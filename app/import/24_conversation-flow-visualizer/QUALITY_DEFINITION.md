# 品質定義書 - 会話フロービジュアライザー

## 1. 概要
本書は、「会話フロービジュアライザー」システムの品質目標、品質保証活動、および評価基準について定義する。利用者に価値を提供し、継続的に利用される高品質なシステムを目指す。

**プロジェクトリポジトリ**: `conversation-flow-visualizer`

## 2. 品質目標

本システムは、以下の品質特性を重視する。

### 2.1. 機能性 (Functionality)
*   **適合性**: 仕様書 (`SPECIFICATION_DOCUMENT.md`) に定義された機能要件を正確に満たしていること。
*   **正確性**: 音声認識の結果、ノード分割、エッジ接続などが意図通り正確に処理・表示されること。
*   **相互運用性**: (将来) 他システムやデータ形式との連携がスムーズに行えること (例: JSONエクスポート/インポート)。
*   **セキュリティ性 (機能観点)**: APIキーなどの機密情報が適切に取り扱われること。

### 2.2. 信頼性 (Reliability)
*   **成熟性**: 通常の利用シナリオにおいて、クラッシュや予期せぬエラーが頻繁に発生しないこと。
*   **耐故障性**: APIエラー、不正な入力、マイクアクセス拒否などの例外的な状況が発生した場合でも、システムがハングアップせず、適切なエラーメッセージを表示し、可能な限り安全な状態に復帰できること。
*   **回復性**: エラー発生後、ユーザーが操作を再試行できる、あるいはアプリケーションを再起動することで正常な状態に戻せること。

### 2.3. 使用性 (Usability)
*   **理解容易性**: UIが直感的で、ユーザーが特別なトレーニングなしにシステムの機能や操作方法を理解できること。
*   **習得容易性**: ユーザーが短時間でシステムの操作に習熟できること。
*   **操作容易性**: 録音開始/停止、ズーム/パン、ノード選択などの主要な操作が簡単かつ効率的に行えること。
*   **魅力性**: UIデザインがモダンで、ユーザーが快適に利用できること (`ui_ux_spec`準拠)。
*   **アクセシビリティ**:
    *   WCAG 2.1 AAレベルのコントラスト比を確保。
    *   キーボード操作による主要機能へのアクセス。
    *   ARIA属性の適切な使用によるスクリーンリーダー対応。

### 2.4. 効率性 (Efficiency)
*   **時間効率性 (パフォーマンス)**:
    *   リアルタイム処理のレイテンシ目標達成（音声認識: 500ms以内）。
    *   UI描画の目標フレームレート60fps。
    *   1時間の会話データ（約600ノード）でも操作が遅延しないこと。
*   **資源効率性**: ブラウザのメモリやCPUリソースを過度に消費しないこと。不要なリソース (Blob URL, MediaStreamトラック等) は適切に解放すること。

### 2.5. 保守性 (Maintainability)
*   **解析容易性**: コードやコンポーネントの構造が理解しやすく、不具合の原因特定が容易であること。
*   **変更容易性**: 仕様変更や機能追加に対して、コードの修正が局所的かつ容易に行えること。
*   **安定性 (変更影響)**: コード変更が予期せぬ副作用を他の部分に与えにくいこと。
*   **試験容易性**: 各コンポーネントや機能がテストしやすい設計であること。
*   **コード品質**:
    *   一貫性のあるコーディングスタイル。
    *   適切なコメントとドキュメント。
    *   可読性の高い変数名・関数名。
    *   コンポーネントの適切な分割と関心の分離。

### 2.6. 移植性 (Portability) - (限定的)
*   **適応性**: 主要なモダンブラウザ (Chrome, Firefox, Edge, Safariの最新版) で概ね同様に動作すること。
*   **設置性**: (AI Studio環境では該当しないが、ローカル開発やセルフホスティングを考慮する場合) 開発環境や実行環境のセットアップが容易であること。

## 3. テスト方針

### 3.1. 開発者による動作確認
*   各機能実装後、開発者は主要なユースケースに沿って手動で動作確認を行う。
*   Chrome開発者ツール等を利用し、コンソールエラーやネットワークリクエスト/レスポンスを確認する。

### 3.2. 単体テスト (Unit Testing) - 将来導入検討
*   **対象**: 純粋なロジックを持つ関数（例: `blobToBase64`、キーワード抽出処理など）、副作用の少ないReactコンポーネントの描画テスト。
*   **ツール**: Jest, React Testing Libraryなど。

### 3.3. 結合テスト (Integration Testing) - 将来導入検討
*   **対象**: 複数のコンポーネントやモジュールが連携する機能（例: 録音開始からノード表示までの一連のフロー）。
*   **ツール**: React Testing Library, Playwright/Cypress (E2Eに近い形でのテストも含む)。

### 3.4. UI/UXテスト
*   **手動テスト**: `ui_ux_spec` に基づき、レイアウト、スタイル、インタラクションが仕様通りであることを確認。
*   **ユーザビリティ評価**: 開発者自身がユーザー視点で操作し、直感性や操作性に問題がないか評価。将来的には実際のユーザーによるテストも検討。

### 3.5. パフォーマンステスト
*   **手動テスト**: 長時間利用や多数ノード生成時の体感速度、ブラウザのプロファイラを用いたリソース使用状況の確認。

### 3.6. アクセシビリティテスト
*   キーボードのみでの操作確認。
*   Axe DevToolsなどのブラウザ拡張機能を用いた自動チェック。
*   （可能であれば）スクリーンリーダーを用いた読み上げ確認。

## 4. コード品質基準

*   **命名規則**: 変数名、関数名、クラス名等は、その役割が明確にわかるように命名する (例: キャメルケース、パスカルケースを適切に使い分ける)。
*   **コメント**: 複雑なロジックや、自明でない処理には適切なコメントを付与する。ただし、コード自体で意図が伝わるように記述することを優先する。
*   **フォーマット**: Prettierなどのフォーマッタを利用し、コード全体のフォーマットを統一する。
*   **Linter**: ESLintなどのLinterを利用し、潜在的なバグやコードスタイルの問題を早期に検出する。
*   **DRY原則 (Don't Repeat Yourself)**: 同じロジックの繰り返しを避け、共通化できる部分は関数やコンポーネントに切り出す。
*   **関心の分離**: 各モジュールやコンポーネントは、単一の責任を持つように設計する。
*   **TypeScriptの型活用**: `any` 型の使用は極力避け、適切な型定義を行うことで型安全性を高める。
*   **エラーハンドリング**: 予期されるエラーは適切にキャッチし、ユーザーに分かりやすいフィードバックを提供するか、安全に処理を継続する。
*   **セキュリティ**: APIキーなどの機密情報をコードにハードコードしない (`process.env`経由で取得)。
*   **依存関係の最小化**: 不必要なライブラリの導入は避け、プロジェクトの複雑性を抑える。

## 5. 品質保証活動の記録
*   主要なバグや問題点は、イシュー管理システム（GitHub Issuesなど、プロジェクトがホストされる場合）または `PROJECT_STATUS.md` の備考欄に記録する。
*   テスト結果や品質評価のサマリーは、各フェーズの完了報告時に含めることを検討する。