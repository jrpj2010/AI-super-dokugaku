<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini 2.5 TTS - å…¨è©±è€…å¯¾å¿œéŸ³å£°åˆæˆã‚·ã‚¹ãƒ†ãƒ </title>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #3b82f6;
            --success-color: #10b981;
            --error-color: #ef4444;
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --border-color: #e2e8f0;
            --male-color: #3b82f6;
            --female-color: #ec4899;
            --neutral-color: #8b5cf6;
            --info-color: #06b6d4;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* ãƒ˜ãƒƒãƒ€ãƒ¼ */
        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 2rem 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }

        /* ãƒ¢ãƒ‡ãƒ«é¸æŠ */
        .model-selector {
            background: rgba(255, 255, 255, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .model-selector label {
            font-weight: 600;
        }

        .model-selector select {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            border: none;
            background: white;
            color: var(--text-primary);
            font-size: 1rem;
            cursor: pointer;
        }

        /* è¨€èªã‚µãƒãƒ¼ãƒˆæƒ…å ± */
        .language-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        /* ã‚¿ãƒ– */
        .tabs {
            display: flex;
            gap: 0;
            margin: 2rem 0 0 0;
            background: var(--card-bg);
            border-radius: 12px 12px 0 0;
            overflow: hidden;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
        }

        .tab {
            flex: 1;
            padding: 1.5rem 2rem;
            background: var(--card-bg);
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            position: relative;
        }

        .tab:hover {
            background: #f1f5f9;
        }

        .tab.active {
            color: var(--primary-color);
            background: var(--card-bg);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-color);
        }

        /* ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ */
        .main-content {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            min-height: 600px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* ã‚«ãƒ†ã‚´ãƒªãƒ¼ */
        .voice-category {
            margin-bottom: 2rem;
        }

        .category-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding: 0.75rem;
            background: #f8fafc;
            border-radius: 8px;
        }

        .category-icon {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 1.2rem;
        }

        .category-icon.male {
            background: var(--male-color);
            color: white;
        }

        .category-icon.female {
            background: var(--female-color);
            color: white;
        }

        .category-icon.neutral {
            background: var(--neutral-color);
            color: white;
        }

        .category-icon.info {
            background: var(--info-color);
            color: white;
        }

        .category-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* è©±è€…é¸æŠã‚°ãƒªãƒƒãƒ‰ */
        .voice-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .voice-card {
            background: #f8fafc;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .voice-card:hover {
            border-color: var(--primary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .voice-card.selected {
            border-color: var(--primary-color);
            background: #eff6ff;
        }

        .voice-card.selected::after {
            content: 'âœ“';
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 24px;
            height: 24px;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .voice-card .voice-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .voice-card .voice-name {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.25rem;
        }

        .voice-card .voice-desc {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .voice-card .voice-lang {
            font-size: 0.75rem;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        .voice-card button {
            margin-top: 0.5rem;
            padding: 0.25rem 0.75rem;
            font-size: 0.875rem;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
            width: 100%;
        }

        .voice-card button:hover {
            background: var(--secondary-color);
        }

        .voice-card button:disabled {
            background: #94a3b8;
            cursor: not-allowed;
        }

        /* å…±é€šã‚¹ã‚¿ã‚¤ãƒ« */
        .section {
            margin-bottom: 2rem;
        }

        .section h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        textarea {
            width: 100%;
            padding: 1rem;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            font-size: 1rem;
            resize: vertical;
            transition: border-color 0.3s ease;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        button {
            padding: 0.75rem 2rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.3);
        }

        .btn-primary:disabled {
            background: #94a3b8;
            cursor: not-allowed;
            transform: none;
        }

        /* ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º */
        .status {
            margin: 1.5rem 0;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            display: none;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
            border: 1px solid #6ee7b7;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }

        .status.loading {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }

        /* ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ */
        audio {
            width: 100%;
            margin-top: 1.5rem;
            border-radius: 8px;
        }

        /* SRTå°‚ç”¨ã‚¹ã‚¿ã‚¤ãƒ« */
        .file-upload {
            border: 3px dashed var(--border-color);
            border-radius: 12px;
            padding: 3rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8fafc;
        }

        .file-upload:hover {
            border-color: var(--primary-color);
            background: #eff6ff;
        }

        .file-upload.drag-over {
            border-color: var(--primary-color);
            background: #dbeafe;
        }

        .file-info {
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .file-info h3 {
            font-size: 1.2rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .stat-item {
            background: white;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .stat-item .label {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .stat-item .value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }

        /* ä¼šè©±å…¥åŠ› */
        .conversation-lines {
            margin: 1.5rem 0;
        }

        .conversation-line {
            display: grid;
            grid-template-columns: 200px 1fr 150px auto;
            gap: 1rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: #f8fafc;
            border-radius: 8px;
            align-items: center;
        }

        select, input {
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .btn-remove {
            background: var(--error-color);
            color: white;
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
        }

        .btn-remove:hover {
            background: #dc2626;
        }

        .btn-add {
            background: var(--success-color);
            color: white;
            margin-top: 1rem;
        }

        .btn-add:hover {
            background: #059669;
        }

        /* ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚° */
        .speaker-mapping {
            background: #f1f5f9;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1.5rem 0;
        }

        .speaker-mapping h3 {
            font-size: 1.2rem;
            margin-bottom: 1rem;
        }

        .mapping-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .mapping-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .speaker-icon {
            width: 40px;
            height: 40px;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
        }

        /* SRTãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚¹ã‚¿ã‚¤ãƒ« */
        .srt-preview-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            background: #f8fafc;
            margin-top: 1rem;
        }

        .srt-preview-item {
            padding: 1rem;
            margin: 0.5rem 0;
            background: white;
            border-radius: 6px;
            border: 1px solid var(--border-color);
        }

        .srt-preview-container::-webkit-scrollbar {
            width: 8px;
        }

        .srt-preview-container::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .srt-preview-container::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .srt-preview-container::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        /* ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ */
        .style-settings {
            background: #f8fafc;
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border: 1px solid var(--border-color);
        }

        .style-toggle {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .style-toggle button {
            flex: 1;
            padding: 0.5rem 1rem;
            border: 2px solid var(--primary-color);
            background: white;
            color: var(--primary-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .style-toggle button.active {
            background: var(--primary-color);
            color: white;
        }

        .style-toggle button:hover:not(.active) {
            background: #eff6ff;
        }

        .style-input {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            font-size: 0.95rem;
            transition: border-color 0.3s ease;
        }

        .style-input:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .style-hint {
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        /* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ– */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.75rem;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                padding: 1rem;
                font-size: 1rem;
            }
            
            .conversation-line {
                grid-template-columns: 1fr;
                gap: 0.5rem;
            }
            
            .main-content {
                padding: 1.5rem;
            }

            .voice-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }
        }

        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¹ãƒ”ãƒŠãƒ¼ */
        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 0.5rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="container">
            <h1>
                <span>ğŸ™ï¸</span>
                Gemini 2.5 TTS <span style="font-size: 0.6em; opacity: 0.8;">v1.1.0</span>
            </h1>
            <p class="subtitle">Googleæœ€æ–°AIãƒ¢ãƒ‡ãƒ«ã«ã‚ˆã‚‹å…¨è©±è€…å¯¾å¿œéŸ³å£°åˆæˆã‚·ã‚¹ãƒ†ãƒ </p>
            
            <div class="model-selector">
                <label for="model-select">ãƒ¢ãƒ‡ãƒ«é¸æŠ:</label>
                <select id="model-select" onchange="updateModel()">
                    <option value="gemini-2.5-flash-preview-tts">Gemini 2.5 Flash Preview TTS (é«˜é€Ÿ)</option>
                    <option value="gemini-2.5-pro-preview-tts">Gemini 2.5 Pro Preview TTS (é«˜å“è³ª)</option>
                </select>
            </div>
            
            <div class="language-info">
                ğŸŒ å¯¾å¿œè¨€èª: æ—¥æœ¬èªã€è‹±èªã€ä¸­å›½èªã€éŸ“å›½èªãªã©24è¨€èªã«å¯¾å¿œ
            </div>
            
            <div class="language-info" style="background: rgba(255, 193, 7, 0.2); margin-top: 0.5rem;">
                âš ï¸ ãƒ¬ãƒ¼ãƒˆåˆ¶é™: 1åˆ†ã‚ãŸã‚Š10ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¾ã§ã€‚é€£ç¶šä½¿ç”¨æ™‚ã¯ã”æ³¨æ„ãã ã•ã„ã€‚
            </div>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('simple')">
                ã‚·ãƒ³ãƒ—ãƒ«éŸ³å£°ç”Ÿæˆ
            </button>
            <button class="tab" onclick="switchTab('conversation')">
                è¤‡æ•°è©±è€…å¯¾è©±
            </button>
            <button class="tab" onclick="switchTab('srt')">
                SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«
            </button>
        </div>

        <div class="main-content">
            <!-- ã‚·ãƒ³ãƒ—ãƒ«éŸ³å£°ç”Ÿæˆã‚¿ãƒ– -->
            <div id="simple-tab" class="tab-content active">
                <div class="section">
                    <div class="form-group">
                        <label for="simple-text">ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼š</label>
                        <textarea id="simple-text" rows="5" placeholder="ã“ã“ã«éŸ³å£°åŒ–ã—ãŸã„ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„...">ã“ã‚“ã«ã¡ã¯ã€ã“ã‚Œã¯Gemini 2.5 TTSãƒ¢ãƒ‡ãƒ«ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚è‡ªç„¶ã§æ»‘ã‚‰ã‹ãªéŸ³å£°ã‚’ç”Ÿæˆã§ãã¾ã™ã€‚</textarea>
                    </div>
                    
                    <!-- ä¼šè©±ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š -->
                    <div class="style-settings">
                        <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem;">ä¼šè©±ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š</h3>
                        <div class="style-toggle">
                            <button class="active" onclick="toggleStyleMode('simple', 'auto')">ğŸ¤– è‡ªå‹•ç”Ÿæˆ</button>
                            <button onclick="toggleStyleMode('simple', 'manual')">âœï¸ æ‰‹å‹•å…¥åŠ›</button>
                        </div>
                        <div id="simple-style-auto" style="display: block;">
                            <p class="style-hint">ãƒ†ã‚­ã‚¹ãƒˆã®å†…å®¹ã‹ã‚‰æœ€é©ãªã‚¹ã‚¿ã‚¤ãƒ«æŒ‡ç¤ºã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã™</p>
                            <div id="simple-auto-style-preview" style="margin-top: 0.5rem; padding: 0.75rem; background: white; border-radius: 6px; border: 1px solid var(--border-color); font-style: italic; color: var(--text-secondary);">
                                ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...
                            </div>
                        </div>
                        <div id="simple-style-manual" style="display: none;">
                            <textarea id="simple-style-input" class="style-input" rows="2" placeholder="ä¾‹: ç–²ã‚ŒãŸæ§˜å­ã§è©±ã™ã€æ˜ã‚‹ãå…ƒæ°—ã«è©±ã™ã€ç·Šå¼µã—ãªãŒã‚‰è©±ã™ ãªã©ï¼ˆ100æ–‡å­—ä»¥å†…ï¼‰" maxlength="100"></textarea>
                            <p class="style-hint">è©±ã—æ–¹ã®ç‰¹å¾´ã‚„æ„Ÿæƒ…ã‚’æŒ‡å®šã—ã¦ãã ã•ã„</p>
                            <button id="generateSimpleStyleBtn" class="btn-primary" style="margin-top: 0.5rem; padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="generateSimpleStyle()">
                                ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆ
                            </button>
                        </div>
                    </div>
                    
                    <button class="btn-primary" onclick="generateSimpleAudio()">
                        é¸æŠã—ãŸè©±è€…ã§éŸ³å£°ã‚’ç”Ÿæˆ
                    </button>
                    
                    <div id="simple-status" class="status"></div>
                    <audio id="simple-audio" controls style="display: none;"></audio>
                </div>

                <div class="section">
                    <h2>è©±è€…ã‚’é¸æŠ</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1rem;">
                        ã‚¯ãƒªãƒƒã‚¯ã§è©±è€…ã‚’é¸æŠã—ã€ã€Œè©¦è´ã€ãƒœã‚¿ãƒ³ã§å³åº§ã«ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã‚’èã‘ã¾ã™
                    </p>
                    
                    <div id="voice-categories">
                        <!-- ã‚«ãƒ†ã‚´ãƒªãƒ¼ãŒã“ã“ã«å‹•çš„ã«ç”Ÿæˆã•ã‚Œã¾ã™ -->
                    </div>
                </div>
            </div>

            <!-- è¤‡æ•°è©±è€…å¯¾è©±ã‚¿ãƒ– -->
            <div id="conversation-tab" class="tab-content">
                <div class="section">
                    <h2>è¤‡æ•°è©±è€…ã«ã‚ˆã‚‹å¯¾è©±ç”Ÿæˆ</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        ç•°ãªã‚‹è©±è€…ã¨æ„Ÿæƒ…ã‚’çµ„ã¿åˆã‚ã›ã¦ã€ãƒªã‚¢ãƒ«ãªå¯¾è©±éŸ³å£°ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
                    </p>
                    
                    <div style="background: #e0f2fe; border: 1px solid #0284c7; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                        <p style="margin: 0; color: #075985;">
                            <strong>â„¹ï¸ æ¨å¥¨</strong>: æœ€é©ãªéŸ³å£°å“è³ªã®ãŸã‚ã€<strong>2è©±è€…ã§ã®å¯¾è©±</strong>ã‚’æ¨å¥¨ã—ã¾ã™ã€‚
                        </p>
                    </div>
                    
                    <div id="conversation-lines" class="conversation-lines">
                        <div class="conversation-line">
                            <select class="speaker-select" onchange="updateSpeakerMapping()">
                                <!-- ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯å‹•çš„ã«ç”Ÿæˆã•ã‚Œã¾ã™ -->
                            </select>
                            <input type="text" class="text-input" placeholder="ã‚»ãƒªãƒ•ã‚’å…¥åŠ›..." value="ã“ã‚“ã«ã¡ã¯ï¼ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™ã­ã€‚">
                            <select class="emotion-select">
                                <option value="">é€šå¸¸</option>
                                <option value="happy">å–œã³</option>
                                <option value="sad">æ‚²ã—ã¿</option>
                                <option value="angry">æ€’ã‚Š</option>
                                <option value="excited">èˆˆå¥®</option>
                                <option value="calm">è½ã¡ç€ã</option>
                            </select>
                            <button class="btn-remove" onclick="removeLine(this)">å‰Šé™¤</button>
                        </div>
                    </div>
                    
                    <button class="btn-add" onclick="addConversationLine()">
                        + è¡Œã‚’è¿½åŠ 
                    </button>
                    
                    <div class="speaker-mapping">
                        <h3>è©±è€…è¨­å®š</h3>
                        <div id="speaker-mapping-display" class="mapping-grid"></div>
                    </div>
                    
                    <!-- ä¼šè©±ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š -->
                    <div class="style-settings">
                        <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem;">ä¼šè©±ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š</h3>
                        <div class="style-toggle">
                            <button class="active" onclick="toggleStyleMode('conversation', 'auto')">ğŸ¤– è‡ªå‹•ç”Ÿæˆ</button>
                            <button onclick="toggleStyleMode('conversation', 'manual')">âœï¸ æ‰‹å‹•å…¥åŠ›</button>
                        </div>
                        <div id="conversation-style-auto" style="display: block;">
                            <p class="style-hint">å¯¾è©±å†…å®¹ã‹ã‚‰æœ€é©ãªã‚¹ã‚¿ã‚¤ãƒ«æŒ‡ç¤ºã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã™</p>
                            <div id="conversation-auto-style-preview" style="margin-top: 0.5rem; padding: 0.75rem; background: white; border-radius: 6px; border: 1px solid var(--border-color); font-style: italic; color: var(--text-secondary);">
                                ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...
                            </div>
                        </div>
                        <div id="conversation-style-manual" style="display: none;">
                            <textarea id="conversation-style-input" class="style-input" rows="2" placeholder="ä¾‹: ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ãªå‹äººåŒå£«ã®ä¼šè©±ã€ãƒ“ã‚¸ãƒã‚¹ã®æ‰“ã¡åˆã‚ã›ã€è¦ªå­ã®æ¸©ã‹ã„ä¼šè©± ãªã©ï¼ˆ100æ–‡å­—ä»¥å†…ï¼‰" maxlength="100"></textarea>
                            <p class="style-hint">ä¼šè©±å…¨ä½“ã®é›°å›²æ°—ã‚„çŠ¶æ³ã‚’æŒ‡å®šã—ã¦ãã ã•ã„</p>
                            <button id="generateConversationStyleBtn" class="btn-primary" style="margin-top: 0.5rem; padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="generateConversationStyle()">
                                ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆ
                            </button>
                        </div>
                    </div>
                    
                    <button class="btn-primary" onclick="generateConversationAudio()">
                        å¯¾è©±éŸ³å£°ã‚’ç”Ÿæˆ
                    </button>
                    
                    <div id="conversation-status" class="status"></div>
                    <audio id="conversation-audio" controls style="display: none;"></audio>
                </div>
            </div>

            <!-- SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚¿ãƒ– -->
            <div id="srt-tab" class="tab-content">
                <div class="section">
                    <h2>SRTå­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰éŸ³å£°ç”Ÿæˆ</h2>
                    <p style="color: var(--text-secondary); margin-bottom: 1.5rem;">
                        SRTå½¢å¼ã®å­—å¹•ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ã€è‡ªå‹•çš„ã«è©±è€…ã‚’èªè­˜ã—éŸ³å£°ã‚’ç”Ÿæˆã—ã¾ã™ã€‚
                    </p>
                    
                    <div style="background: #fef3c7; border: 1px solid #f59e0b; border-radius: 8px; padding: 1rem; margin-bottom: 1.5rem;">
                        <h3 style="color: #92400e; margin: 0 0 0.5rem 0; font-size: 1.1rem;">âš ï¸ é‡è¦ãªåˆ¶é™äº‹é …</h3>
                        <ul style="margin: 0; padding-left: 1.5rem; color: #92400e;">
                            <li><strong>2è©±è€…ã¾ã§å¯¾å¿œ</strong>: ç¾åœ¨ã®APIã¯æœ€å¤§2åã®è©±è€…ã¾ã§ã—ã‹å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚</li>
                            <li>3è©±è€…ä»¥ä¸Šã®SRTãƒ•ã‚¡ã‚¤ãƒ«ã®å ´åˆã€æœ€åˆã®è©±è€…ã®éŸ³å£°ã®ã¿ãŒå†ç”Ÿã•ã‚Œã¾ã™ã€‚</li>
                            <li><strong>å‡¦ç†æ™‚é–“åˆ¶é™</strong>: Cloud Runã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆåˆ¶é™ã«ã‚ˆã‚Šã€5åˆ†ä»¥å†…ã«å‡¦ç†ãŒå®Œäº†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</li>
                            <li>é•·æ™‚é–“ã®SRTãƒ•ã‚¡ã‚¤ãƒ«ã¯åˆ†å‰²ã—ã¦å‡¦ç†ã™ã‚‹ã“ã¨ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                        <button class="btn-primary" onclick="switchSRTMode('file')" id="srt-file-mode-btn">
                            ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
                        </button>
                        <button class="btn-primary" onclick="switchSRTMode('text')" id="srt-text-mode-btn" style="background: #64748b;">
                            âœï¸ ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿
                        </button>
                    </div>
                    
                    <div id="srt-file-mode">
                        <div class="file-upload" id="file-upload" onclick="document.getElementById('srt-file').click()">
                            <input type="file" id="srt-file" accept=".srt" style="display: none;" onchange="handleFileSelect(event)">
                            <div style="font-size: 3rem; margin-bottom: 1rem;">ğŸ“</div>
                            <p style="font-size: 1.2rem; font-weight: 600; margin-bottom: 0.5rem;">
                                SRTãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
                            </p>
                            <p style="color: var(--text-secondary);">
                                ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
                            </p>
                        </div>
                    </div>
                    
                    <div id="srt-text-mode" style="display: none;">
                        <div class="form-group">
                            <label for="srt-text-input" style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; display: block;">
                                SRTå½¢å¼ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ï¼š
                            </label>
                            <textarea id="srt-text-input" rows="15" placeholder="1&#10;00:00:00,000 --> 00:00:03,000&#10;ç”°ä¸­: ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™ã­ã€‚&#10;&#10;2&#10;00:00:03,500 --> 00:00:06,500&#10;ä½è—¤: ãã†ã§ã™ã­ã€‚æ•£æ­©æ—¥å’Œã§ã™ã€‚&#10;&#10;â€»æ³¨æ„: å„ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã®å‰ã«é€£ç•ªï¼ˆ1, 2, 3...ï¼‰ãŒå¿…è¦ã§ã™" style="width: 100%; font-family: monospace; font-size: 0.9rem;"></textarea>
                        </div>
                        <button class="btn-primary" onclick="processSRTText()">
                            SRTãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†
                        </button>
                    </div>
                    
                    <button class="btn-primary" style="margin-top: 1rem;" onclick="loadSampleSRT()">
                        ã‚µãƒ³ãƒ—ãƒ«SRTã‚’èª­ã¿è¾¼ã‚€
                    </button>
                    
                    <div id="file-info" class="file-info" style="display: none;">
                        <h3>ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±</h3>
                        <div class="stats-grid">
                            <div class="stat-item">
                                <div class="label">ãƒ•ã‚¡ã‚¤ãƒ«å</div>
                                <div class="value" id="file-name">-</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">ç·è¡Œæ•°</div>
                                <div class="value" id="total-lines">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">è©±è€…æ•°</div>
                                <div class="value" id="speaker-count">0</div>
                            </div>
                            <div class="stat-item">
                                <div class="label">ç·æ™‚é–“</div>
                                <div class="value" id="total-duration">00:00</div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="srt-speaker-mapping" class="speaker-mapping" style="display: none;">
                        <h3>è©±è€…ã¨éŸ³å£°ã®å‰²ã‚Šå½“ã¦</h3>
                        <div id="srt-speaker-selects"></div>
                    </div>
                    
                    <div id="srt-content" style="margin-top: 1.5rem;"></div>
                    
                    <!-- ä¼šè©±ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š -->
                    <div id="srt-style-settings" class="style-settings" style="display: none;">
                        <h3 style="margin: 0 0 1rem 0; font-size: 1.1rem;">ä¼šè©±ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š</h3>
                        <div class="style-toggle">
                            <button class="active" onclick="toggleStyleMode('srt', 'auto')">ğŸ¤– è‡ªå‹•ç”Ÿæˆ</button>
                            <button onclick="toggleStyleMode('srt', 'manual')">âœï¸ æ‰‹å‹•å…¥åŠ›</button>
                        </div>
                        <div id="srt-style-auto" style="display: block;">
                            <p class="style-hint">SRTå†…å®¹ã‹ã‚‰æœ€é©ãªã‚¹ã‚¿ã‚¤ãƒ«æŒ‡ç¤ºã‚’è‡ªå‹•ç”Ÿæˆã—ã¾ã™</p>
                            <div id="srt-auto-style-preview" style="margin-top: 0.5rem; padding: 0.75rem; background: white; border-radius: 6px; border: 1px solid var(--border-color); font-style: italic; color: var(--text-secondary);">
                                ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...
                            </div>
                        </div>
                        <div id="srt-style-manual" style="display: none;">
                            <textarea id="srt-style-input" class="style-input" rows="2" placeholder="ä¾‹: ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ã‚¿ãƒªãƒ¼é¢¨ã®ãƒŠãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ã‚¢ãƒ‹ãƒ¡é¢¨ã®æ¼”æŠ€ã€ãƒ©ã‚¸ã‚ªãƒ‰ãƒ©ãƒé¢¨ ãªã©ï¼ˆ100æ–‡å­—ä»¥å†…ï¼‰" maxlength="100"></textarea>
                            <p class="style-hint">éŸ³å£°å…¨ä½“ã®æ¼”å‡ºã‚„é›°å›²æ°—ã‚’æŒ‡å®šã—ã¦ãã ã•ã„</p>
                            <button id="generateSRTStyleBtn" class="btn-primary" style="margin-top: 0.5rem; padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="generateSRTStyle()">
                                ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆ
                            </button>
                        </div>
                    </div>
                    
                    <button id="generate-srt-btn" class="btn-primary" style="display: none; margin-top: 1.5rem;" onclick="generateSRTAudio()">
                        SRTéŸ³å£°ã‚’ç”Ÿæˆ
                    </button>
                    
                    <div id="srt-status" class="status"></div>
                    <audio id="srt-audio" controls style="display: none;"></audio>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let currentTab = 'simple';
        let srtData = null;
        let selectedVoice = 'Puck';
        let currentModel = 'gemini-2.5-flash-preview-tts';
        let srtSpeakerMapping = {};
        let sampleAudios = {};
        let styleMode = {
            simple: 'auto',
            conversation: 'auto',
            srt: 'auto'
        };
        let autoGeneratedStyles = {
            simple: '',
            conversation: '',
            srt: ''
        };

        // ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ¥ã®è©±è€…ãƒªã‚¹ãƒˆï¼ˆå®Ÿéš›ã®è´ãæ¯”ã¹ã«åŸºã¥ãåˆ†é¡ï¼‰
        const voiceCategories = {
            'female': {
                title: 'å¥³æ€§ã®å£°',
                icon: 'ğŸ‘©',
                voices: [
                    { id: 'Leda', name: 'Leda', desc: 'ã‚¢ãƒ‹ãƒ¡å£°ãƒ»è‹¥ã„å¥³æ€§ãƒ»æ˜ã‚‹ã„', icon: 'ğŸŒ¸' },
                    { id: 'Aoede', name: 'Aoede', desc: 'æˆäººå¥³æ€§ãƒ»ã‚»ã‚¯ã‚·ãƒ¼ãƒ»å°‘ã—å£°æ¯ã‚Œ', icon: 'ğŸ’‹' },
                    { id: 'Autonoe', name: 'Autonoe', desc: 'æˆäººå¥³æ€§ãƒ»è½ã¡ç€ã„ãŸãƒ»å°‘å¹´ã£ã½ã•ã‚‚', icon: 'ğŸŒ™' },
                    { id: 'Callirrhoe', name: 'Callirrhoe', desc: 'æˆäººå¥³æ€§ãƒ»AIã£ã½ã„ãƒ»èããªã‚ŒãŸ', icon: 'ğŸ¤–' },
                    { id: 'Despina', name: 'Despina', desc: 'ã‚¢ãƒ‹ãƒ¡å£°ãƒ»ã‚»ã‚¯ã‚·ãƒ¼ãƒ»å¥½å°è±¡', icon: 'âœ¨' },
                    { id: 'Erinome', name: 'Erinome', desc: 'æˆäººå¥³æ€§ãƒ»æ˜ã‚‹ã„ãƒ»èããªã‚ŒãŸ', icon: 'â˜€ï¸' },
                    { id: 'Kore', name: 'Kore', desc: 'æˆäººå¥³æ€§ãƒ»æ˜ã‚‹ã„ãƒ»æ¥½ã—ãã†', icon: 'ğŸ˜Š' },
                    { id: 'Laomedeia', name: 'Laomedeia', desc: 'æˆäººå¥³æ€§ãƒ»è½ã¡ç€ã„ãŸãƒ»ãƒŠãƒ¬ãƒ¼ã‚¿ãƒ¼å‘ã', icon: 'ğŸ™ï¸' },
                    { id: 'Sulafat', name: 'Sulafat', desc: 'ã‚¢ãƒ‹ãƒ¡å£°ãƒ»ã‚»ã‚¯ã‚·ãƒ¼ãƒ»è½ã¡ç€ã„ãŸ', icon: 'ğŸŒ¹' },
                    { id: 'Vindemiatrix', name: 'Vindemiatrix', desc: 'ã‚ªãƒã‚µãƒ³ãƒ»æ˜ã‚‹ã„ãƒ»å£°æ¯ã‚Œ', icon: 'ğŸ‘µ' },
                    { id: 'Zephyr', name: 'Zephyr', desc: 'æˆäººå¥³æ€§ãƒ»è½ã¡ç€ã„ãŸãƒ»é€šã‚‹å£°', icon: 'ğŸ¤' },
                    { id: 'Achernar', name: 'Achernar', desc: 'å£°ãŒä½ã‚ã®å¥³æ€§ãƒ»å°‘å¹´ã£ã½ã•ã‚‚', icon: 'ğŸ­' }
                ]
            },
            'male': {
                title: 'ç”·æ€§ã®å£°',
                icon: 'ğŸ‘¨',
                voices: [
                    { id: 'Puck', name: 'Puck', desc: 'æˆäººç”·æ€§ãƒ»ãƒŠãƒ¬ãƒ¼ã‚¿ãƒ¼å‘ããƒ»èª å®Ÿãã†', icon: 'ğŸ“¢' },
                    { id: 'Charon', name: 'Charon', desc: 'æˆäººç”·æ€§ãƒ»è½ã¡ç€ã„ãŸãƒ»é ­ãŒè‰¯ã•ãã†', icon: 'ğŸ“' },
                    { id: 'Fenrir', name: 'Fenrir', desc: 'é«˜ã„ç”·æ€§ãƒ»ãƒŠãƒ¬ãƒ¼ã‚¿ãƒ¼å‘ããƒ»é€šã‚‹å£°', icon: 'ğŸ“£' },
                    { id: 'Orus', name: 'Orus', desc: 'æˆäººç”·æ€§ãƒ»æ˜ã‚‹ã„ãƒ»èª å®Ÿãã†', icon: 'ğŸ˜„' },
                    { id: 'Enceladus', name: 'Enceladus', desc: 'ãƒ’ãƒ­ã‚·ãƒ»è½ã¡ç€ã„ãŸãƒ»çˆ¶è¦ª', icon: 'ğŸ‘¨â€ğŸ‘§' },
                    { id: 'Iapetus', name: 'Iapetus', desc: 'æˆäººç”·æ€§ãƒ»è½ã¡ç€ã„ãŸãƒ»ãƒŠãƒ¬ãƒ¼ã‚¿ãƒ¼å‘ã', icon: 'ğŸ™ï¸' },
                    { id: 'Algenib', name: 'Algenib', desc: 'å¤–å›½äººç”·æ€§ãƒ»é™½æ°—ãƒ»æ˜ã‚‹ã„', icon: 'ğŸŒ' },
                    { id: 'Rasalgethi', name: 'Rasalgethi', desc: 'æˆäººç”·æ€§ãƒ»ãƒŠãƒ¬ãƒ¼ã‚¿ãƒ¼å‘ããƒ»èª å®Ÿãã†', icon: 'ğŸ“–' },
                    { id: 'Alnilam', name: 'Alnilam', desc: 'ã‚ªã‚¿ã‚¯ç”·æ€§ãƒ»æ ¹æš—', icon: 'ğŸ¤“' },
                    { id: 'Gacrux', name: 'Gacrux', desc: 'å„ªã—ãã†ãƒ»å°‘ã—é«˜ã„å£°ãƒ»ç—©ã›ã¦ãã†', icon: 'ğŸ¤—' },
                    { id: 'Achird', name: 'Achird', desc: 'æˆäººç”·æ€§ãƒ»èª å®Ÿãã†', icon: 'ğŸ¤' },
                    { id: 'Zubenelgenubi', name: 'Zubenelgenubi', desc: 'é›°å›²æ°—ã‚¤ã‚±ãƒ¡ãƒ³ãƒ»å°‘ã—ä½ã‚ã®å£°ãƒ»è½ã¡ç€ã„ãŸ', icon: 'ğŸ˜' },
                    { id: 'Sadaltager', name: 'Sadaltager', desc: 'æˆäººç”·æ€§ãƒ»æ˜ã‚‹ã„', icon: 'â˜€ï¸' },
                    { id: 'Pulcherrima', name: 'Pulcherrima', desc: 'è‹¥ã„ç”·æ€§ãƒ»ãƒ•ãƒ©ãƒ³ã‚¯ãƒ»é›°å›²æ°—ã‚¤ã‚±ãƒ¡ãƒ³', icon: 'âœ¨' },
                    { id: 'Algieba', name: 'Algieba', desc: 'æˆäººç”·æ€§ãƒ»å£°æ¯ã‚Œãƒ»è©æ¬ºå¸«ãƒ»ãƒ€ãƒŸå£°', icon: 'ğŸ­' },
                    { id: 'Schedar', name: 'Schedar', desc: 'æˆäººç”·æ€§ãƒ»ãƒŠãƒãƒ¥ãƒ©ãƒ«ãƒ»è·äºº', icon: 'ğŸ”¨' },
                    { id: 'Sadachbia', name: 'Sadachbia', desc: 'ã‚ªã‚¸ã‚µãƒ³ãƒ»ãƒ¯ã‚¤ãƒ«ãƒ‰ãƒ»æ˜ã‚‹ã„', icon: 'ğŸ¦' },
                    { id: 'Umbriel', name: 'Umbriel', desc: 'æˆäººç”·æ€§ãƒ»AIã£ã½ã„ãƒ»é€šã‚‹å£°', icon: 'ğŸ¤–' }
                ]
            }
        };

        // å…¨è©±è€…ãƒªã‚¹ãƒˆï¼ˆãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ç”¨ï¼‰
        const allVoices = [];
        Object.values(voiceCategories).forEach(category => {
            category.voices.forEach(voice => {
                allVoices.push({
                    id: voice.id,
                    name: voice.name,
                    desc: voice.desc,
                    lang: 'multi',
                    icon: voice.icon,
                    category: category.title
                });
            });
        });

        // åˆæœŸåŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initializeVoiceCategories();
            updateSpeakerOptions();
            updateSpeakerMapping();
            generateAutoStyle('simple'); // åˆæœŸã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆ
            // ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ã®ãŸã‚ã€ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã®äº‹å‰èª­ã¿è¾¼ã¿ã¯ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ
            // preloadSampleAudios();
        });

        // ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã‚’äº‹å‰èª­ã¿è¾¼ã¿ï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ä»˜ãï¼‰
        async function preloadSampleAudios() {
            console.log('ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã®äº‹å‰èª­ã¿è¾¼ã¿ã‚’é–‹å§‹...');
            
            // å„è©±è€…ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆ
            const sampleText = "ã“ã‚“ã«ã¡ã¯ã€ç§ã¯{voice}ã§ã™ã€‚ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ã€‚";
            
            // ãƒãƒƒãƒå‡¦ç†ã§ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã‚’å›é¿
            const batchSize = 5; // ä¸€åº¦ã«å‡¦ç†ã™ã‚‹æ•°
            const delayBetweenBatches = 7000; // 7ç§’å¾…æ©Ÿ
            
            for (let i = 0; i < allVoices.length; i += batchSize) {
                const batch = allVoices.slice(i, i + batchSize);
                
                await Promise.all(batch.map(async (voice) => {
                    try {
                        const text = sampleText.replace('{voice}', voice.name);
                        const response = await fetch('/api/tts', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                text: text,
                                voice: voice.id,
                                model: currentModel
                            })
                        });
                        
                        if (response.ok) {
                            const blob = await response.blob();
                            const audioUrl = URL.createObjectURL(blob);
                            sampleAudios[voice.id] = audioUrl;
                            console.log(`${voice.id}ã®ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ`);
                        }
                    } catch (error) {
                        console.error(`${voice.id}ã®ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:`, error);
                    }
                }));
                
                // æ¬¡ã®ãƒãƒƒãƒã¾ã§å¾…æ©Ÿ
                if (i + batchSize < allVoices.length) {
                    console.log(`ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ã®ãŸã‚${delayBetweenBatches / 1000}ç§’å¾…æ©Ÿä¸­...`);
                    await new Promise(resolve => setTimeout(resolve, delayBetweenBatches));
                }
            }
            
            console.log('ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã®äº‹å‰èª­ã¿è¾¼ã¿å®Œäº†');
        }

        // ãƒ¢ãƒ‡ãƒ«æ›´æ–°
        function updateModel() {
            currentModel = document.getElementById('model-select').value;
            console.log('Model changed to:', currentModel);
            // ãƒ¢ãƒ‡ãƒ«å¤‰æ›´æ™‚ã¯ã‚µãƒ³ãƒ—ãƒ«éŸ³å£°ã‚’å†èª­ã¿è¾¼ã¿
            sampleAudios = {};
            preloadSampleAudios();
        }

        // è©±è€…ã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚’åˆæœŸåŒ–
        function initializeVoiceCategories() {
            const container = document.getElementById('voice-categories');
            container.innerHTML = '';
            
            Object.entries(voiceCategories).forEach(([key, category]) => {
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'voice-category';
                
                const header = document.createElement('div');
                header.className = 'category-header';
                header.innerHTML = `
                    <div class="category-icon ${key}">${category.icon}</div>
                    <div class="category-title">${category.title}</div>
                `;
                categoryDiv.appendChild(header);
                
                const grid = document.createElement('div');
                grid.className = 'voice-grid';
                
                category.voices.forEach(voice => {
                    const card = document.createElement('div');
                    card.className = 'voice-card';
                    if (voice.id === selectedVoice) {
                        card.classList.add('selected');
                    }
                    card.onclick = () => selectVoice(voice.id);
                    
                    card.innerHTML = `
                        <div class="voice-icon">${voice.icon}</div>
                        <div class="voice-name">${voice.name}</div>
                        <div class="voice-desc">${voice.desc}</div>
                        <div class="voice-lang">24è¨€èªå¯¾å¿œ</div>
                        <button id="btn-${voice.id}" onclick="event.stopPropagation(); testVoice('${voice.id}')">
                            è©¦è´
                        </button>
                    `;
                    
                    grid.appendChild(card);
                });
                
                categoryDiv.appendChild(grid);
                container.appendChild(categoryDiv);
            });
        }

        // è©±è€…ã‚’é¸æŠ
        function selectVoice(voiceId) {
            selectedVoice = voiceId;
            document.querySelectorAll('.voice-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');
        }

        // è©±è€…ã‚’è©¦è´ï¼ˆäº‹å‰èª­ã¿è¾¼ã¿æ¸ˆã¿ã®éŸ³å£°ã‚’å³åº§ã«å†ç”Ÿï¼‰
        async function testVoice(voiceId) {
            const button = document.getElementById(`btn-${voiceId}`);
            const originalText = button.textContent;
            
            // æ—¢ã«èª­ã¿è¾¼ã¿æ¸ˆã¿ã®éŸ³å£°ãŒã‚ã‚‹å ´åˆã¯å³åº§ã«å†ç”Ÿ
            if (sampleAudios[voiceId]) {
                const audio = new Audio(sampleAudios[voiceId]);
                audio.play();
                
                button.textContent = 'å†ç”Ÿä¸­...';
                audio.onended = () => {
                    button.textContent = originalText;
                };
                return;
            }
            
            // èª­ã¿è¾¼ã¿æ¸ˆã¿ã§ãªã„å ´åˆã¯ç”Ÿæˆ
            button.disabled = true;
            button.innerHTML = 'ç”Ÿæˆä¸­<span class="loading-spinner"></span>';
            
            try {
                const testText = `ã“ã‚“ã«ã¡ã¯ã€ç§ã¯${voiceId}ã§ã™ã€‚ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ã€‚`;
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        text: testText,
                        voice: voiceId,
                        model: currentModel
                    })
                });
                
                if (!response.ok) {
                    throw new Error('éŸ³å£°ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å†ç”Ÿï¼ˆè©¦è´ç”¨ï¼‰
                const reader = response.body.getReader();
                const chunks = [];
                let firstChunkReceived = false;
                const audio = new Audio();
                
                const readStream = async () => {
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        chunks.push(value);
                        
                        // æœ€åˆã®ãƒãƒ£ãƒ³ã‚¯ã§å†ç”Ÿé–‹å§‹ï¼ˆ16KBä»¥ä¸Šæºœã¾ã£ãŸã‚‰ï¼‰
                        if (!firstChunkReceived && chunks.reduce((sum, chunk) => sum + chunk.length, 0) >= 16384) {
                            const partialBlob = new Blob(chunks, { type: 'audio/wav' });
                            const partialUrl = URL.createObjectURL(partialBlob);
                            audio.src = partialUrl;
                            audio.play().catch(e => console.log('è©¦è´å†ç”Ÿã‚¨ãƒ©ãƒ¼:', e));
                            firstChunkReceived = true;
                            button.textContent = 'å†ç”Ÿä¸­...';
                        }
                    }
                    
                    // å®Œå…¨ãªãƒ‡ãƒ¼ã‚¿ã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ä¿å­˜
                    const fullBlob = new Blob(chunks, { type: 'audio/wav' });
                    const fullUrl = URL.createObjectURL(fullBlob);
                    sampleAudios[voiceId] = fullUrl;
                };
                
                readStream();
                
                audio.onended = () => {
                    button.textContent = originalText;
                    button.disabled = false;
                };
                
            } catch (error) {
                button.textContent = 'ã‚¨ãƒ©ãƒ¼';
                setTimeout(() => {
                    button.textContent = originalText;
                    button.disabled = false;
                }, 2000);
            }
        }

        // è©±è€…ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
        function updateSpeakerOptions() {
            // ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ¥ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            let optionsHTML = '';
            
            // å¥³æ€§ã®å£°
            optionsHTML += '<optgroup label="å¥³æ€§ã®å£° ğŸ‘©">';
            voiceCategories.female.voices.forEach(voice => {
                optionsHTML += `<option value="${voice.id}">${voice.name} - ${voice.desc}</option>`;
            });
            optionsHTML += '</optgroup>';
            
            // ç”·æ€§ã®å£°
            optionsHTML += '<optgroup label="ç”·æ€§ã®å£° ğŸ‘¨">';
            voiceCategories.male.voices.forEach(voice => {
                optionsHTML += `<option value="${voice.id}">${voice.name} - ${voice.desc}</option>`;
            });
            optionsHTML += '</optgroup>';
            
            document.querySelectorAll('.speaker-select').forEach(select => {
                select.innerHTML = optionsHTML;
            });
        }

        // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
        function switchTab(tabName) {
            currentTab = tabName;
            
            // ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // ã‚¿ãƒ–ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®è¡¨ç¤ºã‚’æ›´æ–°
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆæ™‚ã«ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆ
            if (styleMode[tabName] === 'auto') {
                generateAutoStyle(tabName);
            }
        }

        // ã‚¹ã‚¿ã‚¤ãƒ«ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function toggleStyleMode(tab, mode) {
            styleMode[tab] = mode;
            
            // ãƒœã‚¿ãƒ³ã®çŠ¶æ…‹ã‚’æ›´æ–°
            const toggleButtons = document.querySelectorAll(`#${tab}-tab .style-toggle button`);
            toggleButtons.forEach(btn => btn.classList.remove('active'));
            if (mode === 'auto') {
                toggleButtons[0].classList.add('active');
            } else {
                toggleButtons[1].classList.add('active');
            }
            
            // è¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
            const autoDiv = document.getElementById(`${tab}-style-auto`);
            const manualDiv = document.getElementById(`${tab}-style-manual`);
            
            if (mode === 'auto') {
                autoDiv.style.display = 'block';
                manualDiv.style.display = 'none';
                generateAutoStyle(tab);
            } else {
                autoDiv.style.display = 'none';
                manualDiv.style.display = 'block';
            }
        }

        // ã‚¹ã‚¿ã‚¤ãƒ«è‡ªå‹•ç”Ÿæˆé–¢æ•°ï¼ˆã‚µãƒ¼ãƒãƒ¼APIã‚’ä½¿ç”¨ï¼‰
        async function generateStyleForText(text, type) {
            if (!text.trim()) {
                updateStatus('ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return '';
            }

            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 10000);

                const response = await fetch('/api/generate-style', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ text, type }),
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                return data.style || '';
            } catch (error) {
                if (error.name === 'AbortError') {
                    updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ç”ŸæˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚', 'error');
                } else {
                    updateStatus(`ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                }
                return '';
            }
        }

        // è‡ªå‹•ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆï¼ˆå„ã‚¿ãƒ–ç”¨ï¼‰
        async function generateAutoStyle(tab) {
            let content = '';
            const previewElement = document.getElementById(`${tab}-auto-style-preview`);
            
            // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å–å¾—
            if (tab === 'simple') {
                content = document.getElementById('simple-text').value;
            } else if (tab === 'conversation') {
                const lines = document.querySelectorAll('.conversation-line');
                const conversation = [];
                lines.forEach(line => {
                    const text = line.querySelector('.text-input').value;
                    if (text.trim()) {
                        conversation.push(text);
                    }
                });
                content = conversation.join('\n');
            } else if (tab === 'srt' && srtData) {
                content = srtData.slice(0, 5).map(entry => `${entry.speaker}: ${entry.text}`).join('\n');
            }
            
            if (!content || content.trim().length === 0) {
                autoGeneratedStyles[tab] = '';
                if (previewElement) {
                    previewElement.textContent = 'ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“';
                }
                return;
            }
            
            if (previewElement) {
                previewElement.textContent = 'ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...';
            }
            
            const style = await generateStyleForText(content, tab);
            autoGeneratedStyles[tab] = style || getDefaultStyle(tab);
            
            if (previewElement) {
                previewElement.textContent = autoGeneratedStyles[tab] || 'ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸ';
            }
        }

        // å„ã‚¿ãƒ–ã®ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆé–¢æ•°
        async function generateSimpleStyle() {
            const text = document.getElementById('simple-text').value;
            const styleTextarea = document.getElementById('simple-style-input');
            const generateBtn = document.getElementById('generateSimpleStyleBtn');
            
            setButtonLoading('generateSimpleStyleBtn', true);
            updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...', 'processing');
            
            const style = await generateStyleForText(text, 'simple');
            if (style) {
                styleTextarea.value = style;
                updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ã®ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
            }
            
            setButtonLoading('generateSimpleStyleBtn', false);
        }

        async function generateConversationStyle() {
            const lines = document.querySelectorAll('.conversation-line');
            const conversation = [];
            lines.forEach(line => {
                const text = line.querySelector('.text-input').value;
                if (text.trim()) {
                    conversation.push(text);
                }
            });
            const content = conversation.join('\n');
            
            const styleTextarea = document.getElementById('conversation-style-input');
            
            setButtonLoading('generateConversationStyleBtn', true);
            updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...', 'processing');
            
            const style = await generateStyleForText(content, 'conversation');
            if (style) {
                styleTextarea.value = style;
                updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ã®ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
            }
            
            setButtonLoading('generateConversationStyleBtn', false);
        }

        async function generateSRTStyle() {
            if (!srtData || srtData.length === 0) {
                updateStatus('SRTãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚', 'error');
                return;
            }
            
            const content = srtData.slice(0, 5).map(entry => `${entry.speaker}: ${entry.text}`).join('\n');
            const styleTextarea = document.getElementById('srt-style-input');
            
            setButtonLoading('generateSRTStyleBtn', true);
            updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ã‚’ç”Ÿæˆä¸­...', 'processing');
            
            const style = await generateStyleForText(content, 'srt');
            if (style) {
                styleTextarea.value = style;
                updateStatus('ã‚¹ã‚¿ã‚¤ãƒ«ã®ç”ŸæˆãŒå®Œäº†ã—ã¾ã—ãŸï¼', 'success');
            }
            
            setButtonLoading('generateSRTStyleBtn', false);
        }

        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ã‚¿ã‚¤ãƒ«ã‚’å–å¾—
        function getDefaultStyle(tab) {
            const defaults = {
                simple: 'è‡ªç„¶ã§èãå–ã‚Šã‚„ã™ã„å£èª¿ã§è©±ã™',
                conversation: 'ã‚«ã‚¸ãƒ¥ã‚¢ãƒ«ã§è¦ªã—ã¿ã‚„ã™ã„ä¼šè©±',
                srt: 'å ´é¢ã«å¿œã˜ãŸè‡ªç„¶ãªæ¼”æŠ€'
            };
            return defaults[tab] || 'è‡ªç„¶ãªè©±ã—æ–¹';
        }

        // ç¾åœ¨ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’å–å¾—
        function getCurrentStyle(tab) {
            if (styleMode[tab] === 'auto') {
                return autoGeneratedStyles[tab] || getDefaultStyle(tab);
            } else {
                const input = document.getElementById(`${tab}-style-input`);
                return input ? input.value.trim() : '';
            }
        }

        // ã‚·ãƒ³ãƒ—ãƒ«éŸ³å£°ç”Ÿæˆï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å¯¾å¿œï¼‰
        async function generateSimpleAudio() {
            const text = document.getElementById('simple-text').value;
            const status = document.getElementById('simple-status');
            const audio = document.getElementById('simple-audio');
            const button = event.target;
            
            if (!text.trim()) {
                showStatus(status, 'ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            button.disabled = true;
            
            // è‡ªå‹•ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ã§ã€ã‚¹ã‚¿ã‚¤ãƒ«ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ãªã„å ´åˆ
            let style = getCurrentStyle('simple');
            if (styleMode.simple === 'auto' && !style) {
                showStatus(status, 'ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆä¸­...', 'loading');
                style = await generateStyleForText(text, 'simple');
                if (style) {
                    autoGeneratedStyles.simple = style;
                    const previewElement = document.getElementById('simple-auto-style-preview');
                    if (previewElement) {
                        previewElement.textContent = style;
                    }
                }
            }
            
            showStatus(status, 'éŸ³å£°ã‚’ç”Ÿæˆä¸­...', 'loading');
            
            try {
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        text,
                        voice: selectedVoice,
                        model: currentModel,
                        style: style || ''
                    })
                });
                
                if (!response.ok) {
                    throw new Error('éŸ³å£°ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å†ç”Ÿã®å®Ÿè£…
                await streamAudio(response, audio, status);
                
            } catch (error) {
                showStatus(status, 'ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            } finally {
                button.disabled = false;
            }
        }

        // è¤‡æ•°è©±è€…å¯¾è©±ã®è¡Œã‚’è¿½åŠ 
        function addConversationLine() {
            const container = document.getElementById('conversation-lines');
            const newLine = document.createElement('div');
            newLine.className = 'conversation-line';
            
            const optionsHTML = allVoices.map(voice => 
                `<option value="${voice.id}">${voice.name} - ${voice.desc}</option>`
            ).join('');
            
            newLine.innerHTML = `
                <select class="speaker-select" onchange="updateSpeakerMapping()">
                    ${optionsHTML}
                </select>
                <input type="text" class="text-input" placeholder="ã‚»ãƒªãƒ•ã‚’å…¥åŠ›...">
                <select class="emotion-select">
                    <option value="">é€šå¸¸</option>
                    <option value="happy">å–œã³</option>
                    <option value="sad">æ‚²ã—ã¿</option>
                    <option value="angry">æ€’ã‚Š</option>
                    <option value="excited">èˆˆå¥®</option>
                    <option value="calm">è½ã¡ç€ã</option>
                </select>
                <button class="btn-remove" onclick="removeLine(this)">å‰Šé™¤</button>
            `;
            container.appendChild(newLine);
            updateSpeakerMapping();
        }

        // è¡Œã‚’å‰Šé™¤
        function removeLine(button) {
            button.parentElement.remove();
            updateSpeakerMapping();
        }

        // è©±è€…ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æ›´æ–°
        function updateSpeakerMapping() {
            const speakers = new Map();
            document.querySelectorAll('.speaker-select').forEach(select => {
                const speaker = select.value;
                if (!speakers.has(speaker)) {
                    speakers.set(speaker, speaker);
                }
            });
            
            const display = document.getElementById('speaker-mapping-display');
            display.innerHTML = '';
            
            speakers.forEach((voice, speaker) => {
                const voiceInfo = allVoices.find(v => v.id === speaker);
                const item = document.createElement('div');
                item.className = 'mapping-item';
                item.innerHTML = `
                    <div class="speaker-icon">${voiceInfo?.icon || 'ğŸ¤'}</div>
                    <div>
                        <div style="font-weight: 600;">${speaker}</div>
                        <div style="font-size: 0.875rem; color: var(--text-secondary);">${voiceInfo?.desc || 'Unknown'}</div>
                    </div>
                `;
                display.appendChild(item);
            });
        }

        // è¤‡æ•°è©±è€…éŸ³å£°ç”Ÿæˆï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å¯¾å¿œï¼‰
        async function generateConversationAudio() {
            const lines = document.querySelectorAll('.conversation-line');
            const status = document.getElementById('conversation-status');
            const audio = document.getElementById('conversation-audio');
            const button = event.target;
            
            const conversation = [];
            const speakerSet = new Set();
            
            lines.forEach(line => {
                const speaker = line.querySelector('.speaker-select').value;
                const text = line.querySelector('.text-input').value;
                const emotion = line.querySelector('.emotion-select').value;
                
                if (text.trim()) {
                    conversation.push({ speaker, text, emotion });
                    speakerSet.add(speaker);
                }
            });
            
            if (conversation.length === 0) {
                showStatus(status, 'å°‘ãªãã¨ã‚‚1ã¤ã®ã‚»ãƒªãƒ•ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            const speakers = Array.from(speakerSet).map(name => ({
                name,
                voice: name
            }));
            
            button.disabled = true;
            
            // è‡ªå‹•ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ã§ã€ã‚¹ã‚¿ã‚¤ãƒ«ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ãªã„å ´åˆ
            let style = getCurrentStyle('conversation');
            if (styleMode.conversation === 'auto' && !style) {
                showStatus(status, 'ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆä¸­...', 'loading');
                const content = conversation.map(c => c.text).join('\n');
                style = await generateStyleForText(content, 'conversation');
                if (style) {
                    autoGeneratedStyles.conversation = style;
                    const previewElement = document.getElementById('conversation-auto-style-preview');
                    if (previewElement) {
                        previewElement.textContent = style;
                    }
                }
            }
            
            showStatus(status, 'å¯¾è©±éŸ³å£°ã‚’ç”Ÿæˆä¸­...', 'loading');
            
            try {
                const response = await fetch('/api/conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        conversation, 
                        speakers,
                        model: currentModel,
                        style: style || ''
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'éŸ³å£°ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å†ç”Ÿã®å®Ÿè£…
                await streamAudio(response, audio, status);
                
            } catch (error) {
                showStatus(status, 'ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            } finally {
                button.disabled = false;
            }
        }

        // SRTãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
        function switchSRTMode(mode) {
            const fileMode = document.getElementById('srt-file-mode');
            const textMode = document.getElementById('srt-text-mode');
            const fileModeBtn = document.getElementById('srt-file-mode-btn');
            const textModeBtn = document.getElementById('srt-text-mode-btn');
            
            if (mode === 'file') {
                fileMode.style.display = 'block';
                textMode.style.display = 'none';
                fileModeBtn.style.background = '#2563eb'; // --primary-color
                textModeBtn.style.background = '#64748b';
            } else {
                fileMode.style.display = 'none';
                textMode.style.display = 'block';
                fileModeBtn.style.background = '#64748b';
                textModeBtn.style.background = '#2563eb'; // --primary-color
            }
            
            // ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
            const status = document.getElementById('srt-status');
            if (status) {
                status.style.display = 'none';
            }
        }
        
        // SRTãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†
        function processSRTText() {
            const textInput = document.getElementById('srt-text-input');
            const srtText = textInput.value.trim();
            
            if (!srtText) {
                const status = document.getElementById('srt-status');
                showStatus(status, 'SRTãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            console.log('Processing SRT text:', srtText.substring(0, 100) + '...');
            
            try {
                parseSRT(srtText, 'text-input.srt');
            } catch (error) {
                console.error('Error parsing SRT:', error);
                const status = document.getElementById('srt-status');
                showStatus(status, 'SRTãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            }
        }
        
        // SRTãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file && file.name.endsWith('.srt')) {
                readSRTFile(file);
            }
        }

        // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
        const fileUpload = document.getElementById('file-upload');
        
        fileUpload.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUpload.classList.add('drag-over');
        });
        
        fileUpload.addEventListener('dragleave', () => {
            fileUpload.classList.remove('drag-over');
        });
        
        fileUpload.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUpload.classList.remove('drag-over');
            
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.srt')) {
                readSRTFile(file);
            }
        });

        // SRTãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
        function readSRTFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                parseSRT(content, file.name);
            };
            reader.readAsText(file, 'UTF-8');
        }

        // SRTã‚’ãƒ‘ãƒ¼ã‚¹
        function parseSRT(content, fileName) {
            // æ”¹è¡Œã‚’çµ±ä¸€
            content = content.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
            
            const lines = content.trim().split('\n');
            const entries = [];
            let currentEntry = null;
            let state = 'index';
            let entryIndex = 1;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (state === 'index') {
                    // ç©ºè¡Œã¯ã‚¹ã‚­ãƒƒãƒ—
                    if (line === '') continue;
                    
                    // æ•°å­—ã®ã¿ã®è¡Œã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã—ã¦èªè­˜
                    if (/^\d+$/.test(line)) {
                        currentEntry = { index: parseInt(line) };
                        state = 'time';
                    } else if (line.includes('-->')) {
                        // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒãªãç›´æ¥ã‚¿ã‚¤ãƒ ã‚³ãƒ¼ãƒ‰ã®å ´åˆ
                        currentEntry = { index: entryIndex++ };
                        i--; // ã“ã®è¡Œã‚’å†å‡¦ç†
                        state = 'time';
                    }
                } else if (state === 'time') {
                    // ã‚¿ã‚¤ãƒ ã‚³ãƒ¼ãƒ‰ã‚’æ¢ã™
                    if (line.includes('-->')) {
                        const [start, end] = line.split('-->').map(t => t.trim());
                        currentEntry.start = start;
                        currentEntry.end = end;
                        currentEntry.text = '';
                        state = 'text';
                    } else if (line === '') {
                        // ç©ºè¡Œãªã‚‰çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                        state = 'index';
                    }
                } else if (state === 'text') {
                    if (line === '') {
                        // ç©ºè¡Œã§ã‚¨ãƒ³ãƒˆãƒªãƒ¼çµ‚äº†
                        if (currentEntry && currentEntry.text) {
                            entries.push(currentEntry);
                        }
                        currentEntry = null;
                        state = 'index';
                    } else {
                        // ãƒ†ã‚­ã‚¹ãƒˆã‚’è¿½åŠ 
                        if (currentEntry.text) {
                            currentEntry.text += '\n' + line;
                        } else {
                            currentEntry.text = line;
                        }
                    }
                }
            }
            
            // æœ€å¾Œã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã‚’è¿½åŠ 
            if (currentEntry && currentEntry.text && state === 'text') {
                entries.push(currentEntry);
            }
            
            if (currentEntry.text) {
                entries.push(currentEntry);
            }
            
            // è©±è€…ã‚’è‡ªå‹•èªè­˜
            entries.forEach(entry => {
                const match = entry.text.match(/^([^ï¼š:]+)[ï¼š:]\s*(.+)/);
                if (match) {
                    entry.speaker = match[1].trim();
                    entry.text = match[2].trim();
                } else {
                    // è©±è€…ãŒæ˜ç¤ºã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€æ—¢å­˜ã®è©±è€…ã‹ã‚‰æ¨æ¸¬
                    // æœ€åˆã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã¾ãŸã¯å‰ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ã¨åŒã˜è©±è€…ã¨ã™ã‚‹
                    if (entries.indexOf(entry) === 0) {
                        entry.speaker = 'è©±è€…1';
                    } else {
                        const prevEntry = entries[entries.indexOf(entry) - 1];
                        entry.speaker = prevEntry.speaker || 'è©±è€…1';
                    }
                }
                // æ™‚é–“æƒ…å ±ã‚’ä¿æŒ
                entry.startTime = parseTime(entry.start);
                entry.endTime = parseTime(entry.end);
                entry.duration = entry.endTime - entry.startTime;
            });
            
            srtData = entries;
            displaySRTInfo(fileName, entries);
        }

        // SRTæƒ…å ±ã‚’è¡¨ç¤º
        function displaySRTInfo(fileName, entries) {
            document.getElementById('file-name').textContent = fileName;
            document.getElementById('total-lines').textContent = entries.length;
            
            const speakers = new Set(entries.map(e => e.speaker));
            document.getElementById('speaker-count').textContent = speakers.size;
            
            // ç·æ™‚é–“ã‚’è¨ˆç®—
            if (entries.length > 0) {
                const lastEntry = entries[entries.length - 1];
                document.getElementById('total-duration').textContent = lastEntry.end.split(',')[0];
            }
            
            document.getElementById('file-info').style.display = 'block';
            
            // 3è©±è€…ä»¥ä¸Šã®å ´åˆã¯è­¦å‘Šã‚’è¡¨ç¤º
            if (speakers.size > 2) {
                const status = document.getElementById('srt-status');
                showStatus(status, `è­¦å‘Š: ${speakers.size}äººã®è©±è€…ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ç¾åœ¨ã®APIã¯2è©±è€…ã¾ã§ã—ã‹å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚éŸ³å£°ç”Ÿæˆã‚’ç¶šè¡Œã™ã‚‹ã¨ã€æœ€åˆã®è©±è€…ã®éŸ³å£°ã®ã¿ãŒç”Ÿæˆã•ã‚Œã¾ã™ã€‚`, 'error');
                document.getElementById('generate-srt-btn').style.display = 'block';
            } else {
                document.getElementById('generate-srt-btn').style.display = 'block';
            }
            
            // ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®šã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
            document.getElementById('srt-style-settings').style.display = 'block';
            generateAutoStyle('srt');
            
            // è©±è€…ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è¡¨ç¤º
            const speakerMapping = document.getElementById('srt-speaker-mapping');
            const speakerSelects = document.getElementById('srt-speaker-selects');
            speakerMapping.style.display = 'block';
            speakerSelects.innerHTML = '';
            
            Array.from(speakers).forEach((speaker, index) => {
                // è©±è€…åã‹ã‚‰æ€§åˆ¥ã‚’æ¨æ¸¬ã—ã¦æœ€é©ãªéŸ³å£°ã‚’ææ¡ˆ
                const defaultVoice = recommendVoiceForSpeaker(speaker, index);
                srtSpeakerMapping[speaker] = defaultVoice;
                
                const div = document.createElement('div');
                div.style.cssText = 'display: flex; align-items: center; gap: 1rem; margin-bottom: 1rem;';
                
                // ã‚«ãƒ†ã‚´ãƒªãƒ¼åˆ¥ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’ç”Ÿæˆ
                let optionsHTML = '';
                
                // å¥³æ€§ã®å£°
                optionsHTML += '<optgroup label="å¥³æ€§ã®å£° ğŸ‘©">';
                voiceCategories.female.voices.forEach(voice => {
                    optionsHTML += `<option value="${voice.id}" ${voice.id === defaultVoice ? 'selected' : ''}>${voice.name} - ${voice.desc}</option>`;
                });
                optionsHTML += '</optgroup>';
                
                // ç”·æ€§ã®å£°
                optionsHTML += '<optgroup label="ç”·æ€§ã®å£° ğŸ‘¨">';
                voiceCategories.male.voices.forEach(voice => {
                    optionsHTML += `<option value="${voice.id}" ${voice.id === defaultVoice ? 'selected' : ''}>${voice.name} - ${voice.desc}</option>`;
                });
                optionsHTML += '</optgroup>';
                
                div.innerHTML = `
                    <span style="min-width: 150px; font-weight: 600;">${speaker}:</span>
                    <select onchange="srtSpeakerMapping['${speaker}'] = this.value" style="flex: 1;">
                        ${optionsHTML}
                    </select>
                `;
                
                speakerSelects.appendChild(div);
            });
            
            // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º
            const contentDiv = document.getElementById('srt-content');
            contentDiv.innerHTML = '<h3>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</h3><div class="srt-preview-container" id="srt-preview-container"></div>';
            
            const previewContainer = document.getElementById('srt-preview-container');
            entries.forEach(entry => {
                const item = document.createElement('div');
                item.className = 'srt-preview-item';
                item.innerHTML = `
                    <div style="font-size: 0.875rem; color: var(--text-secondary);">${entry.start} â†’ ${entry.end}</div>
                    <div style="margin-top: 0.5rem;">
                        <strong>${entry.speaker}:</strong> ${entry.text}
                    </div>
                `;
                previewContainer.appendChild(item);
            });
        }

        // ã‚µãƒ³ãƒ—ãƒ«SRTã‚’èª­ã¿è¾¼ã‚€
        function loadSampleSRT() {
            const sampleSRT = `1
00:00:00,000 --> 00:00:03,000
ç”°ä¸­: ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ï¼ä»Šæ—¥ã¯ã„ã„å¤©æ°—ã§ã™ã­ã€‚

2
00:00:03,500 --> 00:00:06,500
ä½è—¤: ãã†ã§ã™ã­ã€‚æ•£æ­©æ—¥å’Œã§ã™ã€‚

3
00:00:07,000 --> 00:00:10,000
ç”°ä¸­: å…¬åœ’ã§ã‚‚è¡Œãã¾ã—ã‚‡ã†ã‹ï¼Ÿ

4
00:00:10,500 --> 00:00:13,500
ä½è—¤: ã„ã„ã§ã™ã­ï¼æº–å‚™ã—ã¦ãã¾ã™ã€‚

5
00:00:14,000 --> 00:00:18,000
ç”°ä¸­: ã˜ã‚ƒã‚ã€10åˆ†å¾Œã«ç„é–¢ã§å¾…ã¡åˆã‚ã›ã—ã¾ã—ã‚‡ã†ã€‚

6
00:00:18,500 --> 00:00:22,000
ä½è—¤: äº†è§£ã§ã™ã€‚æ°´ç­’ã‚‚æŒã£ã¦ã„ãã¾ã™ã­ã€‚`;
            
            // ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒ‡ã‚£ã‚¿ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã«ã‚‚è¨­å®š
            const textInput = document.getElementById('srt-text-input');
            if (textInput) {
                textInput.value = sampleSRT;
            }
            
            parseSRT(sampleSRT, 'sample.srt');
        }

        // SRTéŸ³å£°ç”Ÿæˆ
        async function generateSRTAudio() {
            if (!srtData || srtData.length === 0) {
                showStatus(document.getElementById('srt-status'), 'SRTãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãã ã•ã„ã€‚', 'error');
                return;
            }
            
            const status = document.getElementById('srt-status');
            const audio = document.getElementById('srt-audio');
            const button = event.target;
            
            const speakerSet = new Set(srtData.map(e => e.speaker));
            const uniqueSpeakers = Array.from(speakerSet);
            
            // APIã®åˆ¶é™ã«å¯¾å¿œ
            let speakers = [];
            let conversation = [];
            
            if (uniqueSpeakers.length === 1) {
                // å˜ä¸€è©±è€…ã®å ´åˆ
                conversation = srtData.map(entry => ({
                    speaker: entry.speaker,
                    text: entry.text,
                    emotion: ''
                }));
            } else if (uniqueSpeakers.length === 2) {
                // 2è©±è€…ã®å ´åˆ
                speakers = uniqueSpeakers.map(name => ({
                    name,
                    voice: srtSpeakerMapping[name]
                }));
                conversation = srtData.map(entry => ({
                    speaker: entry.speaker,
                    text: entry.text,
                    emotion: ''
                }));
            } else {
                // 3è©±è€…ä»¥ä¸Šã®å ´åˆã¯å„è©±è€…ã”ã¨ã«åˆ¥ã€…ã«å‡¦ç†
                showStatus(status, `${uniqueSpeakers.length}äººã®è©±è€…ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸã€‚ç¾åœ¨ã®APIã¯2è©±è€…ã¾ã§ã—ã‹å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚æœ€åˆã®è©±è€…ã®éŸ³å£°ã®ã¿ã‚’ç”Ÿæˆã—ã¾ã™ã€‚`, 'error');
                
                // å„è©±è€…ã”ã¨ã«éŸ³å£°ã‚’ç”Ÿæˆã—ã¦çµåˆ
                const audioBuffers = [];
                
                for (const speakerName of uniqueSpeakers) {
                    const speakerLines = srtData.filter(entry => entry.speaker === speakerName);
                    if (speakerLines.length === 0) continue;
                    
                    const speakerConversation = speakerLines.map(entry => ({
                        speaker: entry.speaker,
                        text: entry.text,
                        emotion: ''
                    }));
                    
                    showStatus(status, `${speakerName}ã®éŸ³å£°ã‚’ç”Ÿæˆä¸­...`, 'loading');
                    
                    try {
                        const response = await fetch('/api/tts', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ 
                                text: speakerConversation.map(line => line.text).join(' '),
                                voice: srtSpeakerMapping[speakerName],
                                model: currentModel
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`${speakerName}ã®éŸ³å£°ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ`);
                        }
                        
                        const blob = await response.blob();
                        audioBuffers.push({ speaker: speakerName, blob, entries: speakerLines });
                        
                        // ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–ã®ãŸã‚ã«å°‘ã—å¾…æ©Ÿ
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        
                    } catch (error) {
                        console.error(`Error generating audio for ${speakerName}:`, error);
                        showStatus(status, `${speakerName}ã®éŸ³å£°ç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
                    }
                }
                
                // ç°¡æ˜“çš„ã«æœ€åˆã®è©±è€…ã®éŸ³å£°ã‚’å†ç”Ÿï¼ˆæœ¬æ¥ã¯æ™‚é–“è»¸ã«æ²¿ã£ã¦çµåˆã™ã¹ãï¼‰
                if (audioBuffers.length > 0) {
                    const firstAudio = audioBuffers[0];
                    const audioUrl = URL.createObjectURL(firstAudio.blob);
                    audio.src = audioUrl;
                    audio.style.display = 'block';
                    audio.play();
                    showStatus(status, `éŸ³å£°ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼ˆ${audioBuffers.length}äººã®è©±è€…ï¼‰ã€‚æ™‚é–“è»¸ã®çµåˆã¯æœªå®Ÿè£…ã§ã™ã€‚`, 'success');
                }
                
                return;
            }
            
            button.disabled = true;
            
            // è‡ªå‹•ã‚¹ã‚¿ã‚¤ãƒ«ç”Ÿæˆãƒ¢ãƒ¼ãƒ‰ã§ã€ã‚¹ã‚¿ã‚¤ãƒ«ãŒã¾ã ç”Ÿæˆã•ã‚Œã¦ã„ãªã„å ´åˆ
            let style = getCurrentStyle('srt');
            if (styleMode.srt === 'auto' && !style) {
                showStatus(status, 'ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è‡ªå‹•ç”Ÿæˆä¸­...', 'loading');
                const content = srtData.slice(0, 5).map(entry => `${entry.speaker}: ${entry.text}`).join('\n');
                style = await generateStyleForText(content, 'srt');
                if (style) {
                    autoGeneratedStyles.srt = style;
                    const previewElement = document.getElementById('srt-auto-style-preview');
                    if (previewElement) {
                        previewElement.textContent = style;
                    }
                }
            }
            
            showStatus(status, 'SRTéŸ³å£°ã‚’ç”Ÿæˆä¸­...', 'loading');
            
            try {
                const response = await fetch('/api/conversation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        conversation, 
                        speakers,
                        model: currentModel,
                        style: style || ''
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'éŸ³å£°ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ');
                }
                
                const blob = await response.blob();
                const audioUrl = URL.createObjectURL(blob);
                
                audio.src = audioUrl;
                audio.style.display = 'block';
                
                // æ—¢å­˜ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’å‰Šé™¤
                const existingLink = audio.parentElement.querySelector('a[download]');
                if (existingLink) {
                    existingLink.remove();
                }
                
                // æ–°ã—ã„ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’è¿½åŠ 
                const downloadLink = document.createElement('a');
                downloadLink.href = audioUrl;
                downloadLink.download = 'srt_audio.wav';
                downloadLink.textContent = 'éŸ³å£°ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰';
                downloadLink.className = 'btn-primary';
                downloadLink.style.cssText = 'display: inline-block; margin-top: 1rem; text-decoration: none;';
                
                audio.parentElement.insertBefore(downloadLink, audio.nextSibling);
                
                audio.play();
                showStatus(status, 'SRTéŸ³å£°ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼', 'success');
                
            } catch (error) {
                showStatus(status, 'ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
            } finally {
                button.disabled = false;
            }
        }

        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
        function showStatus(element, message, type) {
            element.textContent = message;
            element.className = `status ${type}`;
            element.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    element.style.display = 'none';
                }, 5000);
            }
        }

        // çµ±ä¸€çš„ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°é–¢æ•°
        function updateStatus(message, type) {
            // ç¾åœ¨ã®ã‚¿ãƒ–ã«å¿œã˜ã¦ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¦ç´ ã‚’å–å¾—
            let statusElement;
            if (currentTab === 'simple') {
                statusElement = document.getElementById('simple-status');
            } else if (currentTab === 'conversation') {
                statusElement = document.getElementById('conversation-status');
            } else if (currentTab === 'srt') {
                statusElement = document.getElementById('srt-status');
            }
            
            if (statusElement) {
                showStatus(statusElement, message, type);
            }
        }

        // ãƒœã‚¿ãƒ³ã®ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°çŠ¶æ…‹ã‚’è¨­å®š
        function setButtonLoading(buttonId, isLoading) {
            const button = document.getElementById(buttonId);
            if (!button) return;
            
            button.disabled = isLoading;
            if (isLoading) {
                button.innerHTML = button.textContent + '<span class="loading-spinner"></span>';
            } else {
                // ã‚¹ãƒ”ãƒŠãƒ¼ã‚’å‰Šé™¤
                const spinner = button.querySelector('.loading-spinner');
                if (spinner) {
                    spinner.remove();
                }
            }
        }
        
        // è©±è€…åã‹ã‚‰æœ€é©ãªéŸ³å£°ã‚’æ¨å¥¨
        function recommendVoiceForSpeaker(speakerName, index) {
            const nameLower = speakerName.toLowerCase();
            
            // å¥³æ€§çš„ãªåå‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
            const femalePatterns = ['ç¾', 'èŠ±', 'å­', 'é¦™', 'èœ', 'ä½³', 'å¥ˆ', 'æ„›', 'ç”±', 'æµ', 'çœŸ', 'å„ª', 'å½©', 'çµ', 'ã•ã‚“', 'san', 'chan', 'ã¡ã‚ƒã‚“'];
            // ç”·æ€§çš„ãªåå‰ã®ãƒ‘ã‚¿ãƒ¼ãƒ³
            const malePatterns = ['å›', 'ãã‚“', 'kun', 'å¤ª', 'éƒ', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­', 'ä¸ƒ', 'å…«', 'ä¹', 'å', 'é›„', 'å½¦', 'æ­¦', 'å‰›', 'é¾', 'è™'];
            
            // å¥³æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒ
            for (const pattern of femalePatterns) {
                if (speakerName.includes(pattern)) {
                    const femaleVoices = voiceCategories.female.voices;
                    return femaleVoices[index % femaleVoices.length].id;
                }
            }
            
            // ç”·æ€§ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ãƒãƒƒãƒ
            for (const pattern of malePatterns) {
                if (speakerName.includes(pattern)) {
                    const maleVoices = voiceCategories.male.voices;
                    return maleVoices[index % maleVoices.length].id;
                }
            }
            
            // è‹±èªåã®å ´åˆ
            if (/^[a-zA-Z]+$/.test(speakerName)) {
                // ä¸€èˆ¬çš„ãªå¥³æ€§å
                const femaleNames = ['mary', 'sarah', 'emma', 'anna', 'lisa', 'kate', 'jane', 'emily', 'jessica', 'ashley'];
                // ä¸€èˆ¬çš„ãªç”·æ€§å
                const maleNames = ['john', 'james', 'robert', 'michael', 'david', 'william', 'richard', 'joseph', 'thomas', 'charles'];
                
                if (femaleNames.some(name => nameLower.includes(name))) {
                    const femaleVoices = voiceCategories.female.voices;
                    return femaleVoices[index % femaleVoices.length].id;
                }
                if (maleNames.some(name => nameLower.includes(name))) {
                    const maleVoices = voiceCategories.male.voices;
                    return maleVoices[index % maleVoices.length].id;
                }
            }
            
            // ãƒãƒƒãƒã—ãªã„å ´åˆã¯ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åŸºã¥ã„ã¦äº¤äº’ã«
            if (index % 2 === 0) {
                const femaleVoices = voiceCategories.female.voices;
                return femaleVoices[Math.floor(index / 2) % femaleVoices.length].id;
            } else {
                const maleVoices = voiceCategories.male.voices;
                return maleVoices[Math.floor(index / 2) % maleVoices.length].id;
            }
        }
        
        // SRTæ™‚é–“ã‚’ãƒŸãƒªç§’ã«å¤‰æ›
        function parseTime(timeStr) {
            const parts = timeStr.split(':');
            const [hours, minutes] = parts;
            const [seconds, milliseconds] = parts[2].split(',');
            return parseInt(hours) * 3600000 + parseInt(minutes) * 60000 + parseInt(seconds) * 1000 + parseInt(milliseconds);
        }

        // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°éŸ³å£°å†ç”Ÿ
        async function streamAudio(response, audioElement, statusElement) {
            const reader = response.body.getReader();
            const chunks = [];
            let totalSize = 0;
            
            // åˆæœŸãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºï¼ˆæœ€åˆã®æ•°ãƒãƒ£ãƒ³ã‚¯ã‚’å¾…ã¤ï¼‰
            const initialBufferSize = 16384; // 16KBï¼ˆWAVãƒ˜ãƒƒãƒ€ãƒ¼ã‚’ç¢ºå®Ÿã«å«ã‚€ã‚µã‚¤ã‚ºï¼‰
            let isPlaying = false;
            let currentBlob = null;
            
            while (true) {
                const { done, value } = await reader.read();
                
                if (done) break;
                
                chunks.push(value);
                totalSize += value.length;
                
                // åˆæœŸãƒãƒƒãƒ•ã‚¡ãŒæºœã¾ã£ãŸã‚‰å†ç”Ÿé–‹å§‹
                if (!isPlaying && totalSize >= initialBufferSize) {
                    currentBlob = new Blob(chunks, { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(currentBlob);
                    audioElement.src = audioUrl;
                    audioElement.style.display = 'block';
                    
                    // éŸ³å£°ã®å†ç”Ÿæº–å‚™ãŒã§ããŸã‚‰å†ç”Ÿ
                    audioElement.addEventListener('canplay', () => {
                        audioElement.play().catch(e => console.log('å†ç”Ÿã‚¨ãƒ©ãƒ¼:', e));
                    }, { once: true });
                    
                    isPlaying = true;
                    showStatus(statusElement, 'ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å†ç”Ÿä¸­...', 'loading');
                }
                
                // å®šæœŸçš„ã«éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆã‚ˆã‚Šå¤§ããªãƒãƒ£ãƒ³ã‚¯ã§ï¼‰
                if (isPlaying && totalSize % (64 * 1024) === 0) { // 64KBã”ã¨ã«æ›´æ–°
                    const currentTime = audioElement.currentTime;
                    const wasPaused = audioElement.paused;
                    
                    // å¤ã„Blobã®URLã‚’è§£æ”¾
                    if (currentBlob) {
                        URL.revokeObjectURL(audioElement.src);
                    }
                    
                    currentBlob = new Blob(chunks, { type: 'audio/wav' });
                    const newUrl = URL.createObjectURL(currentBlob);
                    audioElement.src = newUrl;
                    
                    // å†ç”Ÿä½ç½®ã‚’å¾©å…ƒ
                    audioElement.addEventListener('loadedmetadata', () => {
                        audioElement.currentTime = currentTime;
                        if (!wasPaused) {
                            audioElement.play().catch(e => console.log('å†ç”Ÿå†é–‹ã‚¨ãƒ©ãƒ¼:', e));
                        }
                    }, { once: true });
                }
            }
            
            // æœ€çµ‚çš„ãªå®Œå…¨ãªãƒ‡ãƒ¼ã‚¿ã§éŸ³å£°ã‚’è¨­å®š
            if (currentBlob) {
                URL.revokeObjectURL(audioElement.src);
            }
            
            const fullBlob = new Blob(chunks, { type: 'audio/wav' });
            const fullUrl = URL.createObjectURL(fullBlob);
            
            // ç¾åœ¨ã®å†ç”ŸçŠ¶æ…‹ã‚’ä¿å­˜
            const currentTime = audioElement.currentTime;
            const wasPaused = audioElement.paused;
            
            // å®Œå…¨ãªéŸ³å£°ã«åˆ‡ã‚Šæ›¿ãˆ
            audioElement.src = fullUrl;
            
            if (isPlaying && currentTime > 0) {
                audioElement.addEventListener('loadedmetadata', () => {
                    audioElement.currentTime = currentTime;
                    if (!wasPaused) {
                        audioElement.play().catch(e => console.log('æœ€çµ‚å†ç”Ÿã‚¨ãƒ©ãƒ¼:', e));
                    }
                }, { once: true });
            }
            
            showStatus(statusElement, 'éŸ³å£°ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸï¼', 'success');
        }
    </script>
</body>
</html>