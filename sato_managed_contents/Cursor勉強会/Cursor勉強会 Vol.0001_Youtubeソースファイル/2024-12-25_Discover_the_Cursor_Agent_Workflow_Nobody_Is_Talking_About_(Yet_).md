# Discover the Cursor Agent Workflow Nobody Is Talking About (Yet!)

**チャンネル:** Frank Nillard
**公開日:** 2024-12-24
**URL:** https://www.youtube.com/watch?v=U_X4erx9ISY

## 説明

🔹Find All Resources inside Neural Architects:
https://www.skool.com/neural-architects-2547/about?ref=aae29a11b5d446c4ae3ef450353313d1

🔹 *Follow and Chat with Me:*
- In LinkedIn: https://www.linkedin.com/in/frank-nillard-6bb3291b3/

💯 *My Links and Resources*- some of these give me a kick back- thank you!
- n8n: https://n8n.partnerlinks.io/bnt3a6q0bh6a
- Create a Skool Account: https://www.skool.com/signup?ref=aae29a11b5d446c4ae3ef450353313d1
- Join the Skool Games: https://www.skool.com/games?ref=aae29a11b5d446c4ae3ef450353313d1 Learn how to create an app from scratch using Cursor with a simple workflow, perfect for non-programmers! Let me know in the comments if you'd like to see the full version of the tool built in this video.

🔹 *TIME STAMPS:*
[0:00] - Intro
[1:04] - Cursor Workflow Overview
[11:44] - Early Prototype
[14:50] - Building the App

## 字幕

[00:00 - 00:04]
こんにちは、ビルダーの皆さん。今日は少し変わったことをやります。

[00:04 - 00:09]
カーソルとその新しいエージェント機能を使ってみましたが、本当に

[00:07 - 00:11]
素晴らしいです。カーソルを使うと、

[00:13 - 00:17]
コーディングの経験があまりなくてもアプリ開発がずっと簡単になります。この動画では、

[00:17 - 00:22]
カーソルとその新しいエージェント機能を使ってゼロからアプリを構築していきます。また、

[00:22 - 00:26]
私自身がアプリ開発でテストした、非常に分かりやすいフレームワークも紹介します。このフレームワークを使えば、プログラミング言語に精通してい

[00:28 - 00:31]
なくても、エラーを減らしてアプリをより良く構築できます。カーソルを

[00:30 - 00:33]
使う際によく見られる問題の一つは、

[00:31 - 00:35]
まず、アプリを

[00:33 - 00:37]
どのように

[00:35 - 00:39]
構築したいのか、何を使って

[00:37 - 00:41]
アプリを構築したいのか、そして最終的に何が

[00:39 - 00:43]
起こるのかが明確になっていないことです。カーソルは

[00:41 - 00:45]
言語モデルなので、最終的に勝手に作り上げられてしまうのです。

[00:45 - 00:49]
アプリをどのように構築したいのか明確なイメージがなければ、

[00:47 - 00:52]
言語モデルが

[00:49 - 00:54]
勝手に動き、必要のないファイルを作成したり編集したりしてしまう可能性があります。

[00:58 - 01:02]
そこで、このフレームワークについても説明していきます。

[01:00 - 01:05]
さあ、始めましょう。

[01:02 - 01:07]
ご覧の通り、

[01:05 - 01:09]
コーディングの未来は平易な英語になるでしょう。これは

[01:07 - 01:11]
本当に真実だと信じています。NVIDIA

[01:11 - 01:17]
のCEOが出席した会議かコンベンションに関する別の動画を投稿しましたが、

[01:15 - 01:18]
彼も

[01:17 - 01:20]
このことについて言及していました。彼は、コーディングの未来は

[01:18 - 01:22]
平易な英語になるだろうと。なぜなら、

[01:20 - 01:24]
今後数年間でエージェントと

[01:22 - 01:26]
言語モデルが

[01:24 - 01:28]
自然言語からコードを解釈するのが非常に上手になり、

[01:28 - 01:33]
基本的にすべてが平易な英語になるからです。

[01:31 - 01:35]
つまり、コーディングの機能はここにあります。

[01:37 - 01:40]
カーソルのようなエディタがあるので、もう手動でコードを入力する必要はなく、そのため、

[01:38 - 01:42]
完全なソフトウェアを構築するための参入障壁は

[01:40 - 01:44]
かつてない

[01:42 - 01:46]
ほど低くなりました。適切なプロンプトと、

[01:44 - 01:48]
アプリの構築方法の概要さえあれば、

[01:48 - 01:53]
カーソルを使ってアプリを成功させるために必要なのはそれだけです。

[01:53 - 01:59]
では、カーソルとは何か

[01:56 - 02:01]
ご存じない方のために説明します。カーソルはAIコードエディタで、

[02:01 - 02:05]
AIを使って何でも構築できます。Chrome

[02:03 - 02:08]
拡張機能でも、

[02:05 - 02:10]
フルスタックのWebアプリケーションでも、

[02:10 - 02:14]
コードを必要とするものなら何でも、そして

[02:12 - 02:17]
カーソルの素晴らしい点は、

[02:14 - 02:19]
VS Codeのフォークであることです。

[02:17 - 02:21]
使い始めると、多くの

[02:19 - 02:24]
機能がVisual Studio Codeに似ていることに気付くでしょう。これは、

[02:25 - 02:30]
現在VS Codeを使用している多くのプログラマーにとって良い兆候です。VS

[02:28 - 02:31]
Codeからカーソルへの移行は

[02:31 - 02:36]
シームレスになるはずです。それでは、

[02:36 - 02:41]
エージェント機能について少しお話ししましょう。これは

[02:38 - 02:43]
カーソルの素晴らしい追加機能です。以前は、

[02:44 - 02:49]
カーソルで操作できる言語モデルは基本的に2種類ありました。1つ目は

[02:47 - 02:51]
チャットモデルで、

[02:49 - 02:54]
コードベースについて質問すると返答が

[02:51 - 02:56]
返されます。2つ目は

[02:54 - 02:59]
コンポーザーで、コンポーザーは

[02:56 - 03:00]
ファイルの追加や編集、そしておそらくファイルの削除もできます。

[03:00 - 03:05]
以前のコンポーザーでは、

[03:05 - 03:08]
アプリケーションの構築に主に使用していたため、

[03:08 - 03:11]
ターミナルとのやり取りができなかったなど、いくつかの問題がありましたが、この問題が

[03:10 - 03:13]
解決されました。エージェントは

[03:13 - 03:17]
コンポーザーを介してターミナルとやり取りできるようになり、複数のファイルに同時に変更を加えることも可能になりました。

[03:17 - 03:22]
これは素晴らしい機能です。時間の節約になりますし

[03:19 - 03:24]
、一番の利点は、

[03:22 - 03:25]
プロジェクトの完全なコンテキストが把握できるようになったことです。エージェントモード

[03:24 - 03:27]
にすれば、話しかけるたびに

[03:27 - 03:31]
コードベース全体がプロンプトまたは

[03:29 - 03:32]
メモリにインデックスされます。

[03:32 - 03:35]
以前は、

[03:35 - 03:39]
関連性があると判断したコードのランダムな部分をトークンにプッシュしていましたが、今は

[03:37 - 03:41]
そうする必要がなくなりました。つまり、

[03:43 - 03:46]
ファイルの追加、編集、削除などの提案がより

[03:44 - 03:48]
正確になったということです。つまり、これで

[03:46 - 03:50]
あなたは、あなたと

[03:48 - 03:51]
一緒に作業するジュニアフルスタック開発者にアクセスできるようになります。

[03:50 - 03:53]
このビデオでは、

[03:51 - 03:55]
カーソルとエージェント機能を、先ほど説明したフレームワークと一緒に使用する方法を紹介します。Web

[03:58 - 04:03]
アプリケーションが初めての方は、

[04:00 - 04:05]
今日私たちが構築しようとしているのはWebアプリケーションなので、

[04:05 - 04:08]
フロントエンド、

[04:08 - 04:12]
つまりマウスでクリックできる視覚的な部分があることを理解するだけで十分です。 ウェブ

[04:09 - 04:14]
アプリとバックエンドがあります。例えば、

[04:16 - 04:21]
車を検索できるウェブサイトがあるとします。この仕組みは、

[04:21 - 04:25]
まず車のモデルなどの検索語を入力します。

[04:24 - 04:27]
フロントエンドで入力されたすべての情報が、検索クエリとして返されます。

[04:25 - 04:30]
例えば、コルベットを探しているとします。この

[04:27 - 04:32]
検索クエリは

[04:30 - 04:35]
APIなどによって

[04:32 - 04:36]
バックエンドに送信されます。バックエンドには

[04:35 - 04:39]
すべてのロジックと

[04:36 - 04:41]
データベースが存在します。検索クエリは

[04:39 - 04:43]
おそらくデータベースを通過し

[04:41 - 04:45]
、データベースはデータベースに登録されているコルベットに関するすべての関連情報を取得します。

[04:48 - 04:52]
画像や必要な説明が取得され、

[04:52 - 04:56]
フロントエンドでレンダリングされます。そして、

[04:56 - 05:00]
探していたコルベットの検索結果が表示されます。APIは、

[04:58 - 05:01]
中間のブリッジとして

[05:00 - 05:03]
フロントエンドと

[05:01 - 05:05]
バックエンドを接続する役割を果たします。また、

[05:03 - 05:08]
バックエンドの一部として、

[05:05 - 05:10]
例えばOpenAPIなどのAPIに接続することもできます。  APIについて

[05:08 - 05:12]
ですが、Pythonを使った他のプロジェクトをご存知ですか？例えば、

[05:12 - 05:16]
誰かがPythonで作ったチャットBがありますよね？

[05:14 - 05:18]
補完や

[05:16 - 05:20]
言語モデル出力を生成するには、

[05:18 - 05:22]
Open Eyes APIを使用する必要があります。これはバックグラウンド

[05:20 - 05:25]
で行われている処理です。バックエンドとの通信を

[05:22 - 05:26]
容易にするだけでなく、

[05:28 - 05:34]
Open Eyes Appや

[05:31 - 05:36]
Reddit Coolなどのサードパーティサービスとのやり取りも可能にします。フロントエンド

[05:34 - 05:38]
とバックエンドの違いは、分かりやすい図やイラストを探してみました。

[05:38 - 05:42]
これらが最適なものなので、これらがどの

[05:42 - 05:47]
ように接続されているかを説明した後で、ご理解いただければ幸いです。Web

[05:45 - 05:48]
アプリがサーバーに

[05:47 - 05:50]
アクセスし、サーバーが

[05:48 - 05:53]
データベースとやり取りして必要なクエリを実行します。

[05:50 - 05:55]
データベース

[05:53 - 05:58]
情報は

[05:55 - 06:00]
Webアプリまたはモバイルアプリに取り込まれます。もしこれが

[05:58 - 06:02]
少し分かりにくかったり、

[06:00 - 06:04]
よく理解できなかったりする場合は、ビデオを残しておきましたので、

[06:02 - 06:06]
このプレゼンテーションをダウンロードして、

[06:06 - 06:10]
YouTubeビデオのリンクをクリックしてください。

[06:10 - 06:15]
フロントエンドとバックエンドがどのように連携するかについて、分かりやすく説明されています。

[06:18 - 06:22]
プログラミング、特にコーディングの

[06:20 - 06:25]
世界に初めて触れる方は、

[06:22 - 06:27]
エディター

[06:25 - 06:30]
やIDEを使ってコードを書き、ターミナル内で

[06:27 - 06:33]
特定のコマンドを実行できます。Gitは、

[06:37 - 06:42]
作成したアプリケーションなどを保存できるオンラインリポジトリのようなもので、

[06:44 - 06:48]
プロジェクトを保存するためのコマンドです。これらは、プロジェクトを保存しているリポジトリの場所を特定するためのコマンド例です。次に、

[06:48 - 06:53]
プロジェクトに追加した新しい変更をプッシュするためのコマンドです。

[06:53 - 06:56]
エディター内で特定のフォルダに移動したい場合は、

[06:54 - 06:58]
CDと

[06:56 - 07:00]
フォルダ名を入力します。この2つのコマンドは、

[06:58 - 07:03]
これからよく使うコマンドです。

[07:00 - 07:04]
フロントエンドを実行するにはnpm runev、

[07:03 - 07:07]
バックエンドを起動するには

[07:04 - 07:09]
npm startを実行します。

[07:09 - 07:14]
これで

[07:11 - 07:16]
基本が理解できたので、先ほど

[07:16 - 07:19]
説明した

[07:17 - 07:22]
カーソルの操作方法を見てみましょう。

[07:19 - 07:24]
エージェントの仕組みは、まず

[07:24 - 07:28]
PRDと呼ばれるものを計画・準備します。これはMarkdown

[07:27 - 07:31]
ファイルで、

[07:28 - 07:33]
カーソル内のエディターに保存します。PRDは

[07:31 - 07:36]
プロセス要件ドキュメントの略で、

[07:33 - 07:38]
カーソル内で使用することで

[07:36 - 07:39]
エージェントが参照できるようにし、

[07:38 - 07:41]
プロジェクトやアプリケーションを段階的に構築できるようにします。

[07:41 - 07:45]
これで

[07:43 - 07:47]
理解が深まります。準備ができたら、

[07:47 - 07:51]
カーソル内のエージェントと適切にチャットを開始し、

[07:49 - 07:53]
エージェントに基本的な

[07:51 - 07:55]
フロントエンドを構築させます。次に、Superbaseを使用して

[07:55 - 07:59]
バックエンドのすべてを接続し、UIを調整します。

[07:57 - 08:00]
これはオプションですが、

[08:00 - 08:06]
今日は詳しく説明しません。基本的に、

[08:03 - 08:08]
LLMの出力をより細かく制御し、

[08:06 - 08:09]
その

[08:08 - 08:12]
プロセスを調整したい場合は、Lsmith

[08:09 - 08:14]
などの監視プラットフォームに接続するのが最適です。

[08:14 - 08:20]
もし興味があれば、ぜひご覧ください。 では、

[08:20 - 08:25]
Googleで調べてみましょう。プロセス要件ドキュメントを書くには、

[08:22 - 08:27]
まず

[08:27 - 08:33]
PRDのドラフトを作成する必要があります。第40章で、

[08:31 - 08:35]
何を構築したいのかを伝えます。すると、

[08:35 - 08:39]
アプリケーションの範囲、つまりアプリケーションが

[08:39 - 08:44]
有用であるために必要なものが構築されます。これはオプションですが、理想的には、

[08:46 - 08:49]
コア機能を構築するためにどのようなパッケージを使用できるかを理解するために調査を行う必要があります。

[08:49 - 08:56]
次に、そのPRDのリファインバージョン、

[08:53 - 08:59]
つまりPRDのV2を渡し

[08:56 - 09:00]
ます。これをO1に貼り付けて、

[08:59 - 09:04]
プロジェクト

[09:00 - 09:06]
構造の設計とPRDの定義をもう少し明確にします。そして、

[09:04 - 09:08]
それをO1に渡して、

[09:12 - 09:16]
アプリケーションの要件がどうあるべきかという完全にリファインされたバージョンを作成します。これは後で確認しますが、

[09:16 - 09:21]
ここにある指示書を見てください。

[09:19 - 09:22]
これが

[09:21 - 09:25]
PRDファイルになります。

[09:22 - 09:27]
指示書と呼ぶことにします。

[09:25 - 09:29]
大丈夫です。これらの

[09:27 - 09:31]
セクションがあるので、

[09:29 - 09:34]
プロジェクトの概要と主要な

[09:31 - 09:36]
機能のリストを、理想的には

[09:34 - 09:38]
時系列順に記述していきます。

[09:36 - 09:41]
ユーザーが

[09:38 - 09:43]
ログインして、録画して、ログアウトするまでのプロセス全体を想像してみてください。

[09:43 - 09:48]
そのプロセス全体を時系列で記録します。そして、使用する

[09:48 - 09:51]
パッケージのドキュメントを含めることができます。

[09:51 - 09:58]
特定のAPIや

[09:55 - 10:00]
ツールを呼び出す場合は、ここに追加できますが、

[09:58 - 10:02]
必須ではありません。o1が

[10:00 - 10:04]
記入を手伝ってくれるからです。そして、現在のファイル

[10:02 - 10:07]
構造です。これは

[10:04 - 10:10]
最終的なPRDを作成する上で重要です。うまく説明できなかったかもしれませんが、

[10:10 - 10:14]
ドラフトPRDと調査パッケージに基づいて、

[10:14 - 10:20]
プロジェクト構造フォルダを作成します。

[10:17 - 10:22]
これはPRD全体ではなく、私たちが

[10:22 - 10:26]
取得する構造です。その後、

[10:24 - 10:28]
要件を書き出します。 念のため、

[10:28 - 10:34]
for 4 o や o1 などを使う場合は、mckown

[10:31 - 10:36]
で取得されるものを確認してください。

[10:34 - 10:38]
これらは、プレゼンテーションにアクセス

[10:36 - 10:40]
したら読むことができるものです。先ほど

[10:38 - 10:42]
言ったように、

[10:40 - 10:45]
後で o1 を使ってこれを行うことができます。エディター

[10:42 - 10:46]
内でプロジェクト構造を表示するために、

[10:48 - 10:53]
tree と呼ばれるものを使います。tree は、ターミナル

[10:51 - 10:56]
でファイルの構造を印刷するために使用できるアドオンです。PRD を

[10:57 - 11:05]
作成する際の参照として使用すると非常に便利です。

[11:00 - 11:08]
これがその見た目です。では、

[11:05 - 11:10]
カーソルを開いて

[11:08 - 11:13]
すべてを設定します。

[11:13 - 11:17]
まず、カーソルの Web サイトにアクセスして

[11:15 - 11:20]
アカウントを作成し、

[11:17 - 11:22]
Mac 用にダウンロードします。Windows 用があるかどうかはわかりません

[11:20 - 11:24]
が、ダウンロードして確認することができます。

[11:22 - 11:26]
無料版を試すことができると思います。

[11:24 - 11:28]
無料版は

[11:26 - 11:29]
かなり充実していると思います。

[11:28 - 11:31]
もう少し高度な機能が必要な場合は、

[11:29 - 11:33]
その時は

[11:31 - 11:35]
料金を支払う必要があります。価格は

[11:33 - 11:37]
正直言ってそれほど高くなく、月額20ドルです。これだけの

[11:35 - 11:40]
機能を考えると、

[11:37 - 11:42]
大きなリターンが得られると思います。

[11:40 - 11:43]
まずは私が構築してきた文字起こしアプリをお見せします。

[11:48 - 11:57]
これを開いて、

[11:52 - 11:59]
Cityバックエンドとmpm startを実行してみましょう。

[11:57 - 12:01]
次にターミナルの別のインスタンスを開いて、

[12:01 - 12:09]
CDフロント

[12:04 - 12:11]
エンドとMPN

[12:09 - 12:13]
runevを実行してみましょう。これでローカルホストで実行されています。

[12:11 - 12:16]
基本的に、現在の

[12:13 - 12:16]
状態をお見せしたいと思います。これが

[12:22 - 12:28]
私のローカルインスタンスです。

[12:25 - 12:31]
サーバー上で実行しています。これは

[12:28 - 12:32]
私のコンピュータ上で実行されています。

[12:31 - 12:34]
これはローカルホストです。つまり、

[12:32 - 12:36]
ローカルインスタンスです。文字

[12:34 - 12:39]
起こしアプリへようこそ。Gmailで

[12:36 - 12:40]
サインインできます。これは素晴らしいですね。Clerk

[12:39 - 12:42]
というツールを使用しています。

[12:42 - 12:47]
ワークスペースを選択して開始できます。 録音する

[12:44 - 12:49]
前にAPIキーを追加する必要があるので、先に

[12:47 - 12:51]
進めてそれを行います。

[12:49 - 12:53]
とにかく

[12:51 - 12:56]
APIキーを保存します。

[12:53 - 13:00]
ワークスペースを選択して録音を開始できます。こんにちは、

[12:56 - 13:03]
こんにちは、1 12 3 1 2 31

[13:00 - 13:03]
123 調子はどうですか？これで文字

[13:07 - 13:13]
起こしができました。自分のAPIキーを使用して

[13:10 - 13:15]
Open AI Whisper

[13:13 - 13:17]
モデルにアクセスし、文字起こしが行われ、

[13:15 - 13:19]
結果が返されました。聞くこともできます。

[13:19 - 13:23]
マイクを接続しているので今は音声を録音しませんが、アイデアは

[13:21 - 13:25]
伝わりましたね。これから

[13:25 - 13:29]
これよりも少し良いものを作ってみましょう。前に

[13:28 - 13:32]
フレームフレームワークについて話した理由は、

[13:29 - 13:34]
カーソルをもう少しうまく使うのに

[13:34 - 13:39]
予想よりも時間がかかったからです。3日かかりました。

[13:39 - 13:42]
1日でできると思っていたのですが、実際には

[13:41 - 13:45]
ここまで構築するのに3日かかりました。その理由は、

[13:42 - 13:48]
今回

[13:45 - 13:50]
カーソルを試した時に

[13:50 - 13:55]
アプリ全体の見た目をどうしたいか理解したので、

[13:53 - 13:58]
ここで基本的な説明をしました。

[13:55 - 13:59]
チャットとコンポーザーがあります。

[13:58 - 14:01]
チャットには様々なものがあり、

[13:59 - 14:03]
コンポーザーでは

[14:03 - 14:06]
ファイルの作成、削除、編集ができます。コンポーザーを開いて、「文字

[14:06 - 14:11]
起こしアプリが欲しい。これを

[14:08 - 14:13]
作りたいんだけど、すごくバラバラだった」と伝えます。

[14:11 - 14:14]
先ほども説明したように、

[14:14 - 14:19]
アプリの

[14:17 - 14:21]
見た目や詳細な構造について十分なアイデアがなければ、

[14:19 - 14:23]
ただ

[14:21 - 14:25]
漫然とサイトの

[14:23 - 14:26]
機能を構築してしまい、後で

[14:25 - 14:28]
他にも作るべきものがあったことに気づいてやり直そうとしてしまうという問題があります。

[14:30 - 14:34]
コンポーザーは役立ちますが、

[14:32 - 14:36]
自分が何をしたいのか理解するのが難しい場合があります。そのため、

[14:34 - 14:39]
適切な構造とPRDを用意して

[14:36 - 14:41]
コンポーザーに渡すことで、

[14:39 - 14:43]
開発を迅速化できました。

[14:43 - 14:48]
それでは、その仕組みをお見せしましょう。

[14:46 - 14:49]
これを閉じましょう。

[14:48 - 14:52]
見ていてとても良かったです。えー、

[14:49 - 14:57]
ゼロから構築していきますので、フォルダーを開いて

[14:52 - 14:57]
新しいフォルダーを作成し、「

[14:57 - 15:01]
transcription YouTube

[15:01 - 15:05]
demo」という名前を付けましょう。完璧です。先に進み、それを開いてみましょう。

[15:04 - 15:07]
ご覧のとおり、ここには何もないので、

[15:05 - 15:11]
最初のステップでは、

[15:07 - 15:12]
その手順を設定することになります。  ND ファイルな

[15:11 - 15:15]
ので、このマークダウン ファイルに

[15:12 - 15:17]
手順が記載されていることを確認します。 わかりました。

[15:15 - 15:19]
構造を使っていきます。

[15:17 - 15:21]
先ほどプレゼンテーションでご覧いただいたように、

[15:21 - 15:25]
ファイル内のこれらの項目について説明します。

[15:23 - 15:26]
概要、機能、

[15:25 - 15:29]
ドキュメント、そして現在のファイル構造です。

[15:26 - 15:30]
なぜMarkdownで記述するのでしょうか？

[15:29 - 15:32]
これらの言語モデルは、デフォルトでMarkdownの仕組みをより深く理解しています。

[15:32 - 15:36]
だからこそ、

[15:34 - 15:38]
Markdown言語モデルを使用しているのです。

[15:36 - 15:39]
ヘッダーや箇条書きなどの構造を理解し、

[15:43 - 15:47]
太字を追加する必要がある場合でも、すべてMarkdownで処理されます。

[15:47 - 15:51]
言語モデルはMarkdownをより適切に解釈するためです。それでは、

[15:51 - 15:57]
プロジェクトの

[15:53 - 15:59]
概要、コア機能

[15:59 - 16:07]
、

[16:04 - 16:10]
ドキュメント、そして

[16:07 - 16:10]
現在のプロジェクト

[16:10 - 16:15]
構造を確認しましょう。これは、

[16:15 - 16:19]
プロジェクト全体の構造を把握するのに役立ちます。

[16:17 - 16:21]
もし、少しおかしくなったり、

[16:19 - 16:23]
横道に逸れたりした場合でも、

[16:21 - 16:25]
この構造を参照して、この参照構造とどのように異なるかを確認できます。

[16:23 - 16:27]
それでは

[16:25 - 16:29]
これで

[16:27 - 16:32]
最初の部分、プロジェクトの概要を完成させ

[16:29 - 16:35]
ましょう。さて、まずは

[16:32 - 16:37]
プロジェクトの概要をここに貼り付けましょう。

[16:35 - 16:40]
ちなみに、プロジェクトの概要は、ご自身の責任で、

[16:40 - 16:44]
最も適切だと思うものを入力してください。ただし、私としては、

[16:42 - 16:46]
キーワークフローと

[16:44 - 16:48]
テキストタグの基礎となる部分が良いかもしれません。

[16:48 - 16:52]
アプリの概要を少しだけ記述します。これで

[16:49 - 16:55]
プロジェクトの概要は完了です。もし、

[16:52 - 16:58]
この手順が分からなければ、チャットGPTが便利です。

[16:55 - 17:00]
何をしたいのかを伝えてください。プロジェクト要件ドキュメントを

[16:58 - 17:02]
作成したいのです。プロジェクトの

[17:02 - 17:06]
概要には、キーフローと

[17:04 - 17:08]
テキストスタックがあります。これが最初の

[17:06 - 17:10]
部分です。プロジェクトの概要です。これをここに入力して、

[17:10 - 17:13]
アプリケーションについて少し説明してください。

[17:11 - 17:15]
次のようなものが表示されるはずです。

[17:13 - 17:18]
必ずマークダウンで記述してください。dotmd

[17:15 - 17:19]
なので、ここにマークダウンで追加してください。これが

[17:18 - 17:21]
最初の部分です。次に

[17:19 - 17:23]
コア機能です。

[17:21 - 17:25]
このセクションには十分な時間をかける必要があります。これは、

[17:25 - 17:30]
Composerなどでプロジェクトを確認するために使用するためです。

[17:28 - 17:33]
エージェントなので、手順

[17:33 - 17:38]
ごとにできるだけ詳細に記述し、

[17:38 - 17:42]
ユーザーが

[17:40 - 17:43]
アプリを操作する方法に沿っていることを確認してください。

[17:42 - 17:45]
まず、

[17:43 - 17:47]
認証を行います。Googleなどでサインインします。

[17:45 - 17:48]
次にメインページが表示されます。

[17:47 - 17:50]
メインページで何を

[17:48 - 17:52]
するのでしょうか？

[17:50 - 17:55]
録音ボタンを押します。

[17:52 - 17:56]
ボタンの色は？これは

[17:55 - 17:58]
あくまでアイデアですが、主に

[17:56 - 18:00]
アクションの詳細を説明します。それでは実際にやってみましょう。

[17:58 - 18:02]
コア

[18:00 - 18:05]
機能のログインとユーザー設定を行います。

[18:02 - 18:07]
ワークスペースの録音

[18:05 - 18:09]
管理を設定します。ご覧のとおり、トランスクリプション

[18:07 - 18:10]
機能とデータ管理です。次にドキュメントを作成します。これは後で

[18:10 - 18:14]
設定します。設定方法は

[18:11 - 18:17]
後ほど説明します。プロジェクト

[18:14 - 18:18]
構造は、カバープロジェクト内のファイルのスクリーンショットのはずです

[18:17 - 18:21]
が、

[18:18 - 18:24]
まだ何も作成されていません。

[18:21 - 18:27]
理由は後ほど説明します。これは、アプリケーションの構造を

[18:24 - 18:29]
構築するためにComposerを使用したくないからです。AI

[18:29 - 18:33]
以外のものを使用したいのです。

[18:31 - 18:35]
モデルです。

[18:33 - 18:38]
ここでComposerとChatのオン/オフを切り替えることができます。Chatと

[18:39 - 18:42]
Composerがここにあります。少し拡大してみますが、うまくいかないかもしれませんが、ここ

[18:45 - 18:51]
で

[18:49 - 18:53]
よく見ると、名前でファイルを追加して参照できます。もちろん、ファイルは

[18:53 - 18:57]
1つだけですが、Composerで

[18:56 - 18:59]
Agentを選択すると、

[18:59 - 19:02]
すべてのファイルの概要が表示されます。

[19:01 - 19:04]
今はファイルがありませんが、後で確認するので、念のためお知らせします。

[19:02 - 19:09]
とにかく、

[19:04 - 19:11]
NextJS 14を使用します。NextJSは

[19:09 - 19:14]
Reactベースのフレームワークなので、今すぐお見せします。NextJSはReactベースのフレームワークで、

[19:17 - 19:21]
非常に高速なWebアプリケーションを構築できます。Shatenが

[19:19 - 19:24]
あります。Shatenは、

[19:24 - 19:28]
Tailwind CSSと連携する、既に構築済みのUIコンポーネントのライブラリです。

[19:26 - 19:30]
そして、Tailwind本体があります。  CSSはフレーム

[19:28 - 19:33]
ワークで、

[19:30 - 19:35]
簡単にスタイルを設定できます。

[19:33 - 19:37]
そしてlucd iconsがあります。

[19:35 - 19:39]
これは以前も使ったことがあり、

[19:37 - 19:40]
素晴らしい出来栄えだと思います。

[19:39 - 19:43]
これらはあらかじめ用意されたボタンと

[19:40 - 19:45]
アイコンなので、このアプリのビルドで使用します。

[19:43 - 19:46]
さて、

[19:45 - 19:49]
ここで

[19:46 - 19:51]
ターミナルを使ってルートディレクトリに移動します。すでに

[19:49 - 19:53]
ルートディレクトリにいるはずです。MPX

[19:53 - 19:59]
shatenを

[19:56 - 20:00]
最新の

[19:59 - 20:03]
initializeディレクトリに配置します。次に、定義済みのファイル構造を

[20:00 - 20:05]
設定するための手順をいくつか実行します。これはAI

[20:03 - 20:08]
ではなくshatenによって構築されます。shatenはAIを使用してこれらの構造を構築し

[20:08 - 20:12]
ません。

[20:11 - 20:14]
これは、

[20:14 - 20:20]
実際の開発者が何年もかけてこれらのファイル構造を作成してきた成果物です。[

[20:17 - 20:22]
はい]を押して、これらのファイル構造を

[20:20 - 20:24]
すべて構築します。

[20:22 - 20:25]
パスユーザーにはパッケージJSONファイルが含まれていません。

[20:25 - 20:30]
新しいNexusプロジェクトを開始しますか？[

[20:28 - 20:33]
はい]を選択します。プロジェクトの名前は何ですか？[

[20:30 - 20:35]
transcription]にします。 テスト、

[20:33 - 20:38]
YouTubeはこのように配置しました。これで

[20:35 - 20:40]
NextJSプロジェクトを作成しています。

[20:38 - 20:41]
新しいフォルダが作成され、

[20:41 - 20:46]
必要なファイルがすべて作成されています。作業を進め

[20:43 - 20:48]
ながら進めていきます。次に、

[20:46 - 20:51]
使用するスタイルを選択する必要があります。New Yorkを選択しましょう。Neutral

[20:48 - 20:53]
にしましょう。

[20:51 - 20:55]
テーマ設定にCSS変数を使用しますか？

[20:55 - 20:59]
はいを選択します。これで完了です。

[20:59 - 21:05]
言語モデルに頼ることなく、すべてのファイルが揃っているはずです。言語モデルを使用すると

[21:03 - 21:07]
エラーが発生する可能性があります。これで、

[21:05 - 21:10]
この構造が使用すべきものであることがわかりました。

[21:11 - 21:18]
正規のインストーラーを使用したので、これでわかりました。次に、Shatenによって作成された

[21:15 - 21:21]
transcriptionフォルダ内にフォルダを作成します。

[21:21 - 21:23]
それを選択して任意の

[21:22 - 21:26]
フォルダに移動し、

[21:26 - 21:30]
instructionsという名前を付けます。

[21:28 - 21:31]
最初に作成したファイルをinstructions内に配置します。

[21:31 - 21:37]
それでは、それをinstructions内に移動しましょう。

[21:35 - 21:41]
カーソルを選択してフォルダ名を選択します。

[21:37 - 21:41]
ケースは、

[21:42 - 21:47]
転写の

[21:43 - 21:50]
テスト

[21:47 - 21:52]
YouTube です。基本的に今行ったことは、

[21:55 - 21:59]
shaten で作成したこの新しいフォルダー、この新しいディレクトリに入ることです。はい、

[21:57 - 22:03]
ここにいます。

[21:59 - 22:07]
次に、フォルダーではなく、EnV ファイルを作成する必要があります。

[22:03 - 22:08]
ファイル env が必要です。 ローカルですね。

[22:07 - 22:11]
ここにすべての

[22:08 - 22:13]
オペレーションキーと必要なものを配置します。

[22:11 - 22:16]
それでは、黒のままにしておきます。

[22:16 - 22:19]
ターミナルをもう一度開いて、必要に応じてチャットを開いてください。ターミナルは

[22:19 - 22:24]
ここにあります。MPX

[22:24 - 22:31]
shat CNを最新の追加に配置します。次に、Chatenに

[22:29 - 22:33]
アクセスして、

[22:33 - 22:38]
必要なコンポーネントを選択します。この場合は、スペースキーを

[22:35 - 22:41]
押してボタンを選択します。

[22:53 - 22:59]
カードを選択します。これで完了です。Enterキーを押します。

[22:57 - 23:02]
次に、あらかじめ作成されたshatenコンポーネントを取得します。

[22:59 - 23:04]
これらのコンポーネントは

[23:02 - 23:05]
再利用可能です。Webサイト

[23:04 - 23:07]
から直接取得できるので便利です。

[23:05 - 23:09]
ここにあります。

[23:07 - 23:10]
作曲家はこれらを参照として使用できます。何もないところから何かを

[23:10 - 23:13]
作成するわけではありません。これで

[23:13 - 23:18]
参照ポイントができました。次に、

[23:20 - 23:27]
Brewをインストールします。これは、

[23:27 - 23:32]
先ほど説明したように、ファイルツリーを作成します。

[23:32 - 23:34]
ユーティリティ

[23:39 - 23:46]
自体をインストールします。これで完了です。

[23:42 - 23:49]
ツリーを追加します。

[23:46 - 23:51]
これらの1つを取得しましょう。Tril

[23:49 - 23:53]
2を取得します。ファイルの最初の2つのレベルのみを取得します。1

[23:53 - 23:56]
回クリックすると、ここに表示されている最初のレベルになります。

[23:56 - 24:00]
これを開くと、2番目のレベルになります。これに

[23:58 - 24:01]
別のフォルダーがある場合は、

[24:00 - 24:04]
3番目のレベルに進みます。

[24:01 - 24:06]
すべてがその中に収まるはずです。

[24:04 - 24:08]
これもありますが、すべては必要ありません。

[24:06 - 24:09]
これらは

[24:08 - 24:13]
実際には

[24:09 - 24:15]
表示されません。2番目のレイヤーに限定しましょう。3

[24:13 - 24:17]
つを取得します。

[24:15 - 24:18]
これは何と呼ばれていましたか？

[24:17 - 24:20]
スペイン語と英語の間でした。申し訳ありません。

[24:18 - 24:24]
とにかく、これは大丈夫です。マイナス

[24:20 - 24:28]
記号か何であれ、tree L2です。tree

[24:24 - 24:31]
L2です。ご覧のとおり、

[24:28 - 24:33]
ほとんど取得できます。もちろん、実際には、

[24:31 - 24:36]
先ほど言ったように、

[24:33 - 24:38]
このノード モジュール フォルダには、

[24:38 - 24:42]
ご存知のとおり、必要のないものが含まれています。

[24:39 - 24:44]
そのため、実際には Tree

[24:42 - 24:48]
/

[24:44 - 24:52]
L2 ツリー (ツリー U ハイフン L2) を使用します。

[24:48 - 24:53]
また、

[24:52 - 24:58]
ノード モジュール

[24:53 - 24:58]
フォルダも考慮しません。そのため、ノード

[24:59 - 25:03]
モジュールを

[25:00 - 25:05]
このように配置し、モジュール フォルダのないツリーを取得します。

[25:03 - 25:08]
モジュール フォルダがあると、

[25:09 - 25:13]
ノード モジュール内の

[25:11 - 25:15]
参照する必要のないさまざまなフォルダを参照するため、ツリーが非常に長くなります。そのため、

[25:13 - 25:16]
先に進んでその

[25:15 - 25:18]
フォルダを取得して、手順に進みます

[25:16 - 25:21]
。  MDを

[25:18 - 25:23]
現在のプロジェクト構造の下に貼り付けます。

[25:21 - 25:26]
はい、ここはそのままにしておき

[25:23 - 25:29]
ます。

[25:26 - 25:31]
次のステップは、

[25:29 - 25:33]
現在ここにあるすべてのものを取得することです。さて、

[25:33 - 25:38]
O1、CHB1に移動します。これはより優れた推論

[25:37 - 25:41]
機能を備えているので、

[25:38 - 25:43]
MDファイルのすべての指示を

[25:41 - 25:48]
ここに貼り付けます。これを削除しましょう。

[25:43 - 25:50]
これで完璧です。次に、

[25:50 - 25:53]
構築したいプロジェクトの詳細の上にこれを追加します。プロジェクトファイルをどのように構成すればよいですか？

[25:53 - 25:58]
できるだけ少ないファイルを作成します。実際、

[25:58 - 26:02]
Composerが作成するファイルが少ないほど、

[26:00 - 26:04]
精度が向上し、

[26:02 - 26:06]
アプリで発生するエラーが少なくなることがわかったので、Enterキーを押して、その

[26:06 - 26:12]
ままにしておきます。これで、アプリを

[26:09 - 26:15]
どのように

[26:12 - 26:16]
ビルドするかを考え始めることができますが、今度は、元のPRDの

[26:16 - 26:21]
上に実際にビルドされるように、もう少し詳細なプロンプトを提供します。先に

[26:21 - 26:24]
進み、ここにコピーします。元のPRD

[26:22 - 26:26]
に詳細を追加して、

[26:24 - 26:27]
明確な整合性を持たせるのに役立ちます。

[26:26 - 26:28]
プロジェクトを実装する開発者は、実際のコードを作成するのではなく、

[26:27 - 26:30]
PRDを作成して

[26:28 - 26:33]
ファイルをインクルードするだけです。これですべて取得できました。「

[26:33 - 26:37]
Markdownですべてを教えてください」と頼むのを忘れていました。これは私

[26:36 - 26:39]
の大きなミスですが、

[26:39 - 26:46]
今からやります。Openiは

[26:43 - 26:49]
大量のテキストを

[26:46 - 26:50]
一貫してMarkdownに変換するのが本当に苦手なようです。PRD

[26:50 - 26:55]
から取得した回答をコピーして、

[26:53 - 26:57]
CLA（無料版）を開いて

[26:55 - 27:00]
貼り付けます。「

[26:57 - 27:04]
このテキストをMarkdownに変換するのを手伝ってください」などと入力します。それでは、

[27:07 - 27:15]
これを完璧にやってみましょう。それでは、

[27:10 - 27:18]
それをコピーして戻ってきて、Ctrl +

[27:15 - 27:20]
Altを押してすべてを削除し、

[27:18 - 27:22]
CLAから取得したものを貼り付けます。

[27:20 - 27:25]
このMarkdownバージョンですね。Ctrl +

[27:22 - 27:27]
Sを押して保存します。これで

[27:27 - 27:31]
Composerを使って構築する準備が整いました。Composerが表示されない場合は、

[27:31 - 27:34]
Command + Iを実行すると右側に表示されます。

[27:33 - 27:36]
デフォルトでは右側にあると思います。

[27:36 - 27:40]
先ほどもお話ししたように、チャット機能があります。これは、

[27:43 - 27:47]
プロジェクト内の何かを理解しようとしたり、ファイル

[27:45 - 27:49]
に追加できるスニペットを提供したりするためのものです。

[27:47 - 27:50]
そして、ファイルのビルド、

[27:50 - 27:56]
編集、

[27:53 - 27:58]
削除を担当するコンポーザーがあります。これは私たちが

[27:56 - 28:00]
ほとんどの場合に使うものです。

[27:58 - 28:02]
ここでズームインしたり、

[28:00 - 28:03]
何かできるといいのですが、

[28:02 - 28:06]
通常バージョンと、プレゼンテーション

[28:03 - 28:07]
で説明したエージェントバージョンがあることがわかります。

[28:06 - 28:10]
これでエージェントが何をするのかがお分かりいただけたと思います。これから

[28:10 - 28:15]
行うことは、エージェントを参照することです。必要に応じて言語モデルを変更することもできます。「

[28:15 - 28:19]
カーソル」→「設定」→「カーソル

[28:17 - 28:20]
設定」に進みます。カーソル内にある言語モデルのプロンプトを追加することもできます。

[28:23 - 28:27]
クリーンなコードを提供するようにしたり、

[28:25 - 28:29]
修正やビルド

[28:27 - 28:30]
プロセス中に考慮すべき事項を指定したりできます。これらが完了したら、

[28:30 - 28:35]
使用したいモデルを選択または選択解除してください。

[28:33 - 28:37]
私はプロ版を使用しているので、モデルが他にもあります。

[28:35 - 28:39]
画像も追加できるので、これらが

[28:37 - 28:42]
完了したら

[28:39 - 28:44]
それが整理されたら、

[28:42 - 28:48]
エージェントを選択して、

[28:44 - 28:52]
始めましょう。指示

[28:48 - 28:53]
に基づいて、Web の文字起こし Web アプリを構築してみましょう

[28:52 - 28:59]
。

[28:53 - 28:59]
MD、署名ページを構築し

[29:00 - 29:03]
、

[29:04 - 29:11]
ワークスペースも作成しましょう。MPN runevを使ってフロントエンドを実行したら、

[29:20 - 29:30]
まずクラークのページを表示し、次にすべてのフォルダと記録が表示される

[29:24 - 29:30]
メインのダッシュボードページを表示しましょう。Nextjs

[29:48 - 29:58]
14と

[29:54 - 30:01]
Clerk

[29:58 - 30:04]
ライブラリを使用していることを確認してください。これは

[30:04 - 30:10]
Nexs 14で動作します。

[30:08 - 30:13]
これで十分だと思います

[30:10 - 30:15]
ので、「送信」を押しましょう。まず、

[30:15 - 30:19]
現在のディレクトリにあるワークスペースの内容を確認します。23個の

[30:17 - 30:21]
ファイルまたはフォルダがあります。

[30:19 - 30:22]
これらをローカル環境ファイルから読み込みます。

[30:22 - 30:25]
すでにClerkキーがあることがわかります。Clerkは、

[30:24 - 30:27]
署名ページで認証を行うために使用するプロバイダーです。Super

[30:25 - 30:28]
Baseは

[30:27 - 30:31]
時間制限があるため、今は使用しません。ダッシュ

[30:31 - 30:34]
ボードページを作成しようとしています。それでは、完成したものを見てみましょう。レイアウトと

[30:34 - 30:39]
中央のWeareを設定し、

[30:37 - 30:42]
すべてが正しく設定されていることを確認しました。 メインページに反映されます

[30:39 - 30:47]
。  DSX、

[30:42 - 30:49]
必要な依存関係をチェックしています。よし、

[30:47 - 30:52]
これですべて完了したら、

[30:49 - 30:56]
すべての変更を受け入れて

[30:52 - 30:59]
準備完了です。MPN Rev を実行しましょう。1

[30:59 - 31:04]
つのプロンプトで結果を確認しましょう。

[31:00 - 31:06]
ポート 3,000 が使用中です。

[31:04 - 31:09]
おそらくエージェントがターミナルにアクセスでき

[31:06 - 31:11]
、ポート 3000 で実行されたためです。3001 を

[31:09 - 31:13]
使用しましょう。結果を確認しましょう。何も

[31:11 - 31:17]
表示されません。白いページが表示されます。

[31:13 - 31:20]
すばらしい。エージェントに、フロントエンドを実行すると白いページしか表示されないことを知らせましょう。

[31:25 - 31:28]
これを修正してください。

[31:30 - 31:33]
ミドルウェアを変更しましょう。

[31:32 - 31:35]
適切なクリア コンポーネントを使用していることを確認しましょう。

[31:33 - 31:37]
よし、

[31:35 - 31:40]
ダッシュボード ページを更新して、適切に

[31:37 - 31:42]
保護およびスタイル設定します。これらの

[31:40 - 31:44]
変更を受け入れましょう。適切な

[31:42 - 31:46]
環境と変数が設定されました。では、

[31:44 - 31:47]
このターミナル インスタンスを停止して、

[31:47 - 31:53]
もう一度実行し、ポート 301 3001 を確認しましょう。

[31:51 - 31:54]
何かが起こっています。

[31:53 - 31:58]
文字起こしアプリがあるだけです。これですべて

[31:54 - 32:02]
です。セットアップを行ってください。 指示

[31:58 - 32:07]
に基づいて店員とワークスペースにサインインします

[32:02 - 32:07]
。  MDですが、空白ページしか表示されません。

[32:09 - 32:14]
空白ページしか表示されません。clo

[32:14 - 32:21]
off sign

[32:19 - 32:26]
inが表示されるはずですが、これで問題ないはずです。現在、

[32:21 - 32:26]
2.1と2.2を実行しようとしています。これを受け入れます。

[32:34 - 32:39]
ホームページで更新します。

[32:37 - 32:43]
ダッシュボードページを更新して、

[32:39 - 32:45]
適切に保護されていることを確認しましょう。わかりました。

[32:43 - 32:47]
これらの変更を受け入れましょう。これで問題が

[32:45 - 32:49]
ないことを確認しています。

[32:49 - 32:52]
必要な依存関係をすべてインストールするように指示されています。先に進めて、

[32:52 - 33:00]
すべて揃っていることを確認しましょう。Sol inde依存関係ツリーを

[32:55 - 33:02]
使用します。次に、13を使用します。MBM Rを試してみましょう。

[33:02 - 33:08]
何が起こっているか見てみ

[33:04 - 33:14]
ましょう。ダッシュボードページが表示されました。

[33:08 - 33:17]
真っ白です。ダッシュボードページのルートダッシュボードにいるように見えます

[33:17 - 33:26]
が、真っ白です。

[33:21 - 33:28]
完全に真っ白で、ter Alには何も表示されていません。

[33:35 - 33:39]
次に、検査に移動してコンソールに移動し

[33:37 - 33:40]
、ここで何が起こっているかを確認することもできます。

[33:39 - 33:41]
どうなるか見てみましょう。

[33:40 - 33:44]
試してみましょう。

[33:41 - 33:46]
JavaScriptバージョンでは、クライアントサイド

[33:44 - 33:48]
レンダリングを適切に実行しましょう。これは

[33:46 - 33:50]
比較的長いプロセスです。

[33:48 - 33:52]
私の説明はMDですが、

[33:50 - 33:54]
あまり時間をかけていないのでベストではありません。

[33:52 - 33:56]
しかし、十分な時間をかけることをお勧めします。41

[33:56 - 34:01]
o1などの他のモデルとクロスチェックしてみましょう。

[33:59 - 34:03]
このNextsフォルダを削除して、

[34:01 - 34:04]
mpm runevを実行しましょう。

[34:03 - 34:06]
開発

[34:04 - 34:08]
サーバーを再起動しましょう。もう一度停止しましょう。H

[34:06 - 34:11]
let MP R ポートを100万個も使用したくない

[34:08 - 34:16]
ので、

[34:11 - 34:16]
3,001にしましょう。ローカルホスト3001に移動しましょう。

[34:18 - 34:24]
これで

[34:21 - 34:26]
ダッシュボードが表示されました。API

[34:24 - 34:29]
キーを開いて、安全なキーがあります。

[34:26 - 34:30]
ここに録音タブがあります。

[34:29 - 34:33]
すでにClerkを使用してサインインしているので、サイン

[34:30 - 34:35]
アウトして、どのように見えるか確認しましょう。

[34:35 - 34:39]
この文字起こしアプリにサインインしました。

[34:37 - 34:41]
素晴らしいですね。もう一度検査をクリックして

[34:39 - 34:43]
開きましょ

[34:41 - 34:45]
う。コンソールに移動してください。 ブラウザ

[34:43 - 34:46]
に表示されるエラーがないか確認してください。

[34:45 - 34:48]
これでサインインできます。Gmail を

[34:48 - 34:54]
使用してサインインできます。

[34:51 - 34:55]
これで完了です。

[34:54 - 34:58]
録音ボタンがありませんが、

[34:55 - 35:00]
openi キーを追加すれば機能するはずです。

[34:58 - 35:02]
先に進み、保存キーを追加して

[35:00 - 35:05]
正常に

[35:02 - 35:08]
録音されていないことがわかります。これは、まだそこまで到達していないためです。

[35:08 - 35:13]
セクション 2.3 に進みましょう。新しいターミナルを入手し、

[35:10 - 35:17]
録音セッションに進みましょう。

[35:13 - 35:23]
録音機能を追加しましょう。

[35:17 - 35:27]
サインインとダッシュボードは

[35:23 - 35:31]
完璧です。録音の開始

[35:27 - 35:35]
ボタンと停止ボタンがないので、

[35:31 - 35:40]
次のセクションの説明に進みましょう

[35:35 - 35:42]
。  MD 2.3 と 2.4 のトランス

[35:40 - 35:44]
クリプションはオプションではなく必須にしたいと

[35:42 - 35:46]
思っています。もう一度言いますが、

[35:47 - 35:52]
これはデモ用に非常に簡単にトランスクリプションを構築しただけです。最高のアプリになるとは思っていませんが、まあ、

[35:50 - 35:53]
見てみましょう。

[35:52 - 35:55]
驚くかもしれません。どのように機能するかを見てみましょ

[35:53 - 35:57]
う。まあ、アイデアは理解できたと思います。各

[35:55 - 35:59]
セクションを確認して、

[35:57 - 36:00]
そのセクションが機能することを確認してから、

[35:59 - 36:02]
次のセクションに進みます。

[36:02 - 36:05]
それではダッシュボードを構築しましょう。つまり、サインインを構築し、

[36:03 - 36:07]
ダッシュボードを構築し、録音

[36:05 - 36:08]
機能などを構築しましょう。その後、

[36:07 - 36:10]
独自の小さな修正を追加できます。これ

[36:08 - 36:11]
で、録音を可能にする get display media 関数を使用しました。

[36:11 - 36:16]
変更を受け入れて

[36:14 - 36:21]
、どのように機能するかを確認しましょう。

[36:16 - 36:23]
コンソールですね。

[36:21 - 36:26]
この状態が記憶されているので、Google アカウントを

[36:23 - 36:28]
使用して Local Host に既にログインしていることがわかります。Open

[36:28 - 36:32]
AI API キーを追加したことが記憶されている

[36:30 - 36:34]
ので、録音を開始できます。 では、

[36:32 - 36:36]
これがうまくいくかどうか見てみましょう。画面全体を試してみましょう。

[36:36 - 36:42]
これは興味深いでしょう。今、

[36:40 - 36:44]
録画中です。

[36:42 - 36:46]
ここに録画オプションがあります。ズームインできるかどうか見てみましょう。

[36:44 - 36:48]
そうです。それができています。これは

[36:46 - 36:50]
素晴らしいです。では、

[36:48 - 36:51]
他のタブに移動して、

[36:50 - 36:56]
実際に録音がキャプチャされているかどうかを確認しましょう。

[36:51 - 36:58]
とてもクールです。

[36:56 - 37:03]
ここに戻って録画を停止しましょう。

[37:03 - 37:06]
画面全体の実際の録画が再生されます。

[37:04 - 37:08]
これは素晴らしいです。音声がキャプチャされているかどうかを確認しましょう。

[37:06 - 37:11]
マイクは

[37:08 - 37:14]
オンになっているので、

[37:11 - 37:17]
キャプチャされているかどうかを確認しましょう。

[37:14 - 37:19]
録音の書き起こしに失敗しました。理解しましょう。

[37:17 - 37:20]
もう一度録音を試してみましょう。APIキーが

[37:19 - 37:22]
間違っているとは思いません。バックグラウンド

[37:20 - 37:24]
でのAPIキーに関するロジックが

[37:22 - 37:25]
間違っている可能性があります。

[37:25 - 37:29]
コンソールのエラーをもう少し理解しましょう。

[37:27 - 37:30]
店員のところへ行きましょう。

[37:30 - 37:35]
よし、それでは文字起こしをしてみましょう。

[37:33 - 37:38]
ここで何が起きているのか見てみましょう。

[37:38 - 37:43]
この問題を詳しく見てみましょう。問題が発生している実際の行も確認できます。スクリーンショットを撮って、

[37:43 - 37:48]
カーソルに戻しましょう。うまく

[37:47 - 37:53]
動作しています。

[37:48 - 37:58]
今度は文字

[37:53 - 38:01]
起こしボタンに問題があります。文字起こし

[38:12 - 38:17]
ボタンをクリックしたときに表示されるエラーを示す画像を見てください。文字起こしボタンをクリックすると、文字

[38:17 - 38:21]
起こし

[38:22 - 38:27]
ボタンが表示されます。文字起こしボタン。では、これを見てみましょう。

[38:25 - 38:30]
問題は、Opening Eyes Whisper I が Webon

[38:27 - 38:31]
ファイルを直接受け入れないことです。

[38:31 - 38:36]
録音からオーディオだけを抽出し、Whisper が受け入れる形式に変換する必要があります。納得できます。

[38:36 - 38:39]
少なくとも依存関係の

[38:37 - 38:41]
問題などではなく、機能を

[38:39 - 38:43]
追加する必要があるだけです。では、それを

[38:41 - 38:45]
追加しましょ

[38:43 - 38:47]
う。納得できます。WAV は

[38:45 - 38:51]
Whisper が受け入れる形式です。すべて受け入れてみましょう。

[38:47 - 38:52]
すると、ビデオとオーディオが

[38:51 - 38:55]
自動的に抽出されます。

[38:52 - 38:59]
ビデオから抽出して W に変換します。

[38:55 - 38:59]
よし、もう一度録音しましょう。1

[39:02 - 39:10]
2 3 1 2 3

[39:06 - 39:12]
録音を停止します。彼女は一番下にいます。

[39:12 - 39:19]
今度は文字起こしです。録音の文字起こしに失敗しました。AUT

[39:16 - 39:23]
ファイルが短すぎます。

[39:19 - 39:23]
最小オーディオ長は 0.1

[39:26 - 39:31]
秒です。それで何が

[39:28 - 39:33]
起こっているのか分かりました。これでオーディオを録音でき

[39:31 - 39:35]
、音が出ているのを聞くことができます。

[39:33 - 39:37]
しかし、文字起こしを押すと文字

[39:37 - 39:42]
起こしされません。オーディオ

[39:39 - 39:44]
ファイルが短すぎると表示されます。デバッグしてみましょう。

[39:42 - 39:46]
ここではあまり時間をかけたくないです。お分かりだと

[39:44 - 39:49]
思います。

[39:46 - 39:54]
戻って、ここに来て、

[39:49 - 39:58]
音声を正常に録音しましたが、文字

[39:54 - 40:04]
起こしを押すと、

[40:06 - 40:14]
ビデオとオーディオが約 13 秒のときにオーディオの長さが 0.1 秒未満であると表示されます。

[40:10 - 40:18]
約 13

[40:14 - 40:22]
秒です。なぜだと思いますか。

[40:18 - 40:25]
修正方法を教えてください。

[40:25 - 40:29]
では、提案されていることを見てみましょ

[40:28 - 40:30]
う。 何か問題が発生しています。

[40:30 - 40:35]
何らかの理由で、音声が 100 ミリ秒しか録音されていないためです。

[40:32 - 40:37]
現在これを修正中で、

[40:37 - 40:43]
文字起こし機能を更新して、

[40:40 - 40:46]
ページを更新します。 ありがとうございます。

[40:43 - 40:48]
変更を加えました。これで

[40:46 - 40:50]
変更が反映されました。100

[40:50 - 40:53]
ミリ秒以上抽出しています。どうやらこれは

[40:53 - 40:58]
現在のプロジェクト内で行われた設定のようです。では、

[40:56 - 40:59]
Vで変更を受け入れ、

[40:58 - 41:02]
完全にリロードしてみましょう。はい、

[40:59 - 41:04]
自動的に実行されます。これで

[41:02 - 41:05]
音声を録音できるはずです。

[41:04 - 41:08]
マイクを外して、プロセスを見てみましょう。

[41:21 - 41:28]
これで

[41:24 - 41:29]
戻りました。音声が録音されました。

[41:29 - 41:35]
ビデオがおかしくなっているのがわかります

[41:32 - 41:37]
ね。つまり、

[41:35 - 41:39]
男性が話しているところをキャプチャしました。

[41:37 - 41:42]
スライダーの動きが少しおかしいですね。

[41:39 - 41:43]
でも、大丈夫です。では、文字

[41:42 - 41:45]
起こし機能がどのように

[41:43 - 41:46]
動作するか見てみましょう。ファイルを開くリクエストを送信しています。

[41:46 - 41:52]
無効なファイル形式です。

[41:50 - 41:55]
大丈夫です。これは良いエラーです。

[41:52 - 41:57]
少なくともエラーの内容はわかります。

[41:55 - 42:02]
スクリーンショットを撮ってここに貼り付けましょう。これで

[41:57 - 42:05]
正しく表示されるはずです。

[42:14 - 42:19]
Open AI に送信するときに、オーディオのフォーマット方法にエラーがあるようです。

[42:20 - 42:29]
オーディオが Open API サービスに送信されようとしていることがわかります。オーディオのフォーマット

[42:33 - 42:38]
方法にエラーがあるようです。

[42:38 - 42:43]
添付の​​画像を参照してください。完璧です。[送信] をクリックし、

[42:41 - 42:45]
問題を理解したので、

[42:43 - 42:48]
ページを更新します。  TSXなので、

[42:45 - 42:52]
適切なMタイプを追加して、クリーンアップ

[42:48 - 42:55]
しました。MP3ではなくWeb M形式を使用しています。

[42:52 - 42:58]
これで

[42:55 - 43:01]
変更を受け入れましょう。

[42:58 - 43:02]
ローカルホストが再び更新されるようです。

[43:01 - 43:04]
ええと、はい、転記できませんでした。

[43:02 - 43:06]
再度読み込み中です。問題ありません。

[43:04 - 43:08]
同じプロセスをもう一度実行します。それでは、

[43:06 - 43:11]
マイクを外して、オーディオが

[43:08 - 43:11]
キャプチャされていることを確認します。

[43:12 - 43:17]
これで、もう一度転記をクリックできるはずです。

[43:15 - 43:19]
転記に失敗しました。

[43:17 - 43:23]
録音の転記に失敗しました。無効なファイル形式です。サポートされている

[43:19 - 43:25]
形式です。何が起こっているのか見てみましょう。EYを

[43:25 - 43:30]
開くためのPOSTリクエストを送信しています。これは不正な

[43:27 - 43:33]
リクエストなので、

[43:30 - 43:36]
もう一度渡しましょう。停止しましょう。

[43:33 - 43:39]
ターミナルインスタンスを強制終了して、

[43:36 - 43:39]
再度読み込みます。ブラウザからの

[43:41 - 43:48]
エラーメッセージは次のとおりです。

[43:48 - 43:54]
それでは、

[43:50 - 43:56]
これが何を意味するのか見てみましょう。これで

[43:56 - 44:04]
理解が深まったと思います。適切な

[43:59 - 44:06]
WAVです。rawを取得してTransformersに

[44:04 - 44:08]
wav ブラウザのコンソールを確認してください。

[44:06 - 44:09]
オーディオ BLOB のサイズは前よりも大きくなっている

[44:08 - 44:11]
はずです。

[44:09 - 44:14]
確認すべき点がいくつか表示されています。変更を受け入れて、

[44:11 - 44:19]
mpm runev を実行し

[44:14 - 44:22]
ましょう。はい、3001 を使用しましょ

[44:19 - 44:24]
う。これで問題ありません。API キーがあることを思い出しました。

[44:22 - 44:28]
よし、

[44:24 - 44:28]
マイクをもう一度切断します。申し訳ありません。

[44:31 - 44:36]
これで、

[44:36 - 44:40]
終わりに近づくにつれてどんどん遅くなるのが面白いです。これは非常に

[44:38 - 44:42]
面白いです。明らかに

[44:40 - 44:44]
均等に間隔が空いているはずですが、

[44:42 - 44:47]
何も期待していません。これは AI によって

[44:44 - 44:49]
非常に短い時間で構築されたということです。とにかく、うまくいけば

[44:47 - 44:52]
30 秒未満です。21

[44:49 - 44:56]
秒です。では、

[44:52 - 45:00]
データを文字起こししましょう。文字起こしが作成されました。これでうまく

[44:56 - 45:02]
いきます。ご覧のとおり、

[45:02 - 45:06]
カーソルを使用してこのプロセスを実行するのは簡単ではありません。

[45:04 - 45:07]
簡単なプロセスであれば、誰もが

[45:06 - 45:09]
正しく実行できます。バックグラウンドでこれらの機能がどのように機能するかを少し理解する必要があります。そうすれば

[45:09 - 45:12]
、

[45:10 - 45:13]
プレゼンテーションが

[45:12 - 45:15]
バックエンドで

[45:13 - 45:17]
すべてのデータを処理し、APIに接続し、

[45:15 - 45:19]
フロントエンドで表示されるような仕組みです。

[45:17 - 45:21]
そして、

[45:19 - 45:24]
クラークのような認証方式で、

[45:21 - 45:25]
ユーザーがGoogleアカウントでログインしたり、

[45:25 - 45:31]
独自のユーザー名と

[45:28 - 45:33]
パスワードでログインしたりできるようになっています。ここではお見せしていませんでしたが、

[45:31 - 45:35]
フォルダは作成していません。

[45:33 - 45:38]
理想的にはフォルダを選択して、「

[45:38 - 45:41]
録音はこのフォルダに保存する」などといった設定ができるはずです。しかし、この開発に

[45:41 - 45:46]
費やした時間はわずかですが、これは素晴らしいと思います。さらに

[45:46 - 45:49]
機能を追加したい場合は、

[45:48 - 45:51]
先ほども述べたように、バックグラウンドでSuper Baseを追加すれば、

[45:51 - 45:54]
録音や文字起こし、

[45:53 - 45:56]
ユーザーのAPIキーを保存できます。これにより、ユーザーが

[45:54 - 45:57]
再度ログインする際に、APIキーを入力

[45:56 - 45:59]
する必要がなくなります。つまり、この場合は

[45:57 - 46:02]
少し異なりますが、

[45:59 - 46:03]
ユーザーが

[46:02 - 46:05]
2回目にログインした際に保持しておきたいデータなど、あらゆるデータを保持できます。これは

[46:03 - 46:07]
少し複雑になります。 本番環境にプッシュするときに関係します。

[46:05 - 46:09]
アプリを本番環境にプッシュすると、バックエンドに

[46:09 - 46:13]
Super Baseと

[46:11 - 46:15]
認証、Clerkが利用できるようになります。Clerkを使うと、

[46:15 - 46:20]
アプリをホストする場所が必要になります。選択肢としてはVerselがあります。Verselは、アプリをホストし

[46:18 - 46:22]
たりレンダリングしたりできます。

[46:22 - 46:26]
詳細を入力してサーバーにホストできます。

[46:24 - 46:27]
今はローカルにホストされている

[46:26 - 46:29]
ので、このようにすることで

[46:27 - 46:30]
他の

[46:29 - 46:32]
人にも見てもらうことができます。また、

[46:30 - 46:34]
Dockerコンテナなどを実行することもできます

[46:32 - 46:37]
が、これは

[46:34 - 46:39]
今回の話の範囲外だと思います。さて、皆さん、

[46:37 - 46:42]
言い忘れていましたが、

[46:39 - 46:44]
これをGitHubに保存する場合は、

[46:44 - 46:50]
必ずreadmeファイルを作成してください。Markdownファイルです。他の

[46:47 - 46:52]
人にわかるように、または

[46:50 - 46:54]
これがどのように

[46:52 - 46:57]
動作するかを覚えておくために。そして、

[46:57 - 47:03]
不要なファイルを無視するために、g ignoreファイルも作成してください。API

[47:03 - 47:08]
キーがあるEMVファイルを含める必要があります。

[47:06 - 47:14]
ライセンスファイルを作成します。これが

[47:08 - 47:17]
コントロールです。先に進む前に、

[47:14 - 47:19]
GitHubに行って

[47:17 - 47:23]
新しいリポジトリを作成しましょう。「

[47:19 - 47:24]
test transcription YouTube」という名前にします。YouTubeのトランスクリプションが必要な場合は、「

[47:24 - 47:30]
test

[47:27 - 47:32]
transcription YouTube」にします。「test transcription YouTube」でいいです。

[47:30 - 47:34]
今は非公開にしておきましょう。「

[47:32 - 47:37]
readme」ファイルを追加します。

[47:37 - 47:40]
ここに追加すればいいと思います。そのままにしておき

[47:40 - 47:45]
ます。

[47:43 - 47:46]
リポジトリを作成すると

[47:45 - 47:47]
URLが表示されますので、

[47:46 - 47:50]
この

[47:47 - 47:53]
URLを取得して、「

[47:50 - 47:58]
origin」を追加するときに使用します。「

[47:53 - 48:01]
get

[47:58 - 48:03]
initialize」を実行します。「add everything」を実行します。「

[48:01 - 48:06]
dot」はすべてのファイルを意味します。次に、

[48:03 - 48:07]
最初のコメントを追加します。

[48:06 - 48:11]
これは

[48:07 - 48:14]
ファイルの最初のバージョンをプッシュするだけです。よろしければ、

[48:11 - 48:18]
すべてを再作成します。「

[48:14 - 48:21]
get remote」を追加します。「get remote」は「

[48:21 - 48:30]
get remote at origin」です。「get

[48:27 - 48:32]
remote at origin」です。そして、先ほど選択したURLを入力します。

[48:34 - 48:41]
リポジトリを作成したら、Enterキーを押して進みましょう。G

[48:36 - 48:44]
Branch

[48:41 - 48:49]
mainと入力してメイン

[48:44 - 48:49]
ブランチにプッシュし、kit push origin

[48:50 - 48:57]
mainと入力して完了です。これで

[48:54 - 49:00]
ファイルが表示されるはずです。

[48:57 - 49:04]
更新してみましょう。

[49:04 - 49:11]
カーソルを使ってビルドしたファイルがここにあります。これで

[49:07 - 49:14]
ほぼ完了です。

[49:11 - 49:17]
ご覧の通り、

[49:14 - 49:19]
ここでトランスクリプションアプリをビルドしました。これを

[49:17 - 49:21]
GiOPにアップロードしたので、ビルドを繰り返すことができます。

[49:21 - 49:27]
バージョン

[49:23 - 49:28]
2が完成し、

[49:27 - 49:31]
必要なものがすべて揃っていることを確認したら、

[49:31 - 49:37]
Gitアクションを実行できます。先ほどと同じ

[49:34 - 49:38]
Gitアクションです。これで完了です。ここではこのままにし

[49:37 - 49:42]
ておきます。Clerkを

[49:42 - 49:45]
使ってユーザー認証ロジックを実行できたのがお分かりいただけると思います。

[49:44 - 49:48]
とても簡単です。Googleを

[49:45 - 49:50]
使ってサインインできます。I

[49:48 - 49:52]
キーも開いているので、録音を始める前に設定する必要があります。

[49:52 - 49:56]
キーを外すと

[49:54 - 49:57]
無効になります。これは

[49:56 - 49:59]
すごいですね。

[49:59 - 50:04]
タブを使って録音できます。音声

[50:02 - 50:07]
と動画を録音し、

[50:04 - 50:09]
音声を文字

[50:07 - 50:12]
起こしサービスに送信します。この場合は

[50:09 - 50:13]
音声モデルです。ささやき声です。

[50:12 - 50:16]
そしてそれを元に戻し、

[50:13 - 50:17]
動画の下にレンダリングします。

[50:16 - 50:20]
動画の再生もできます。これはすごいですね。

[50:17 - 50:22]
スライダーはうまく機能しませんが、ファイル名が

[50:20 - 50:25]
あります。これは

[50:25 - 50:30]
バックエンドで定義されています。以上です。この

[50:30 - 50:35]
動画を楽しんでいただけたら嬉しいです。気に入ったら「いいね！」とチャンネル

[50:33 - 50:37]
登録をお願いします。

[50:35 - 50:39]
このような動画をもっと見たい方はお知らせください。

[50:37 - 50:41]
もしこの動画が気に入らなかった場合は、下の

[50:39 - 50:43]
コメント欄で理由を教えて

[50:52 - 50:57]
ください。以上です。他にコンテンツの提案があればお知らせください。もし今年の他の動画で私が見当たらない場合は、 メリー

[50:54 - 51:01]
クリスマス、そして良いお年を。

[50:57 - 51:01]
皆さん、気をつけて。また後で会いましょう。

## コメント

### 1. @franknillard (👍 1)
Would you guys use this transcription app? Planning on deploying it so that you guys get to use it, let me know!

### 2. @powermyapps (👍 32)
Guys, this is a 55-minute class. Save it, download it if you can. The instructor is explaining really important stuff that you don’t come across every day. It’s super useful and will help you develop your ideas for future AI apps.

> **@franknillard** (👍 0): Hey, thanks a lot for your comment. I am glad you saw value in the video. Means a lot. Any specific things that you'd like to see in further videos?

> **@powermyapps** (👍 2): @@franknillard Would love to see what kind of technologies we can use to build a website. I use Swift for iOS app development with Cursor but I want to build web apps as well. Like a mini CRM for my production line to plan production with AI (by using Google's free API) and a local AI Chatbot which is connected with WhatsApp or Slack so I can chat with my company data while on the road.

> **@jasne2992** (👍 0): Ios swift app tutorial would be amazing

> **@franknillard** (👍 0): @@jasne2992 On my way!

### 3. @hmzaipath (👍 2)
actual useful commands he give, take notes guys

### 4. @Bryson_bcy (👍 2)
Awesome content. I have been searching for a video that can teach me the entire process of developing a project using a cursor. This video is a perfect choice. Thank you!!

> **@franknillard** (👍 0): I’m glad it helped you! Thank you very much! :)

### 5. @othon.rodrigues (👍 10)
Nice!! 🤗Please do part 2!!!! Its rare this type of content 💪

> **@franknillard** (👍 0): Hey! Will definitely consider this, thank you for your comment :)

> **@dalecrum-ewing2239** (👍 1): @@franknillard Please do it, this was very good.

### 6. @Wavewave583 (👍 2)
Sir, you have literally saved my life. I was so insanely inefficient with trying to build my simple app and now I know why. AGENT mode is god tier! Deep into drafting my instruction.md file 🙌

> **@franknillard** (👍 0): Hey, I love reading comments like these. I am really happy that I was able to help you!!!! Now, back to building!!! 🤗

### 7. @pH7Programming (👍 0)
As always, PERFECTO 👌

> **@franknillard** (👍 0): Gracias!

### 8. @dawid_dahl (👍 1)
The idea that a non-coder/programmer would be comfortable doing this workflow and all the debugging you did in the later part of the video is pretty funny. 😅

Anyway, as a working programmer I really enjoyed the video, very useful! Thank you. 🙏🏻

> **@franknillard** (👍 2): Hahaha, I think the debugging is an essential part to building anything in code! You have a to be comfortable getting errors, that's where you learn the most! On a sidenote, thank you for the comment and support, means a lot.

### 9. @rhyscampbell4178 (👍 3)
Awesome video! Thanks for all the info!

Here’s what I’d do differently :) based on what I’ve learnt.

1: Using the notepad feature to store all of these instructions and everything is much better as it localises them all to the notepads menu - this means none of your internal development instruction files or PRD documents will get committed to your GitHub repo - they will instead stay in the IDE’s project session.

2: based on my experience, to save you time from going to Anthropic to have it format your o1 message, you’ll find that when you copy the entire message from o1, when you paste it, it will be in markdown format - it just means you have to delete its intro and outro jargon.

> **@franknillard** (👍 1): Hey; Point 1 makes sense, will have a look at that. I realised Point 2 as I was uploading this video haha. Thanks for your comment, your feedback means a lot!

> **@sivakumarm3569** (👍 0): That's why there is an option called git ignore right 🤔

> **@franknillard** (👍 1): @ 😂

### 10. @OffcourseAI (👍 0)
i successfully made it to the authentication screen using clerk and logged into my web app through otp. Was a surreal experience . You have explained this perfectly to the T especially the files documentation part and not depending solely on the editor for the files was a game changer 

it took me around 2 hrs to do so

> **@franknillard** (👍 0): Hey! Thank you for your comment. I love reading comments like these, knowing that I made a difference into someone's day. Now, it's time to finish the web app! Best of luck!

### 11. @EricTidmore (👍 0)
This is the way dude excellent job prompting

> **@franknillard** (👍 0): Thanks man, glad I was of help :)

### 12. @Alx-gj2uz (👍 2)
Great video, my biggest learning was, first do proper requirements engineering and then start to code. You just have a way faster feedback cycle with AI and thats what it was all about. Something whe theoretically should have done in the past, but forgot about in the "Agile Age". Great to see that AI will make this clear to us again. Remember the golden rule of computer science, "shit in / shit out".

> **@franknillard** (👍 1): 100%!!  Because of AI, now the power is in being very good at defining what you want! Fully agree with the shit in shit out as well haha

### 13. @MarketMakerIQ (👍 0)
Most informative video and channel yet and I knew it since the first one I saw

> **@franknillard** (👍 0): Hey, can't express how much I love reading comments like yours. Thanks a lot, really.

### 14. @emdangelo (👍 0)
Great tutorial. Please do part 2 where you connect the backend database with Supabase or MySQL & UI refinement steps. Thank you.

> **@franknillard** (👍 0): hey, thanks for the comment, will clean up some of the project code and will bring you something like you asked!

### 15. @farastray1 (👍 2)
Its ironic, but I have started adopting a flow very similar to this for new projects and I find it works a little smoother. I try to spend some time putting together docs that explain functionality and system design, road map up front. Its then a little bit more predictable when you ask Cursor to make changes.

> **@franknillard** (👍 0): Yes! Well thought, planning in todays AI age is crucial. Keep it going!!!

### 16. @orthodox_gentleman (👍 0)
This info is excellent so thank you!

> **@franknillard** (👍 0): You are so welcome!

### 17. @m3dia_offline (👍 0)
great video, however I do wanna point out, cursor can convert the text into markdown as well :)

### 18. @lilcleo001 (👍 0)
This is such a good video. Thank you! I’m jotting down notes to try this workflow out. How do I get access to the presentation?

> **@franknillard** (👍 0): Hey! Please access the free Skool community to get the presentation!

### 19. @Dagoodev (👍 2)
please do you know which command i can use for tree? i use window pc and not macbook both command are different (25:22)

> **@franknillard** (👍 0): Hey! I don't know from the top of my head, I suggest that you quickly go to perplexity/chatGPT and ask

### 20. @m_g_tek5525 (👍 1)
super content. thank you very much for this.

> **@franknillard** (👍 0): Hey! Thanks for your comment, I am very happy that you enjoyed your content :)

