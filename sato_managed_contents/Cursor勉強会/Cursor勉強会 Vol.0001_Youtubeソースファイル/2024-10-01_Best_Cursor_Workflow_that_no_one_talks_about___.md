# Best Cursor Workflow that no one talks about...

**チャンネル:** AI Jason
**公開日:** 2024-10-01
**URL:** https://www.youtube.com/watch?v=2PjmPU07KNs

## 説明

Tutorial: Best Cursor workflow to boost 10x effectiveness
Get Helicon for free (Use 'AIJASON30' for 30% off for 6 month if you wanna upgrade): https://www.helicone.ai/?utm_source=youtube&utm_medium=video&utm_id=ai-jason-cursor

🔗 Links
- Get full code breakdown & Join AI builder club: https://link.agent.rocks/8ni6ADM
- Follow me on twitter: https://twitter.com/jasonzhou1993
- Join my AI email list: https://www.ai-jason.com/
- My discord: https://discord.gg/eZXprSaCDE

⏱️ Timestamps
0:00 Intro
2:25 Step 1 - Plan & Prep PRD
16:57 Step 2 - Build frontend
22:34 Step 3 - Connect LLM monitoring platform
25:44 Step 4 - Connect Supabase
37:26 Step 5 - UI Touch up


👋🏻 About Me
My name is Jason Zhou, a product designer who shares interesting AI experiments & products. Email me if you need help building AI apps! ask@ai-jason.com

#cursor #webscraping  #generativeai #gpt5 #autogen #gpt4 #autogpt #ai #artificialintelligence #tutorial #stepbystep #openai #llm #chatgpt  #largelanguagemodels #largelanguagemodel #bestaiagent #chatgpt #agentgpt #agent #babyagi

## 字幕

[00:00 - 00:03]
このビデオは、

[00:05 - 00:09]
大規模なLモデルアプリケーションのログ記録、監視、デバッグに最適なオープンソースプラットフォームの一つであるhadongがスポンサーとなっています。今日は、

[00:07 - 00:11]
カーソル

[00:09 - 00:13]
ワークフローを10倍効率化し、矢印の数を

[00:11 - 00:14]
大幅に減らして本番レベルのアプリケーションを構築する方法をご紹介します。カーソルとは

[00:13 - 00:16]
何かご存じない方のために、

[00:14 - 00:18]
カーソルとは最も人気のあるAIコード

[00:16 - 00:20]
エディタで、誰もが学習してい

[00:32 - 00:34]
ます。カーソルを使えば、8歳の子供でも自然言語だけで完全に機能するアプリケーションを構築できます。先週だけでも、インターネット上では、カーソルを使って構築した美しいアプリケーションを披露する素晴らしい例がたくさん見られました。しかし、実際にカーソルアプリを使って構築を始めると、

[00:33 - 00:37]
おそらく

[00:34 - 00:39]
無数の矢印に遭遇し、

[00:37 - 00:41]
実際に実行するのが難しくなるでしょう。もし

[00:39 - 00:43]
あなたがこのような経験をしたなら、幸いなことに、

[00:44 - 00:48]
成功率を劇的に向上させるためにできることはたくさんあります。例えば、

[00:46 - 00:50]
カーソルにWebアプリケーション全体を構築するという単純な指示を与えるのではなく、

[00:53 - 00:57]
カーソルと通信して連携するための最適なドキュメントの書き方を学ぶ必要があります。コア

[00:55 - 00:58]
機能とは何か、ファイル

[00:57 - 01:00]
構造はどのようになっているのか、コード例を含め

[00:58 - 01:02]
、すべての依存関係をリストアップするか、あるいはどの

[01:02 - 01:06]
テキストがどの依存関係なのかが少し不明瞭になるかなどを学ぶ必要があります。 どのような手法を

[01:04 - 01:09]
使うべきか、クラウドVZ

[01:06 - 01:11]
とカーソルをどのように統合されたワークフローに組み込むか、

[01:09 - 01:12]
そしてどちらをいつ使うべきか、

[01:11 - 01:14]
これらのヒントとベストプラクティスの

[01:12 - 01:16]
ワークフローを活用することで、私

[01:14 - 01:18]
自身の目標達成率を劇的に向上させることができました。そこで、

[01:18 - 01:22]
私のワークフローがどのようなものかを段階的に説明し、皆さんも

[01:20 - 01:24]
次の夢のアプリを再現して構築できるようにしたいと思います。

[01:24 - 01:28]
今日ご紹介するサンプルアプリケーションは、Gummy Searchという非常に

[01:26 - 01:29]
興味深いAI分析プラットフォームです。

[01:28 - 01:32]
これは基本的に、

[01:29 - 01:35]
Lモデルが得意とする、

[01:32 - 01:37]
何千もの

[01:35 - 01:39]
非構造化Reddit投稿を読み取り、人々が

[01:37 - 01:41]
どのような

[01:39 - 01:42]
点に困っているのか

[01:41 - 01:44]
、どのような

[01:42 - 01:46]
解決策が求められているのかといった重要な情報を要約して抽出するという手法を活用しています。

[01:44 - 01:48]
このアプリについては、

[01:46 - 01:50]
Gregの動画で

[01:48 - 01:52]
Gumi Searchを使ってスタートアップのアイデアを見つける方法を紹介していました。この動画は非常に

[01:50 - 01:53]
おすすめです。私が

[01:52 - 01:56]
このアプリを例として使うことに興味を持ったのは、

[01:56 - 01:59]
膨大な

[01:57 - 02:01]
非構造化データからLモデルを読み取り、洞察を抽出できるという点です。これは、

[02:01 - 02:05]
Redditだけでなく、他の多くのデータソースにも活用できる可能性があります。

[02:03 - 02:07]
Twitter、

[02:05 - 02:08]
Facebook グループ、Discord のアプリケーション、または他の

[02:07 - 02:10]
場所で取得したプライベート データ ソースなどです。1

[02:08 - 02:12]
時間で、カーソルを使用して、

[02:14 - 02:17]
何千もの投稿を解析し、

[02:16 - 02:19]
重要な情報を要約して抽出して人々が

[02:17 - 02:22]
見つけられるようにするソーシャル メディア分析プラットフォームを報告する方法を紹介します。完全なバックハンド

[02:19 - 02:23]
セットアップと大規模な

[02:22 - 02:25]
言語モデル監視プラットフォームとの統合により、

[02:23 - 02:28]
コストを最適化できる機会があります。では、始めましょう。

[02:28 - 02:32]
カーソル ダイレクトに

[02:30 - 02:34]
何かを構築するように求められるのではなく、

[02:32 - 02:35]
計画を立てる必要があります。最初に、

[02:34 - 02:37]
どのような

[02:35 - 02:40]
コア機能を出荷するかについて少し検討します。私の

[02:37 - 02:42]
プロセスは、アプリケーションが有用である必要があるコア スコープを吐き出すことです。

[02:40 - 02:44]
次に、

[02:42 - 02:46]
簡単な調査を行い、コア機能に

[02:44 - 02:48]
どのようなパッケージを使用できるかを理解するため、chbt に相談するかもしれません。

[02:48 - 02:53]
最終的には、

[02:50 - 02:55]
クラウドまたは 01 モデルを使用してプロジェクト

[02:53 - 02:56]
構造フォルダーを設計し、

[02:55 - 02:58]
すべての要件に基づいて事前に計画を立て、

[02:56 - 03:00]
詳細な

[02:58 - 03:02]
要件を書き出すことができます。特定のケースでは、

[03:02 - 03:07]
Reddit 分析プラットフォームと呼ばれる新しい GitHub レポートを作成してから、

[03:04 - 03:09]
手順の作成を開始します。  MD

[03:07 - 03:10]
ファイルで、通常は次のようなファイル構造から始めます。Purの

[03:10 - 03:15]
概要を説明し、次に

[03:17 - 03:21]
使用するパッケージのドキュメントや現在のファイル

[03:19 - 03:22]
構造などのクールな機能について説明します。これにより、01モデルに

[03:21 - 03:24]
少し計画を立ててもらうことができます。

[03:24 - 03:27]
特にWebアプリケーションを構築している場合は、

[03:25 - 03:29]
プロジェクトの概要について非常によく似た構造をたどることができます。

[03:33 - 03:37]
ここでは、ユーザーがさまざまなサブレディットの投稿にアクセスして

[03:35 - 03:40]
トップコンテンツや

[03:37 - 03:43]
投稿のカテゴリを確認できるRedditアプリケーションプラットフォームを構築していることを簡単に説明します。Tailwind

[03:40 - 03:46]
Lucidアイコンでnextjs 14シャーシを使用します。Tailwind Lucidアイコン

[03:43 - 03:48]
とTaxスタックの観点から、nextjsはReactに似た

[03:46 - 03:51]
フレームワークの1つです。Chassenは

[03:51 - 03:56]
UIコンポーネントライブラリ、telwinは

[03:54 - 03:58]
コードをより

[03:56 - 04:00]
理解しやすくするCSSライブラリです。Lucidは

[03:58 - 04:02]
使用できるアイコンライブラリですが、

[04:00 - 04:03]
他のコンポーネントライブラリを使用したい場合は

[04:02 - 04:05]
ここで変更できます。次に、コア機能について説明します。

[04:05 - 04:09]
最も重要な部分は、

[04:07 - 04:11]
基本的に

[04:09 - 04:14]
このアプリ

[04:11 - 04:16]
に必要なコア機能は何かをよく考えたいということです。私の場合、Gummy

[04:14 - 04:19]
Searchを参考にすると、利用可能な

[04:16 - 04:20]
すべてのsubredditを実際に表示し

[04:19 - 04:23]
、ユーザーが必要に応じて新しいsubredditを作成できるページが必要です。

[04:20 - 04:25]
また、特定のsubredditの

[04:23 - 04:28]
詳細をすべて確認する部分も必要です。

[04:25 - 04:30]
私の経験から、

[04:28 - 04:32]
Gumi Searchの最も便利な部分は

[04:30 - 04:34]
同じで、トップコンテンツ

[04:32 - 04:36]
と、

[04:34 - 04:38]
人々が解決策の要求について話し合っている投稿のカテゴリを確認できます。P

[04:36 - 04:40]
anger、そして

[04:38 - 04:43]
Gumi Searchよりもできることは、

[04:43 - 04:47]
特定の種類の投稿を

[04:44 - 04:49]
見つけたい場合があるため、ユーザーが

[04:47 - 04:50]
新しいカテゴリを追加できるようにしたいということです。私の場合、

[04:49 - 04:52]
いくつかの異なる

[04:50 - 04:54]
機能が必要です。1つは、

[04:52 - 04:57]
利用可能なsubusのリストを表示し、

[04:54 - 05:00]
新しいsub Rusを追加する機能です。サブページを表示する必要があります。

[04:57 - 05:03]
また、

[05:00 - 05:05]
トップ投稿タブに投稿データをFatする必要があり、

[05:03 - 05:07]
Open AIを使用して投稿データを

[05:05 - 05:10]
さまざまなカテゴリSSに分析する必要があります。最後に、

[05:07 - 05:12]
新しいSEカテゴリを追加するためのボーナスポイントが

[05:10 - 05:14]
必要です。 その後にやるべきことは、基本的に、

[05:14 - 05:18]
できる限り詳細なやり取りをすべて書き出すことです。

[05:16 - 05:20]
詳細な製品ドキュメントを書くのが初めてであれば、

[05:18 - 05:21]
おそらく時間はかかりますが、それだけの

[05:20 - 05:23]
価値はあります。私の場合は、

[05:21 - 05:25]
ユーザーが

[05:25 - 05:30]
カードに表示されている、既に作成済みの利用可能なスバルのリストを見ることができるように詳細を書き留めます。一般的なカードには、

[05:27 - 05:32]
AMAやOpen AIなどがあります。ユーザーは「

[05:30 - 05:34]
Redditを追加」ボタンをクリックすると、

[05:32 - 05:37]
モデルが開き、RedditのURLを貼り付けて

[05:34 - 05:39]
追加できます。ユーザーがRedditを追加すると、

[05:37 - 05:42]
新しい車が追加されます。サブレディット

[05:39 - 05:44]
ページでは、各サブレディットをクリックすると、

[05:42 - 05:46]
2つのタブがあるRedditページに移動します。その他の

[05:44 - 05:47]
詳細も表示されます。これらの詳細は、

[05:46 - 05:49]
ビデオを一時停止して

[05:47 - 05:51]
後で入力できます。このコア機能の次に

[05:49 - 05:53]
行うことは、いくつかの機能を構築するために

[05:51 - 05:54]
使用するライブラリとパッケージを見つけること

[06:06 - 06:10]
です。含める必要があるドキュメントは2種類あります。1つは、Redditデータを準備する方法を示すコード例です。最も簡単な方法は、チャットGBTに問い合わせることです。特に、レディターが新しいものではないこの機能についてはそうです。  SCさん、

[06:10 - 06:13]
Reddit向けの実装方法に関するトレーニングデータは既にお持ちだと思いますので、

[06:13 - 06:18]
ファッション関連のReddit投稿データを扱うためにNextJSを使ってWebアプリを構築しています。

[06:15 - 06:20]
どのパッケージを使うのが最適か質問

[06:18 - 06:22]
できます。Snow wrapが

[06:20 - 06:25]
最適なパッケージの一つだと思われる場合は、

[06:22 - 06:27]
npmjs.comに行って

[06:25 - 06:30]
そのパッケージを検索します。mpmは

[06:27 - 06:31]
パッケージマネージャのようなもので、

[06:31 - 06:36]
後でこのパッケージをインストールするために使用します。ここにはいくつかの

[06:33 - 06:38]
例と詳細なドキュメントへのリンクがあり、詳細を確認するために参照

[06:36 - 06:40]
できます。

[06:38 - 06:41]
私が

[06:40 - 06:43]
通常行うことは、un cursorを起動して

[06:41 - 06:45]
ドキュメントを作成し、

[06:43 - 06:47]
この機能の概念実証を試みることです。このドキュメントを

[06:47 - 06:53]
コピーしてcursorに戻り、

[06:49 - 06:56]
cursor composerを開いて「addm

[06:53 - 06:58]
uh doc」と入力します。「add new Doc」をクリックして

[06:56 - 07:00]
リンクを貼り付けます。これで

[06:58 - 07:02]
Snow wrapのドキュメントが追加されます。

[07:00 - 07:04]
確認して、ここで

[07:02 - 07:06]
具体的な指示を与えます。

[07:06 - 07:11]
過去のRIT投稿データから最近のRIT投稿データを含むシンプルなTypescriptファイルを作成するのを手伝ってください。  24時間、

[07:09 - 07:13]
タイトル、コンテンツ、スコア、

[07:11 - 07:14]
コメント数、日付を含む、oramaでsnow rrapを使用して

[07:14 - 07:19]
サンプルスクリプトの作成を開始します。すべてを受け入れることができるように、まず

[07:17 - 07:22]
最初に、

[07:19 - 07:24]
reddit API認証情報を取得する必要があります。Reddit API認証情報を

[07:24 - 07:29]
取得する方法について質問し続けることができますが、

[07:26 - 07:30]
基本的にはreddit.comの設定のSLアプリに移動し、

[07:30 - 07:35]
別のアプリの作成をクリックして

[07:33 - 07:37]
名前を入力します。この場合は、投稿

[07:35 - 07:40]
カテゴライザーを呼び出し、スクリプトの説明を選択します。Reddit

[07:40 - 07:46]
の投稿を分析するアプリを配置します。Urについて。

[07:43 - 07:49]
空のreddit URLのままにしておきます。Local

[07:46 - 07:51]
Host 3000のままにしておきます。「私はロボットではありません」をクリックして

[07:49 - 07:53]
アプリを作成します。これで

[07:51 - 07:54]
認証情報が取得されます。

[07:54 - 07:58]
認証情報とユーザーエージェントを一時的に

[07:56 - 07:59]
置き換えます。クライアントIDはタグになり、

[07:59 - 08:05]
シークレットIDはこれになります。

[08:02 - 08:07]
ここでリフレッシュトークンも要求されます。snow

[08:05 - 08:09]
wrapを覚えておいてください。oosに

[08:07 - 08:11]
はいくつかの異なる方法があります。ユーザー名とパスワードを

[08:09 - 08:13]
使用する簡単な方法を作りたい

[08:11 - 08:15]
ので、

[08:13 - 08:17]
これをコピーして、リフレッシュ

[08:15 - 08:19]
トークンをユーザー名とパスワードに置き換えます。ユーザー名と

[08:17 - 08:22]
パスワードを入力できる場所に、

[08:19 - 08:24]
次に mpm をインストールしたいので、

[08:22 - 08:28]
ターミナルにコマンド ラインをコピーして、

[08:24 - 08:31]
TS node fash RIT post を実行します。  TS わかりました。

[08:31 - 08:35]
実際の投稿データが返されているのがわかります。このコード

[08:34 - 08:38]
例は実際に機能しており、

[08:35 - 08:40]
これをコード例としてコピーして貼り付けることができます。

[08:38 - 08:42]
また、早い段階で調査を行うことで、このプロセス

[08:40 - 08:44]
から潜在的な矢印の別のレイヤーを取り除くことが

[08:44 - 08:48]
できます。そのため、

[08:46 - 08:51]
このコード例をコピーして、手順に戻ります

[08:48 - 08:55]
。  MDと例をここに記入すると、

[08:51 - 08:58]
Snow

[08:55 - 09:01]
Wrapを使用してRITの投稿データを取得する方法がドキュメントに記載されているので、コード

[08:58 - 09:03]
例を記入して貼り付けます。すると、

[09:03 - 09:07]
Redditデータを取得するためにNoRPをライブラリとして使用するという説明も表示されます。

[09:11 - 09:16]
また、Open AIの構造出力を使用してRITの投稿を分類する方法についてもドキュメントに記載されているのと同じことをします。Open AI

[09:13 - 09:19]
ドキュメントに移動し、リンクをコピーして

[09:16 - 09:23]
カーソルを戻し、新しいものを追加してDocを追加し、新しい

[09:19 - 09:25]
ものを貼り付けてOpen AIの構造化出力を

[09:23 - 09:27]
確認します。ここで、RITの投稿を分類するための簡単なTypeScriptの記述方法を説明します。

[09:29 - 09:34]
投稿カテゴリ分析の出力が

[09:31 - 09:35]
あり、bodan値があるはずです。bodanは基本的に、各カテゴリの真偽値のようなものです。

[09:35 - 09:40]
ソリューションリクエストP、怒りのアドバイス

[09:38 - 09:42]
リクエスト、お金の話です。Enterをクリックすると、

[09:40 - 09:44]
簡単なスクリプトが作成されます。

[09:42 - 09:46]
ここに来て、

[09:44 - 09:48]
APIキーを一時的に置き換えます。

[09:46 - 09:50]
ここのコードは実際には

[09:48 - 09:53]
構造出力を使用していないことに気付きました。そこで、

[09:53 - 09:57]
ドキュメントから取得した非常に具体的な例を挙げます。

[09:56 - 09:59]
これが、私がこれを考えるもう一つの理由です。

[09:57 - 10:02]
Advan プランの調査での入力が

[09:59 - 10:05]
必要なので、

[10:02 - 10:08]
カーソルに戻って、

[10:05 - 10:11]
オープン AI 構造化出力

[10:08 - 10:13]
関数を使用するように指定します。上記の例を

[10:11 - 10:15]
リファクタリングされたコードへの参照として使用します。戻ってみると、

[10:17 - 10:23]
モデルが間違っているにもかかわらず、構造出力が使用されていることがわかります。そのため、これを 40 mini に変更します

[10:19 - 10:25]
が、構造が

[10:23 - 10:27]
あまり気に入らないため、いくつか簡単に更新します。

[10:29 - 10:33]
代わりに、実際の Z データ型に説明を入れたいので、この

[10:31 - 10:36]
コード部分を選択して、

[10:33 - 10:38]
カーソル コンポーザーに戻り、

[10:36 - 10:41]
各カテゴリの説明を

[10:38 - 10:42]
プロンプトの一部ではなくゾーン モデル自体に設定すると、

[10:41 - 10:44]
後で

[10:42 - 10:47]
カテゴリが変更された場合に柔軟に対応できます。これで

[10:44 - 10:50]
すべて問題ないはずです。ターミナル mpm

[10:47 - 10:53]
install open および zot を開いて、TS node

[10:50 - 10:56]
categorize post を実行します。  TS わかりました。この矢印を取得しました。

[10:53 - 10:59]
どうやらベータ版はここに追加されていないようです

[10:56 - 11:01]
ので、ドキュメントに従ってベータ版を貼り付けます。

[11:01 - 11:05]
さて、先ほど見つけたもう1つの問題は、

[11:03 - 11:07]
スクリプト型が非常に厳格な戻り値の

[11:05 - 11:08]
型を持っていることです。以前の戻り値の型は、

[11:08 - 11:12]
先ほど定義した結果型などでしたが、

[11:10 - 11:14]
ここで実際に返すものは文字列なので、それを削除して

[11:12 - 11:17]
再度実行できます。これで、

[11:14 - 11:19]
この結果が返されたことがわかります。po playです。これ

[11:17 - 11:23]
も命令に含めることができる例です。Open

[11:23 - 11:28]
AI構造化出力コードの例のドキュメントを追加します。

[11:26 - 11:31]
また、サンプル

[11:28 - 11:34]
出力とサンプル応答を含めることもできます。上部で

[11:31 - 11:37]
Open AI構造出力関数を使用して更新します。

[11:34 - 11:38]
これは

[11:37 - 11:40]
初期ドラフトのCrocとほぼ同じです。最後に、

[11:40 - 11:45]
現在のファイル構造を含めます。そのためには、

[11:42 - 11:47]
まずプロジェクトをセットアップする必要があります。

[11:45 - 11:49]
プロジェクトをセットアップするには、chassに移動します。

[11:47 - 11:52]
非常に優れたコマンドラインがあります。npx chass inを押して

[11:49 - 11:54]
最新の初期値を入力すると、

[11:54 - 12:00]
新しいnextjsプロジェクトを作成するかどうかを尋ねられます。Yをクリックして、

[11:57 - 12:03]
RedditとAnticsという名前を付けます。

[12:00 - 12:05]
ニューヨークスタイルのナチュラルを選択します。

[12:03 - 12:06]
はい、これでプロジェクトがすべて公開

[12:05 - 12:08]
されたので、

[12:06 - 12:11]
プロジェクトフォルダが作成されました。

[12:08 - 12:13]
私がやりたいことは、

[12:11 - 12:16]
まずこのプロジェクトフォルダ内に「instructions」というフォルダを作成し、

[12:16 - 12:21]
この「instruction MD」をそのフォルダの下に移動します。

[12:18 - 12:23]
そして、「cursor Reddit

[12:21 - 12:25]
analytics」を実行します。これでカーソルがその特定のフォルダで開きます。

[12:25 - 12:30]
このカーソルコマンドラインがまだない場合は、

[12:27 - 12:32]
コマンド+Shift+Pを押してから、この

[12:30 - 12:33]
シェルコマンド「install cursor command」を選択します。それ

[12:32 - 12:35]
以外の場合は、

[12:33 - 12:38]
ここから特定のフォルダを開くことができます。今は

[12:35 - 12:39]
特定のプロジェクトフォルダに移動して、

[12:39 - 12:42]
先ほど作成した「instruction」を開きます。まず、必要な

[12:41 - 12:44]
パッケージをいくつかインストールします。mpm

[12:42 - 12:47]
install snow

[12:44 - 12:50]
wrap、open Ai and zです。次に、「

[12:47 - 12:51]
EMV do loal」という新しいファイルを作成し、そこに

[12:50 - 12:55]
すべての認証情報を追加します。

[12:51 - 12:57]
また、最新のアプリでMPX chassiを実行します。

[12:55 - 12:59]
デフォルトでは、

[12:57 - 13:01]
chass in oneのコンポーネントが

[12:59 - 13:03]
自動的に追加されるので、

[13:03 - 13:10]
必要なコンポーネントを手動で選択します。 バッジカード

[13:05 - 13:11]
入力ラベルシートテーブルタブとEnterキーを押します。

[13:10 - 13:14]
コンポーネントが

[13:11 - 13:16]
追加されているのが確認できます。次に、現在のファイル構造を追加する必要があります。

[13:14 - 13:19]
まず、

[13:16 - 13:21]
Brew install tr​​eesを実行します。これは、現在のファイル構造

[13:19 - 13:23]
のスナップショットを取得するライブラリです。tree

[13:21 - 13:25]
だけを実行すると、

[13:23 - 13:26]
ファイル構造全体が返されますが、これは

[13:26 - 13:31]
必要なものではありません。代わりにtree-Lを実行します。これは、

[13:29 - 13:33]
2階層

[13:31 - 13:34]
下に移動します。これで十分です。次に-Iを実行します。これは

[13:33 - 13:37]
無視することを意味します。

[13:34 - 13:40]
ノードモジュールファイルは含めません。

[13:37 - 13:43]
これで、クリーンなファイル構造が表示されます。

[13:40 - 13:45]
これをReddit Analyticsにコピーし、

[13:43 - 13:47]
このファイルを貼り付けて、

[13:45 - 13:49]
既存のプロジェクトフォルダがどの

[13:47 - 13:52]
ようになっているかを示します。これで、

[13:52 - 13:55]
製品要件のかなり適切な開始点ができました。ただし、これでは

[13:53 - 13:57]
カーソルが表示されず、矢印が

[13:55 - 13:59]
少なくなるにつれて非常に良い結果が得られます。

[13:57 - 14:03]
実際には、初期

[13:59 - 14:05]
PRDを01モデルまたはクラウドに渡して、

[14:03 - 14:06]
最終的なPur構造がどのようになるか、

[14:05 - 14:09]
どのような依存関係Zに

[14:06 - 14:12]
なるかを設計し、最終的なPRDを書き出して、

[14:09 - 14:14]
すべての詳細を入力します。個人的に01を見つけました。

[14:14 - 14:18]
詳細なドックの作成と入力が非常に優れています。通常、

[14:15 - 14:20]
既存の Pro 要件ファイルをコピーして

[14:18 - 14:22]
ここに貼り付け、下部に追加します。

[14:20 - 14:24]
その上に構築したいプロジェクトを追加します。

[14:22 - 14:27]
プロジェクト ファイルの構造をどのように構成すればよいでしょうか。

[14:24 - 14:29]
できるだけファイルを少なくするようにしてください。

[14:27 - 14:31]
ファイルが少ないとカーソルの

[14:29 - 14:33]
矢印が少なくなる傾向があるためです。Enter

[14:31 - 14:35]
キーをクリックすると、O モデルが

[14:33 - 14:38]
いくつかの異なる手順で同期を開始し、

[14:38 - 14:42]
要件に基づいてプロジェクト構造ファイルが出力されます。

[14:40 - 14:44]
その後、2 番目のステップとして、

[14:44 - 14:48]
元の PRD に詳細を追加して、このプロジェクトを実装する開発者に明確な整合性を持たせます。

[14:48 - 14:52]
そのため、実際のコードは作成せず、ドキュメント

[14:50 - 14:55]
内のファイル構造を含む PRD のみを作成します。

[14:52 - 14:56]
すべてのドキュメントには

[14:55 - 14:59]
サンプル コードと応答の両方が含まれています。これらは

[14:56 - 15:00]
重要なコンテキストです。もう一度 Enter キーをクリックします。O1

[14:59 - 15:03]
モデルがいくつかの異なる手順を開始し、

[15:03 - 15:07]
このプロジェクトの作成方法に関する非常に詳細な手順

[15:05 - 15:09]
と、

[15:07 - 15:12]
更新された Pera 構造とコード

[15:09 - 15:14]
例を出力します。最後に、

[15:12 - 15:16]
さまざまなコンポーネントの非常に詳細な内訳が示されます。

[15:14 - 15:18]
わかりました。これは本当に

[15:16 - 15:20]
優れた製品要件ドキュメントです。

[15:18 - 15:22]
唯一の欠点は、コピーして貼り付けることができないことです。

[15:20 - 15:24]
これはマークダウン形式ではないため、

[15:22 - 15:27]
通常は

[15:24 - 15:30]
クラウドに移動してこれを貼り付けてから、「

[15:27 - 15:32]
これをマークダウンに変換するのを手伝ってください」と言うと、クラウドは

[15:30 - 15:35]
それを特定のマークダウン ファイルに分解し、それをコピーして貼り付けることができるようになります。

[15:35 - 15:41]
変換が完了したら、これをコピーし

[15:37 - 15:43]
て手順に貼り付けるだけです。  MD を保存すれば、

[15:41 - 15:45]
カーソルの位置が

[15:43 - 15:48]
かなり調整されるはずです。これで

[15:48 - 15:52]
カーソル WAN を取得する準備がほぼ整ったと思います。最後に、

[15:50 - 15:54]
AEMV ローカルファイルを作成し、

[15:52 - 15:56]
Reddit と Open AI の認証情報を

[15:54 - 15:58]
ここに入力します。これでカーソルを取得して

[15:56 - 16:00]
このプロジェクトの実装を開始できますが、

[15:58 - 16:03]
終了する前に、

[16:03 - 16:07]
AI を活用して完全な本番

[16:05 - 16:09]
環境対応アプリケーションを構築するためのより詳細なチュートリアルを求める多くの DMS を受け取ったため、

[16:07 - 16:11]
AI Builder Club というコミュニティを立ち上げました。このコミュニティでは、AI を活用して次のスタートアップのアイデアを実現する方法に関する詳細なコンテンツを

[16:11 - 16:16]
毎週追加することに多くの時間を費やしています。

[16:16 - 16:20]
このコンテンツには、AI を使った実際のユースケースの

[16:18 - 16:23]
構築方法のステップバイステップのチュートリアルが含まれており、

[16:23 - 16:27]
ベストプラクティスのプロンプトと、

[16:24 - 16:29]
私がすべてのプロジェクトで使用しているコード例を共有しています。

[16:27 - 16:30]
コピー アンド ペーストでプラグ アンド プレイできるケース

[16:29 - 16:32]
や、構築可能な

[16:30 - 16:34]
一般的なエージェントのすぐに使用できるテンプレートも用意されています。

[16:32 - 16:37]
そして最も重要なのは、

[16:38 - 16:42]
コミュニティで直面している課題や質問を投稿できることです。私や他のコミュニティ メンバーが

[16:40 - 16:44]
通常は参加して回答します。

[16:42 - 16:46]
また、他の AI ビルダーが提供している秘密のヒントもご覧いただけます。

[16:44 - 16:48]
コミュニティが試して

[16:46 - 16:49]
うまくいきました。これが興味深いと思われる場合は、

[16:49 - 16:53]
以下の説明のリンクをクリックして参加できます。

[16:51 - 16:55]
これで、完全にフラッシュアウトされたドキュメントを

[16:53 - 16:58]
使用して、curser を使用してこのアプリケーションを構築できるようになります。コマンドを実行します。Cursor

[16:58 - 17:02]
Composer を開いて指示を与えましょう。

[17:02 - 17:07]
指示に基づいて RIT 分析プラットフォームを構築しましょう。

[17:04 - 17:10]
まず、1.1 をビルドして、利用可能な

[17:07 - 17:13]
サブレディットを表示します。

[17:10 - 17:16]
適切な場所にファイルが作成されるので、[

[17:13 - 17:19]
Accept] をクリックします。mpm

[17:16 - 17:22]
wrong dep を実行してこれを実行してみます。これで、利用

[17:24 - 17:31]
可能なすべてのサブ Rus がリストされているホームページがすでに作成されていることがわかります。次に、1.2 をビルドして

[17:28 - 17:33]
新しいサブ Rus を追加します。コンポーネントの下に新しいコンポーネントを作成します。add

[17:31 - 17:35]
sarus model という

[17:47 - 17:52]
名前です。また、これらの新しいコンポーネントを追加するように求められます。すでに追加したと思いますが、ダイアログを追加していないようです。npx chass と最新の追加ダイアログを実行します。ローカルホスト 3000 に戻ると、subreddit という新しいボタンが表示されます。

[17:50 - 17:54]
それをクリックすると、UIが少し

[17:52 - 17:55]
壊れているのがわかりますが、

[17:54 - 17:57]
後でUIに戻ります。まず、

[17:55 - 17:59]
すべてが機能することを確認したいので、

[17:57 - 18:01]
サブを追加する機能は

[17:59 - 18:03]
備わっているようです。次に、

[18:01 - 18:08]
サブレディットの詳細ページの

[18:03 - 18:11]
ナビゲーションに進みましょう。サブレディットの詳細ページのナビゲーションの次の部分を見てみましょう。

[18:11 - 18:16]
基本的には、事前

[18:13 - 18:18]
定義された構造に基づいてページとファイルが作成されます。

[18:16 - 18:20]
ローカルホストに戻って

[18:18 - 18:23]
特定のRedditページをクリックすると、

[18:20 - 18:25]
その特定のサイドページに移動します。次に、

[18:25 - 18:30]
タブを追加する2番目の部分に移動するように求められます。それでは、次の部分を構築してみましょう。

[18:32 - 18:36]
このように、事前定義された製品要件ドキュメントの優れた点がわかります。

[18:34 - 18:38]
基本的に、タスクを

[18:36 - 18:41]
カーソルがうまく移動できる小さなステップに分割します。

[18:38 - 18:43]
すべてを受け入れます。

[18:41 - 18:46]
アプリに戻ってこれをクリックすると、

[18:43 - 18:48]
ここにも2つのタブが開きます。ここでも

[18:46 - 18:50]
UIは無視して

[18:48 - 18:53]
機能を完了します。それでは、

[18:50 - 18:57]
指示を示します。それでは、

[18:53 - 18:59]
ファッションRIT投稿3.1データを構築しましょう。

[18:57 - 19:01]
取得なので、いくつかの異なるファイルが作成されます。

[19:01 - 19:06]
すべて受け入れをクリックしてページを更新します。ここで、

[19:06 - 19:11]
モジュールに関していくつかの矢印があるように見えます。

[19:08 - 19:15]
矢印をカーソルに貼り付けて、

[19:11 - 19:18]
この矢印を解決するのに役立ちます。

[19:15 - 19:19]
この2つのライブラリをインストールする必要があるかもしれません。

[19:18 - 19:22]
または、別のターミナルに移動して

[19:19 - 19:25]
インストールし、すべて受け入れます。これで

[19:22 - 19:29]
投稿を表示できます。素晴らしいです。

[19:25 - 19:31]
では、3.2をビルドし

[19:29 - 19:33]
ましょう。コンテンツが表示されていないように見えるので、

[19:31 - 19:36]
戻ります。投稿の

[19:33 - 19:38]
読み込みがUIに短時間表示されます

[19:36 - 19:40]
が、その後消え、

[19:38 - 19:41]
インターフェイスに投稿が表示されません。

[19:40 - 19:44]
ルートコストLingの手順を

[19:41 - 19:46]
段階的に説明します。まず、ログインをいくつか追加するか、

[19:44 - 19:48]
これを受け入れるかを試してください。投稿が

[19:46 - 19:51]
ありませんFと表示されているようですが、

[19:48 - 19:54]
奇妙です。私の推測では、APIが

[19:51 - 19:58]
正しく設定されていない可能性があります。

[19:54 - 20:01]
ライブラリrdit dotsにアクセスしてフィードバックを提供できます。

[19:58 - 20:05]
投稿が見つかりませんCUこれは、

[20:01 - 20:07]
Reddit dotsが正しく設定されていないためです。

[20:05 - 20:10]
問題は

[20:07 - 20:12]
クライアント側とサーバー側の違いのようです。

[20:10 - 20:15]
rdtsファイルはサーバー側で実行されました

[20:12 - 20:17]
が、separ r tabsコンポーネントは

[20:15 - 20:20]
クライアント側コンポーネントです。そのため、

[20:17 - 20:22]
サーバー

[20:20 - 20:24]
側APIからクライアント側コンポーネントへのデータフローを取得するには、

[20:22 - 20:26]
この観察結果に基づいて、

[20:24 - 20:27]
潜在的なルートコストとして、クライアントと

[20:26 - 20:29]
コンポーネントが

[20:27 - 20:32]
サービス側APIを直接呼び出すことができない可能性があることを考慮します。そのため、

[20:29 - 20:34]
ここでの解決策は、投稿を取得するための新しいAPIルートを作成することです。

[20:32 - 20:36]
これですべての投稿が

[20:34 - 20:38]
更新されました。ここで行うことは、

[20:36 - 20:43]
すぐにここに来てコミットを

[20:38 - 20:46]
送信し、プロジェクトを設定し、

[20:43 - 20:48]
redit投稿コミットを取得することです。カーソルコンポーザーに戻ります。

[20:46 - 20:51]
これは

[20:48 - 20:54]
RIT投稿です。次に、指示に従って

[20:51 - 20:56]
4.1投稿カテゴリを構築します。

[20:54 - 20:59]
すべてを受け入れて

[20:56 - 21:01]
このページに戻ります。更新します。

[20:59 - 21:04]
矢印のように見えます。

[21:01 - 21:06]
この矢印をコピーしてコンポーザーに追加します。

[21:04 - 21:09]
ルートコストを特定してこの問題を解決するのに役立ちます。

[21:06 - 21:12]
ステップバイステップで進めていきましょ

[21:09 - 21:14]
う。すべてを受け入れます。次は

[21:12 - 21:16]
カテゴリも表示したいので、

[21:14 - 21:18]
これを実装しましょう。4.2

[21:16 - 21:19]
カテゴリの表示です。これは1つの問題のように見えます。

[21:18 - 21:22]
実際の

[21:19 - 21:24]
分類が表示されていないので、

[21:22 - 21:27]
カーソルを戻して、

[21:24 - 21:29]
投稿を分類してポイントする指示を返します。

[21:27 - 21:32]
実際に機能しています。Reddits

[21:29 - 21:34]
に戻ると、

[21:34 - 21:39]
Open AIのエンドポイントが

[21:37 - 21:41]
指示に記載されている内容と異なることが再度確認できます。そのため、

[21:39 - 21:43]
より具体的にする必要があります。

[21:41 - 21:46]
指示に戻って、コード例をコピーして貼り付ける

[21:43 - 21:49]
か、最初にすべてを受け入れてから、Reddit TSを追加します。

[21:46 - 21:50]
分類された

[21:49 - 21:52]
投稿機能が正しく実装されていません。

[21:52 - 21:55]
この指示ファイルで提供したドキュメントに基づく必要があります。

[21:55 - 22:01]
コードをリファクタリングしてすべてを受け入れるようにし、

[21:57 - 22:02]
このモデルを4つのミニに変更したいのですが、

[22:01 - 22:04]
まだいくつか奇妙な部分が見られます。

[22:02 - 22:07]
何らかの理由で、

[22:04 - 22:09]
ベータ版などの特定の部分が無視され続けるため、

[22:07 - 22:12]
手動でコピーして貼り付ける必要があります。わかりまし

[22:09 - 22:14]
た。

[22:14 - 22:19]
投稿ごとにカテゴリが適切に表示されていることがわかります。SSに移動すると、

[22:17 - 22:21]
各カードをクリックすると、

[22:19 - 22:23]
関連する投稿がここに表示されます。

[22:21 - 22:27]
すばらしいです。もう一度コミットを追加して追加します。

[22:23 - 22:28]
投稿を分類する準備ができました。

[22:27 - 22:31]
コア機能が

[22:28 - 22:33]
実装されているのがわかります。トップの投稿を確認できます。

[22:31 - 22:35]
また、

[22:33 - 22:37]
特定のカテゴリで投稿を分類することもできます。しかし、

[22:35 - 22:39]
大規模なLモデルベースのアプリケーションを立ち上げる人にとっては、

[22:42 - 22:46]
大規模なLモデルの使用状況をどのように監視してアラートを出すか、そして

[22:45 - 22:48]
コスト構造を最適化するかどうかという新たな問題があります。これは、

[22:48 - 22:51]
ビジネスの成功を左右する可能性があります。

[22:49 - 22:53]
一例を挙げましょう。数か月前に

[22:51 - 22:56]
AIガールフレンドを立ち上げたのですが、当時は

[22:56 - 23:00]
ユーザーごとに60秒間の無料トライチャットを提供していました。多くの人がサインアップしました

[22:58 - 23:02]
が、どういうわけか収益は得られませんでした。そこで、コスト構造を理解するために

[23:00 - 23:03]
手動で一連のトラッキングを実装しました。

[23:03 - 23:08]
その後、

[23:05 - 23:10]
60秒間の無料トライチャットで、

[23:08 - 23:12]
全ユーザーの1%のコンバージョン率を達成するには、

[23:10 - 23:14]
各ユーザーから少なくとも13ドルを請求する必要があることに気付き

[23:12 - 23:16]
ました。つまり、

[23:14 - 23:18]
パフォーマンスコストと速度のバランスが重要です。

[23:16 - 23:19]
このRadit Analyticsプラットフォームでも同じことが言えます。

[23:21 - 23:25]
これらのカテゴリをまとめた大規模なLear mod呼び出しごとにどれくらいのコストがかかるか

[23:23 - 23:27]
、通常投稿数はどれくらいかを把握する必要があります。

[23:25 - 23:28]
1 つの別の Addus の下に、

[23:27 - 23:30]
そのため通常は Hadon のような

[23:28 - 23:33]
大規模な LAR モデル観測プラットフォームへの統合を最優先に設定していました。Hadon

[23:33 - 23:36]
について聞いたことがない場合、

[23:34 - 23:39]
Haacon は LAR モデル アプリケーションのログ記録、監視、デバッグを行うオープンソース プラットフォームです。これにより、

[23:44 - 23:48]
大規模な LAR モデル アプリケーションに対するユーザーの操作を正確に把握し、

[23:46 - 23:50]
コスト矢印とレイテンシを追跡してパフォーマンスを

[23:48 - 23:52]
最適化できるように

[24:06 - 24:10]
なります。また、プロンプトが同じ場合に応答を自動的にキャッシュしてコストを節約し、速度を向上させたり、顧客プロパティを送信してさまざまな種類のリクエストをセグメント化したりするなど、非常に高度で興味深いことを多数実行できます。最良の部分はセットアップが非常に簡単なことです。

[24:08 - 24:13]
私のようにオープン AI モデルを呼び出す場合、

[24:10 - 24:15]
このベース URL と

[24:13 - 24:16]
オープン AI クライアントからの追加ヘッダーを追加するだけで済みます。

[24:15 - 24:19]
これでほぼ完了です。

[24:16 - 24:21]
これをコピーしてカーソルを戻して

[24:19 - 24:23]
rit を開くだけです。  TS は Open AI 呼び出しを作成し、

[24:21 - 24:25]
これを貼り付けて、この環境変数を直接追加する場所です。これで

[24:25 - 24:30]
ほぼ完了です。RIT

[24:27 - 24:31]
プラットフォームにアクセスして、この応答を受け取った後にサブレディットを開くと、

[24:34 - 24:38]
その特定のサブレディットに対して 200 件の lar mod リクエストが行われたことが自動的に追跡されます。これは、

[24:38 - 24:43]
約 200 件の投稿が処理されたことを意味します。これらのリクエストは、

[24:40 - 24:45]
オーストラリアを拠点とする同じユーザー (つまり私) からのものであり、

[24:43 - 24:47]
合計コストは約 1 セントです。つまり、

[24:47 - 24:53]
かなり人気のある新しいサブ Rus をオンボードするコストは、

[24:50 - 24:55]
GPD 40 モデルを使用して約 1 セントであることがわかります。

[24:53 - 24:58]
リクエストにアクセスして、すべてのリクエストの詳細

[24:55 - 25:00]
と、

[24:58 - 25:02]
Open AI に送信する実際のプロンプトを確認

[25:00 - 25:04]
できます。すぐにプロンプ​​トの問題を見つけることができます。

[25:02 - 25:06]
たとえば、現在の構造では

[25:06 - 25:10]
実際の投稿コンテンツがあまり明確ではありません。一部の

[25:08 - 25:13]
コンテンツがプロンプトの一部のように見えるため、

[25:10 - 25:14]
lary モデルが混乱する可能性があります。

[25:14 - 25:18]
ここでプロンプトを更新して保存することで、すぐにパフォーマンスを改善できます。ただし、

[25:16 - 25:20]
その一方で、異なるプロンプトを直接試すことができる URI もあります。

[25:20 - 25:23]
また、

[25:22 - 25:25]
異なるモデルを切り替え、各データを

[25:23 - 25:27]
レビューしながら、これを「

[25:25 - 25:29]
bad sessions」というデータセットに追加できます。これにより、

[25:29 - 25:34]
新しいモデルを評価したり、

[25:32 - 25:36]
モデルをプライまたはFチュ​​ーニングしたりするために使用できるデータセットを作成できます。L

[25:34 - 25:37]
モード

[25:36 - 25:39]
アプリケーションをこれらのログと

[25:37 - 25:41]
モーニングプラットフォームでセットアップすることを強くお勧めします。Headonは最高のプラットフォームの1つです。Headonを

[25:43 - 25:46]
無料で試すためのリンクを以下の説明に貼っておきます。Heliconに接続した後、

[25:45 - 25:48]
次に

[25:46 - 25:50]
バックエンドをセットアップして、

[25:50 - 25:55]
このRIT分析プラットフォームのコア機能を実装します。ただし、現時点で面倒なのは、

[25:53 - 25:57]
誰かが

[25:55 - 26:00]
このサブページをクリックするたびにすべての投稿が更新され、

[26:00 - 26:05]
Open AIを介して投稿を分析および分類することです。

[26:02 - 26:07]
これは最適ではなく、

[26:05 - 26:09]
コストがかかります。そこで、IDEで実現したいのは、

[26:07 - 26:10]
誰かがページを開いて初めてデータを取得したときに、

[26:10 - 26:15]
このデータをデータベースに保存することです。そうすれば、

[26:13 - 26:17]
次に誰かがこのページを開いたときに、

[26:17 - 26:22]
Redditからデータが最後に見つかったのはいつかを確認できます。

[26:19 - 26:24]
24時間以内に更新しないようにしましょう。その

[26:22 - 26:26]
ためには、カーソルに

[26:24 - 26:27]
新しい機能を実装して

[26:26 - 26:29]
データをどこかに保存する必要があります。

[26:27 - 26:31]
これは、既存のPuresに新しい機能を追加する方法を示す優れた例なので、これを紹介したいと思います。

[26:33 - 26:38]
そのためには、カーソルを開いてプロジェクト

[26:36 - 26:40]
全体を実装するように指示するのではなく、

[26:38 - 26:43]
サイド

[26:40 - 26:45]
パネルを開いてコードベースを追加します。これは非常に

[26:43 - 26:47]
強力な機能で、カーソルは実際に

[26:45 - 26:49]
コードベース全体を参照でき、含める

[26:47 - 26:51]
ファイルと除外するファイルを指定できます。

[26:49 - 26:53]
たとえば、

[26:51 - 26:56]
Node.jsのモジュール

[26:53 - 26:57]
フォルダは不要なので、Node.jsのモジュールフォルダを配置します。ちなみに、

[26:57 - 27:00]
フォルダ名を配置しても機能するかどうかはわかりませんが、

[26:59 - 27:02]
ここに配置します。

[27:00 - 27:04]
答えがわかったら、以下にコメントしてください。

[27:02 - 27:07]
詳細な手順を記載します。

[27:04 - 27:09]
このプロジェクトは元の手順に基づいて構築されています

[27:07 - 27:11]
が、現在、

[27:11 - 27:16]
誰かがsubrページを開くたびにRデータを取得してOpen APIを呼び出す必要がありますが、これは

[27:13 - 27:18]
最適ではありません。

[27:16 - 27:20]
バックエンドエンジニアにSuper Baseに接続して、

[27:18 - 27:22]
RITの投稿データとAI

[27:20 - 27:25]
分析データをSuper Baseに保存してもらいたいと思っています。

[27:22 - 27:27]
最終更新時刻が 24 時間前より古い場合はデータを取得します。

[27:27 - 27:31]
バックエンドと

[27:29 - 27:33]
開発者がこのプロジェクト構造を理解するのに役立つ詳細なストックを生成できます。

[27:35 - 27:39]
現在のプロジェクト構造と互換性のあるスーパーベース統合用に構築するクールなパーツは何ですか?

[27:37 - 27:41]
実際のコード例を含める必要はありません。

[27:39 - 27:43]
設計のみを行います。ちなみに、スーパーベースがわからない場合は、

[27:41 - 27:45]
スーパーベースは

[27:45 - 27:49]
モバイル アプリケーションと Web アプリケーションの両方に完全なバックエンドを提供するオープンソース プロジェクトです。2020

[27:49 - 27:54]
年に導入され、非常に

[27:52 - 27:55]
急速に人気を博しました。スーパーベースが登場する前は、バックエンドを

[27:54 - 27:58]
構築するための 2 つのオプションがありました。1

[27:55 - 28:00]
つは Firebase、もう 1 つは WS

[27:58 - 28:02]
Amplify です。どちらも問題なく動作しますが、

[28:00 - 28:05]
問題は

[28:02 - 28:07]
特定のベンダーにロックインされてしまうことです。これは最適ではありません。その

[28:07 - 28:10]
ため、スーパーベースは急速に成長しています。バックハンドを構築して

[28:08 - 28:12]
好きな場所にホストできるためです。また、

[28:12 - 28:17]
データベース認証ストレージや

[28:15 - 28:19]
Vector ストレージ用の完全なバックハンド サービスも提供され、フロントエンドと

[28:17 - 28:21]
SDK が提供され、バックエンドに簡単に接続できます。

[28:21 - 28:25]
これまでにバックエンド機能をまったく構築したことがない場合は

[28:24 - 28:28]
驚くかもしれませんが、実際には

[28:25 - 28:29]
思ったよりも簡単です。本当に必要なのは、

[28:28 - 28:32]
実際に保存する必要があるデータの種類を定義することです。

[28:29 - 28:33]
アプリケーションについて、

[28:32 - 28:35]
たとえば、私たちの場合、ユーザーを追跡できる

[28:33 - 28:38]
ように、常にプロファイル用のテーブルが必要になるでしょう。

[28:38 - 28:42]
価格

[28:40 - 28:44]
帯、残っているクレジット数を追跡​​するためにティアなどを追加したり、

[28:42 - 28:45]
顧客IDとサブスクリプションIDを削除したりすることもできます。

[28:44 - 28:48]
支払いを

[28:45 - 28:50]
プラットフォームとサブラタスに組み込んでいる場合は、

[28:48 - 28:52]
さまざまなスバルのリスト、

[28:50 - 28:53]
最終更新時刻、

[28:52 - 28:56]
投稿リストを追跡します。各投稿の

[28:53 - 28:58]
タイトルコンテンツスコアとカテゴリのリストを追跡します。

[28:56 - 28:59]
基本的に、これらはスプレッドシートと考えることができます。必要

[28:59 - 29:03]
なシートの種類と

[29:01 - 29:05]
各シートに必要な列の種類ですが、必要な特定の列がわからない場合は、

[29:05 - 29:09]
心配しないでください。AIに調べてもらうことができます。

[29:07 - 29:11]
カーソルに戻って、

[29:09 - 29:13]
まず

[29:11 - 29:15]
ターミナルを開いてファイル構造を取得します。

[29:13 - 29:18]
同じコマンドを使用しますが、今回は

[29:15 - 29:20]
3層の深さを使用します。これにより、

[29:18 - 29:22]
最新のファイル構造が得られます。

[29:20 - 29:24]
これをコピーして、

[29:24 - 29:29]
指示に進みます。  MD を実行して、ここでファイル構造を更新し、

[29:29 - 29:33]
これを右側の指示にコピーして

[29:31 - 29:35]
指示を与えます。

[29:33 - 29:38]
指示に基づいてプロジェクトが構築されます。

[29:35 - 29:41]
MDですが、現在はレッドデータを高速化して

[29:38 - 29:43]
毎回オープンAPIを呼び出す必要がありますが、これは

[29:41 - 29:45]
最適ではありません。バックエンドエンジニアが

[29:43 - 29:47]
スーパーベースに接続して、

[29:45 - 29:50]
分離された各データをスーパーベースに保存し、

[29:47 - 29:52]
最後の更新時間が

[29:50 - 29:54]
24時間前より古い場合にのみデータを取得できるようにし

[30:07 - 30:12]
たいと考えています。詳細なドキュメントを生成できるようにすることで、バックエンド開発者がプロ​​ジェクト構造を理解するのに役立ちます。現在のプロジェクト構造と互換性のある、素晴らしいスーパーベースの統合、作成するデータベース、最適なスキーマがどのようになるかについて説明します。ステップごとに同期してみましょう。

[30:09 - 30:15]
ここでは01プレビューモデルを直接使用して、

[30:12 - 30:17]
Enterをクリックします。これで、

[30:17 - 30:22]
現在のデータのFL方法について説明した非常に詳細なドキュメントが返されます。

[30:20 - 30:25]
また、実際のデータベーススキーマ

[30:22 - 30:27]
設計とデータファッションロジック、および

[30:25 - 30:29]
詳細な手順も表示されます。これは非常に優れています。次は、

[30:27 - 30:31]
これを

[30:29 - 30:33]
マークダウンファイルに変換して、

[30:31 - 30:35]
カーソルを参照できるようにします。

[30:33 - 30:39]
ホストのものをコピーして貼り付け、カーソルに移動して、

[30:35 - 30:42]
これを適切なマークダウン形式に変換します。わかりました。

[30:42 - 30:48]
これをコピーして、指示フォルダーに移動し

[30:45 - 30:51]
、スーパーベースセットアップという新しいフォルダーを作成します

[30:48 - 30:53]
。  MD はこれを貼り付けますが、

[30:53 - 30:58]
ファイル構造という 1 つの部分を更新する必要があります。

[30:55 - 31:00]
最新のファイル構造をここにコピーして保存します。

[30:58 - 31:01]
カーソルに入る前に、

[31:00 - 31:04]
いくつかの手順を実行する必要があります。まず、

[31:01 - 31:07]
スーパー ベースのクライアント ライブラリをインストールする必要があります。ターミナルを開いて

[31:04 - 31:09]
貼り付けます。

[31:07 - 31:11]
次に、カーソル コンポーザーの使用を開始できます。

[31:09 - 31:16]
カーソル コンポーザーを開いて、

[31:19 - 31:26]
ここのスーパー ベースの指示に基づいて、この現在のプロジェクトにスーパー ベースの統合を実装する必要があると言います。

[31:23 - 31:27]
まず、クライアントを初期化するための St なので、すべてを受け入れるように入力します。

[31:26 - 31:30]
次に、

[31:27 - 31:33]
env に資格情報を追加する必要があります。

[31:30 - 31:35]
そのためには、

[31:33 - 31:37]
まずSuperbaseプロジェクトを設定する必要があります。Superbase

[31:35 - 31:39]
に移動して新しい

[31:37 - 31:43]
プロジェクトを作成します。名前とAnalyticsを編集して

[31:43 - 31:48]
パスワードを入力します。プロジェクトを

[31:45 - 31:51]
作成したら、プロジェクト

[31:48 - 31:53]
設定とAPIに進みます。ここで

[31:51 - 31:55]
必要な認証情報を取得します。1つはURL、もう

[31:53 - 31:57]
1つはサービス行の認証情報です。

[31:55 - 31:59]
その後、2つのデータベーステーブルも作成する必要があります。これを

[31:59 - 32:03]
行うには2つの方法があります。1つは

[32:01 - 32:05]
テーブルエディタに移動して新しいテーブルを作成する方法です。テーブル

[32:03 - 32:07]
名を入力し

[32:05 - 32:09]
、指示に基づいて列を追加するだけです。もう1つは

[32:09 - 32:16]
クラウドに移動して指示を与え、

[32:16 - 32:22]
Superbaseのすべてのテーブルを直接作成するSQLコマンドを指定します。すると、

[32:19 - 32:25]
このSQLコードが表示されます。これをコピーして

[32:22 - 32:27]
SQLエディタに移動し、貼り付けて実行します。

[32:25 - 32:29]
実行後、

[32:27 - 32:31]
テーブルに移動できます。指示に従って、すべてのテーブルが既に作成されているはずです。

[32:31 - 32:35]
指示グリッドを示します。Superbase

[32:33 - 32:37]
プロジェクトテーブルを設定し

[32:35 - 32:39]
、環境変数を追加しました。

[32:37 - 32:42]
次のステップでは、Superbaseクライアントを初期化して

[32:39 - 32:44]
変更します。 データファッションロジックです。

[32:42 - 32:47]
特定の

[32:44 - 32:49]
部分をここにもコピーして貼り付け、Enterをクリックします。[

[32:47 - 32:54]
すべて受け入れる]をクリックして、

[32:49 - 32:57]
ステップ6を実行しましょう。PRを更新して

[32:54 - 33:00]
すべて受け入れます。次のステップでは、

[32:57 - 33:03]
データフローをテストしましょう。

[33:00 - 33:08]
いくつか矢印が表示されています。これらの矢印を過ぎると、

[33:03 - 33:10]
サブページを読み込んだ後にこの矢印が表示され、

[33:08 - 33:12]
すべて受け入れます。ログをありがとうございます。Reddit

[33:12 - 33:16]
からデータを正常にフラッシュしたことはわかりますが、

[33:14 - 33:19]
矢印は実際にデータをアップサートしているため、アドバイスリクエストが見つかりませんでしたと表示されます。

[33:23 - 33:27]
ドキュメントに含まれているにもかかわらず、おそらく間違ったスキームを参照していると思われます。今回は

[33:25 - 33:29]
より具体的に、実際の特定の

[33:27 - 33:34]
スキームをコピーして貼り付け、この矢印をコピーして貼り付けます。この

[33:29 - 33:39]
矢印は、スーパー

[33:34 - 33:42]
ベースへのデータのプッシュに失敗したようです。実際のサブレッドを参照してください。

[33:42 - 33:49]
スーパーベースで設定した実際のテーブルとスキーマについては、

[33:46 - 33:51]
ステップごとに考えてみましょう。はい、これを保存して、

[33:49 - 33:55]
再度更新すると別の矢印が表示されます。TSを

[33:55 - 34:02]
更新した後、この矢印をコピーして貼り付けます。[受け入れ]をクリックすると、

[34:02 - 34:07]
スーパーベースに関連する別の矢印が表示されます。コピーします。 貼り付けて

[34:05 - 34:10]
Enterキーを押すと、重複キーの

[34:07 - 34:12]
矢印とカテゴリが定義されていないと表示されます。

[34:10 - 34:15]
これらを修正しています。

[34:12 - 34:18]
投稿が読み込まれたことがわかります。投稿が

[34:15 - 34:22]
作成され、サブカテゴリも

[34:18 - 34:24]
読み込まれ、投稿カテゴリも読み込まれています。

[34:22 - 34:27]
ただし、矢印は表示されます。

[34:24 - 34:30]
問題は、何らかの理由で

[34:27 - 34:32]
データが2回Fになっているように見えることです。

[34:30 - 34:34]
カーソルに戻って、これをコピーして貼り付けます。

[34:32 - 34:36]
すべてが機能しているようです。

[34:34 - 34:38]
データがスーパーベースに立っているのを確認できます。唯一の

[34:36 - 34:41]
問題は、

[34:38 - 34:43]
最初のフェッチが成功した後、何らかの理由でデータを2回フェッチしているようです。

[34:41 - 34:45]
この文字の矢印は、

[34:43 - 34:48]
ルートコストと思われるものを貼り付けました。わかりました。これで、

[34:45 - 34:51]
データがフロントエンドにポップロードされているのを確認できます。

[34:48 - 34:54]
このページを終了してもう一度アクセスすると、

[34:54 - 34:58]
データの読み取りがスーパーベースからであるため、データの読み込みがはるかに高速であることがわかります。

[34:56 - 35:00]
唯一の問題は、

[34:58 - 35:02]
コメントデータが読み込まれていないように見えることです。

[35:00 - 35:05]
広告作成データが読み込まれておらず、

[35:02 - 35:07]
カテゴリも読み込まれていないため、

[35:05 - 35:09]
カーソルに戻ります。ここで、

[35:09 - 35:13]
右上の投稿コマンドに問題があることを説明します。カテゴリデータが作成された

[35:11 - 35:16]
後、

[35:13 - 35:18]
フロントエンドとSimsに読み込まれるようです。 データはロードされていませんが、

[35:16 - 35:21]
スーパーベースのデータが

[35:18 - 35:23]
存在するのがわかります。ruコストは何でしょうか？それで

[35:21 - 35:25]
答えは得られましたが、何らかの理由で

[35:23 - 35:27]
ファイルが直接更新されなかった

[35:25 - 35:29]
ので、手動でコピーして貼り付けます。

[35:27 - 35:31]
この関数

[35:29 - 35:34]
名をコピーして検索すると、

[35:31 - 35:37]
特定のファイルが見つかるはずです。

[35:34 - 35:40]
この部分を更新する必要があります。

[35:37 - 35:43]
この部分と戻り値を更新します。

[35:40 - 35:45]
これを保存して更新します。

[35:43 - 35:47]
コメントデータと作成

[35:45 - 35:50]
データが正しく表示されているのがわかります。

[35:47 - 35:52]
唯一の問題は、カテゴリデータがまだ取得されて

[35:50 - 35:54]
いないことです。念のため

[35:52 - 35:58]
確認させてください。投稿カテゴリは作成済みになっていると思います。手順を説明します。

[35:58 - 36:04]
作成済みデータと

[36:01 - 36:09]
コマンドデータは表示されていますが、

[36:04 - 36:13]
カテゴリデータがロードされていません。ru

[36:09 - 36:15]
コストは何でしょうか？手

[36:13 - 36:19]
順を追って説明してください。おそらく私が行うことは、

[36:19 - 36:27]
上記のスキーマに関するコマンドをコピーして貼り付けることです。これは、

[36:22 - 36:31]
スーパーベースのテーブルを作成するために使用するテーブルの詳細です。

[36:27 - 36:33]
参照として、テーブルを

[36:31 - 36:35]
作成するために使用する実際のSQLを貼り付けて、

[36:33 - 36:38]
より多くのコンテキストを提供し、次に「

[36:35 - 36:40]
いいえ」と指示します。 カテゴリデータがロードされました。

[36:38 - 36:43]
ルートコストは何だと思いますか？Sy、ステップ

[36:40 - 36:46]
バイステップで教えてください。上記は参考資料です。

[36:43 - 36:49]
デバッグを追加するように求められたので、追加して

[36:49 - 36:54]
データを再度ロードしてみます。

[36:51 - 36:59]
投稿カテゴリはこんな感じです。

[36:54 - 37:04]
投稿カテゴリは

[36:59 - 37:07]
オブジェクトの配列のように見えます。ptingは次のようになります。

[37:04 - 37:10]
素晴らしい。これですべてが機能しています。

[37:07 - 37:13]
スーパーベースに追加されたことがわかります。

[37:10 - 37:15]
戻ってもう一度クリックすると、データは

[37:13 - 37:17]
即座にロードされますが、

[37:15 - 37:20]
初めて何かを開くとデータがロードされ、

[37:17 - 37:22]
すべてのデータがスーパーベースに同期されます。

[37:20 - 37:25]
これは、既存の

[37:22 - 37:27]
プロジェクトの上に新しい機能を構築する方法です。

[37:25 - 37:29]
最後に、

[37:27 - 37:31]
UIの

[37:29 - 37:33]
見栄えを大幅に改善する方法をお見せします。Vzer

[37:31 - 37:34]
については聞いたことがあると思います。これは、

[37:34 - 37:38]
Versalが導入した一種の生成UIプラットフォームです。多くの人が

[37:36 - 37:40]
話題にしていますが、

[37:40 - 37:43]
VZをいつ使用すべきかがよくわからないかもしれません。私の経験では、

[37:42 - 37:46]
基本的にカーソルを使用して

[37:43 - 37:48]
アプリケーションの機能を構築し、

[37:46 - 37:50]
最後に戻って質問することができます。  v0 を使用すると、

[37:48 - 37:52]
UI の見栄えがずっと良くなります。これは

[37:50 - 37:54]
想像していたよりもずっと簡単です。その方法を説明します。

[37:52 - 37:57]
基本的には、v0 に

[37:54 - 37:59]
UI をページごとに更新するように依頼します。たとえば、

[37:57 - 38:02]
アプリに戻ってページを選択します。

[37:59 - 38:04]
TSX は、

[38:02 - 38:06]
すべての Rus を表示するホームページのようなもので、

[38:04 - 38:08]
基本的には vzer に移動して

[38:06 - 38:10]
ページに貼り付けるだけです。  TSX、次に手順を説明します。RIT

[38:10 - 38:14]
分析プラットフォームを構築しています。上記は

[38:12 - 38:16]
すべてのサブRを表示するホームページです。

[38:14 - 38:18]
機能は上記とまったく同じにしてください。

[38:16 - 38:20]
ただし、UIを大幅に改善してください。UI

[38:18 - 38:22]
のみが変更され、

[38:20 - 38:24]
機能と変数は変更されないことに注意してください。Enterを

[38:22 - 38:26]
クリックします。UIが

[38:24 - 38:28]
吐き出されます。

[38:26 - 38:30]
エラーが発生する可能性がありますが、無視できます。

[38:28 - 38:33]
ここに来て、この

[38:30 - 38:36]
コードをコピーして貼り付け、戻って保存します。UIの

[38:33 - 38:38]
外観が大幅に改善され、異なっていることがわかります。これが

[38:36 - 38:40]
基本的にUIを更新する方法です。

[38:38 - 38:41]
基本的には少しずつ変更する必要があります。

[38:41 - 38:46]
次は、サブレディットの追加ボタンを更新します。

[38:44 - 38:49]
コンポーネントに戻り、

[38:46 - 38:53]
SEモデルボタンとして変更します。

[38:49 - 38:55]
上記のものをコピーします。着席

[38:53 - 38:59]
モデルとボタンです。

[38:59 - 39:03]
ここでも同じ種類のコードをコピーします。同じプロンプトです。機能は

[39:01 - 39:05]
上記とまったく同じにしてください。ただし、UIを大幅に

[39:03 - 39:07]
改善してください。完了したら、

[39:05 - 39:10]
これをコピーして貼り付けます。わかりました。

[39:07 - 39:12]
もう一度試したことが1つあります。この部分を追加して

[39:10 - 39:14]
作成しました。

[39:12 - 39:16]
前のページと同じスタイルにして、

[39:14 - 39:19]
一貫性を保ちましょう。よし、

[39:16 - 39:21]
これをコピーして保存します。

[39:19 - 39:23]
ボタンも同じスタイルになっているのがわかります。

[39:21 - 39:26]
それをクリックすると、

[39:23 - 39:28]
ダークモードのようなモデルが表示されます。次に、

[39:28 - 39:32]
サブレディットに表示されるカードも変更したいので、

[39:30 - 39:35]
サブレディットカードに移動して、基本的に

[39:32 - 39:37]
同じことを行います。これらをコピーして、まったく

[39:35 - 39:40]
同じプロンプトをコピーします。これで

[39:37 - 39:43]
カードが作成されました。

[39:40 - 39:46]
これをコピーして貼り付けることができます。これで、プラットフォーム上の

[39:43 - 39:48]
他のすべてと同じスタイルであることがわかります。

[39:46 - 39:50]
次に、

[39:48 - 39:53]
サブレディットページに移動して、まず

[39:50 - 39:56]
スバルのページに移動して貼り付け、

[39:53 - 39:58]
同じプロンプトを使用して

[39:56 - 40:00]
指示を入力します。上記のサブレディットページでは、

[39:58 - 40:02]
このサブレディット分析の詳細が表示されています。

[40:00 - 40:05]
入力して完了です。矢印が表示されています

[40:02 - 40:06]
が、これは

[40:05 - 40:10]
無視して、これを

[40:06 - 40:12]
コピーしてここに貼り付けます。

[40:10 - 40:15]
全体的な構造がますます似て

[40:12 - 40:19]
きていることがわかります。

[40:15 - 40:21]
残っているのはサブレディットのタブだけです。 それをコピーして

[40:19 - 40:23]
貼り付けます。まだ少し

[40:21 - 40:27]
間違っているように見えますが、このコードをコピーして

[40:23 - 40:30]
カーソルに戻り、保存して

[40:27 - 40:32]
ここに戻ります。実際には

[40:30 - 40:35]
かなり見栄えが良くなりました。

[40:32 - 40:37]
ダークモードに溶け込んでいます。全体的には同じです。次に、

[40:37 - 40:44]
テーブルを更新したいので、

[40:41 - 40:46]
投稿テーブルに戻り、これをコピーして貼り付けます。これで見栄えが

[40:44 - 40:49]
良くなりました。

[40:46 - 40:52]
適切な配色とアディソン

[40:49 - 40:54]
アイコンも表示されます。もちろん、

[40:52 - 40:55]
さらにプロンプ​​トして、希望するスタイルにすることができます。

[40:54 - 40:58]
最後の部分に進みます。

[40:55 - 41:01]
同じカードなので、ペースと

[40:58 - 41:02]
貼り付けは素晴らしいです。UIが

[41:02 - 41:07]
以前よりもはるかにフラッシュアウトされ、すべてがより

[41:05 - 41:10]
統一されていることがわかります。もちろん、スタイルが気に入らない場合は、

[41:07 - 41:12]
V Zerにスタイルを変更するようにプロンプ​​トすることもできます

[41:10 - 41:14]
が、

[41:12 - 41:17]
最初に行うことをお勧めします。これが、美しいUIとバックアップを備えた

[41:14 - 41:20]
完全に機能するWebアプリをセットアップする方法です。

[41:17 - 41:21]
最後に、

[41:21 - 41:25]
このアプリを実際に公開して、世界中の人々が

[41:23 - 41:27]
見ることができるようにします。

[41:25 - 41:30]
Next JSの背後にある会社であるVersoを使用します。Versoのおかげで

[41:27 - 41:32]
デプロイメントがはるかに簡単になりました。

[41:30 - 41:33]
基本的にはVersoのアカウント作成ページにアクセスし、

[41:33 - 41:37]
GitHubリポジトリを購入して、

[41:35 - 41:38]
デプロイメントプロセスを実行します。このプロセスには通常、

[41:37 - 41:41]
何らかのデバッグプロセスも含まれます。ここでは

[41:38 - 41:42]
詳細は説明しません。Web

[41:42 - 41:47]
アプリ

[41:45 - 41:48]
Val Versalの実際のデプロイ方法について詳しく知りたい場合は、アプリを

[41:48 - 41:53]
リリースするために必要なすべてのステップを詳しく説明した別のビデオをご覧ください。

[41:51 - 41:54]
そのリンクは

[41:53 - 41:56]
下の説明に貼ってありますので、ぜひご覧ください。

[41:54 - 41:59]
これは、

[41:56 - 42:01]
カーソルを使用して

[41:59 - 42:03]
完全に機能するアプリケーションを構築するベストプラクティスワークフローの一部です。

[42:01 - 42:05]
詳細なドキュメントを作成します。この情報がお役に立てば幸いです。ぜひ

[42:05 - 42:09]
試してみて、このreditデータ

[42:07 - 42:11]
とチャットするなど、より高度な機能を構築することをお勧めします。

[42:13 - 42:17]
カーソルを使用してユーザー認証を構築する方法や、異なる価格帯で課金

[42:15 - 42:19]
できるようにStripeに接続する方法など、詳細を知りたい場合は、

[42:19 - 42:23]
私のコミュニティAI Builder Clubに参加してください。そこでは、

[42:25 - 42:29]
AIアプリケーションの構築方法に関する多くのヒント、詳細なプロンプト、コード例を共有しています。 それぞれに、

[42:27 - 42:31]
私が

[42:29 - 42:33]
個人的にすべてのプロジェクトで使用しているベストプラクティスのプロンプトがあり、

[42:31 - 42:35]
プラグアンドプレイでコピーして貼り付けることができます。さらに、

[42:37 - 42:41]
現在直面している問題をすでに経験している可能性のある他のAIビルダーとつながることができるので、下の説明

[42:39 - 42:42]
にあるリンクをクリックして、今日

[42:41 - 42:44]
私のコミュニティに参加してください。

[42:42 - 42:46]
このビデオを楽しんでいただければ幸いです。今後も

[42:44 - 42:49]
興味深いPurを共有していき

[42:46 - 42:50]
ますので、いいね！と購読をして、最新

[42:49 - 42:53]
情報を入手してください。ありがとうございます。また

[42:50 - 42:53]
次回お会いしましょう。

## コメント

### 1. @AIJasonZ (👍 14)
Comment for more cursor tips you know! If you wanna learn more about Cursor, join my AI builder club: https://link.agent.rocks/8ni6ADM

> **@nikola.khalil** (👍 0): Where can we speak to you about this as i have some questions regarding this program to check if it suits my requirements ! so please let me know. I love your videos and i am starting to apply but i need relevance to my industry and would like your help. so please let me know where can we contact you or if it is on here no problem. really genuinely interested

### 2. @ErsanSaribal (👍 9)
Possibly the most valuable video for AI-assisted coding. Ever.

### 3. @beiz08 (👍 22)
This is really a great example of a real structured and professional workflow for the potential role of AI-Assisted Software Developer!

### 4. @jasperruijs (👍 34)
Wow thanks man this flow is so much better as the other tutorials! ❤

1. Project Setup in md files
2. Add documentation in settings
3. The building the Front End
4 Then Connecting it With The APIs
5. Building the Backend
6. Improving the UI
7. Deployment


My first flow was

A)Setup File
B) Vo1 interface
C)API integration 

I was not planning to do web deployment, but maybe I will do Supobase.

> **@wes7bg** (👍 4): I built a crm system in under 6 hours with cursor only.. without v0.. I was sending screenshots of sections of example CRM and I instructed claude that I want mine to look like that and it executed it brilliantly.. and everything without deployment was ready.. this same project took 5 months for a pro dev (JS+PHP) .. I build it with next and it's probably better.. weird times to be a developer

> **@jdKingg_** (👍 0): @@wes7bg Indeed man, I just discovered cursor ai and these kind of flows blow up my mind. I've been a software engineer for more than 15 years now and I just quit my job just to focus on this, because this will change the way we develop, the way industry moves forward, and the way we use our tools. I truly believe that we need to spend time on this so that we don't lose our jobs in the future. 6hours crm system seems insane. congratz

### 5. @Odnodum (👍 2)
This is an excellent video, that talks about something many just ignore. Start with a great, all-encompassing PRD, don't just start "sketching" via AI.

### 6. @iAmDonH (👍 8)
I watched this on X earlier and then could not find it again. Magically it showed up on my YouTube feed 😁😁 subscribed

### 7. @local-shrink (👍 5)
Amazing tutorial for me. As a non dev it was a perfect video with exactly the amount of details needed

### 8. @antoniofuller2331 (👍 0)
Thanks man, I've been looking for someone talks at length to explain everything in depth. Means a lot. Will digest this entire video today

### 9. @Joe-bp5mo (👍 5)
Brillian as always! The workflow of how you create the cursor doc is so good

### 10. @apex-lazer (👍 3)
Thanks for taking time out of your day to always create such methodical and clear instructions. Your amazing ❤ from Germany 🇩🇪

### 11. @yucelcakir7812 (👍 2)
i have seen a few ai-assisted full stack app development, but this one is really the best structured. thank you!

### 12. @mrpocock (👍 14)
I have had a good experience getting the cursor chat window to interactively edit markdown files including product spec docs. So I've been doing this without going off to another external llm service. One trick I found was to tell it that within markdown that it generates for me, to use ~~~ fences for nested code. This is understood by markdown, but not by the cursor chat interface, so it avoids issues with the cursor chat window thinking that the edit has been exited by it entering a nested code block.

### 13. @deacon0215 (👍 1)
My favourite AI coding youtuber came through just when I want to build something similar. Thank you!!

### 14. @kevinconnolly2325 (👍 3)
Brilliant tutorial as always.  Thank you for your time and sharing with us all.

### 15. @gavienperez9329 (👍 0)
crazy how valuable this is! Thank you so much Jason

### 16. @fabiothebest89lu (👍 0)
wow, the result was pretty good. Also the UI

### 17. @oliver5356 (👍 9)
You dont need to use Claude to get thr markdown version - the openai copy button at the bottom of the response should copy the response content as MD

### 18. @ajayaiyar1907 (👍 0)
Amazing tutorial. Appreciate your step-by-step approach.

### 19. @xelkomy (👍 9)
In chat gpt you can click on ctrl+shift+c and it will copy the last response as markdown

> **@antoniofuller2331** (👍 0): Wow amazing

### 20. @junmagic8847 (👍 2)
jesus what a banger tutorial thank you!

