# How I use Cursor (+ my best tips)

**チャンネル:** Steve (Builder.io)
**公開日:** 2025-03-11
**URL:** https://www.youtube.com/watch?v=uJimjSDio_Y

## 説明

Grab all the tips here: https://www.builder.io/blog/cursor-tips?utm_source=steve-yt&utm_medium=social&utm_campaign=cursor-tips

## 字幕

[00:00 - 00:03]
チームのシニアエンジニアの一人と話していたのですが、

[00:01 - 00:05]
彼

[00:03 - 00:07]
はもうほとんどコードを入力せず、

[00:07 - 00:13]
ボックスに入力するだけだと言っていました。このボックスがエージェントボックスです。

[00:11 - 00:15]
いくつか例を挙げてみましょう。まず、

[00:16 - 00:21]
カーソルで十分に行われていないと感じている非常に優れた機能の1つから始めたいと思います。それは、

[00:18 - 00:24]
エージェントがコードが正しいことを確認するまでコードを入力できるようにすることです。

[00:21 - 00:25]
レンズだけではありません。

[00:24 - 00:28]
これをどのように行うかをお見せしましょう。YOLO

[00:25 - 00:30]
モードをオンにする必要があります。

[00:28 - 00:32]
設定に移動します。これは上にある歯車です。下に

[00:30 - 00:34]
スクロールして、YOLOモードがオンになっていることを確認してください。

[00:32 - 00:35]
名前に恐れることはありません。

[00:34 - 00:37]
最初に名前を聞いたときは、

[00:35 - 00:39]
明らかにこれを使用すべきではないと思いましたが、

[00:37 - 00:41]
私の意見では絶対にこれを使用するべきです。

[00:39 - 00:43]
ボックスにチェックを入れると、

[00:43 - 00:49]
プロンプトや許可リスト、

[00:46 - 00:52]
拒否リストを指定できる多くのオプションが表示されるためです。私が言っているのは、

[00:49 - 00:56]
あらゆる種類のテスト（npm test）を実行できることです。また、ビルド

[00:52 - 00:58]
コマンド（npm run build TSCなど）も

[00:58 - 01:04]
実行できます。本当にクールなワークフローは、  TS C で

[01:02 - 01:05]
ビルドエラーがあれば、自動的に

[01:04 - 01:07]
修正してくれます。

[01:05 - 01:09]
どのファイルでもビルドエラーを見つけて

[01:07 - 01:12]
修正し、ビルドが成功するまで繰り返し実行してくれます。これは

[01:09 - 01:14]
素晴らしい機能です。では、

[01:12 - 01:16]
私がカーソルを使って

[01:14 - 01:18]
できる最も複雑な処理を実行するための推奨方法を見ていきましょう。

[01:16 - 01:20]
このツールにプロンプ​​トを表示して、マークダウン文字

[01:23 - 01:29]
列を HTML 文字列に変換する関数を作成します。

[01:26 - 01:31]
このプロンプトが便利なのは、AI が

[01:29 - 01:33]
これを一発で実行できるケースはほとんどなく、

[01:31 - 01:35]
理解するには数回の反復が必要になるからです。

[01:33 - 01:38]
従来は、これを入力して

[01:35 - 01:40]
コードを確認し、手動でテストして

[01:38 - 01:41]
戻って「これは

[01:40 - 01:43]
違う」と思ってボックスに入力し直し、「これはちょっと

[01:41 - 01:44]
違う」と

[01:43 - 01:46]
行ったり来たりしていました。

[01:44 - 01:48]
自分の仕事が QA テスターのような気がしてきて、

[01:46 - 01:50]
それはそれで良いのですが、必ずしも楽しいとは限りません。

[01:48 - 01:51]
そのため、人々は

[01:51 - 01:55]
自動テストやテスト駆動

[01:53 - 01:57]
開発と呼ばれるものを発明しました。 私は普段テスト駆動

[01:55 - 01:59]
開発のファンではありませんが、

[01:57 - 02:01]
AIに関しては本当に本当に大好きです。

[01:59 - 02:03]
そこで、このプロンプトを

[02:01 - 02:04]
1000倍良くしましょう。特に

[02:03 - 02:08]
重要な部分では、もう1行追加します。

[02:04 - 02:11]
まずテストを書いてからコードを記述し、

[02:08 - 02:14]
テストを実行して、

[02:11 - 02:16]
テストが通るまでコードを更新します。これで、

[02:14 - 02:18]
curseなどに指示を出す必要も、

[02:16 - 02:20]
サンプルコンテキストファイルを追加する必要も、承認する必要もなくなりました。

[02:20 - 02:23]
テストディレクトリが作成されます。素晴らしいですね。v

[02:22 - 02:25]
test を使うように指示する必要もありませんでした。

[02:23 - 02:28]
パッケージからそれを見つけてくれます。JSONは非常に

[02:25 - 02:29]
賢いので、ここでテストファイルが作成されます。

[02:28 - 02:31]
素晴らしいのは、ほとんどの

[02:29 - 02:34]
生成コードとは異なり、

[02:34 - 02:39]
AIが書き込むコードの動作が正しいというある程度の保証が得られることです。

[02:37 - 02:41]
これらのテストに通れば、少なくとも

[02:39 - 02:42]
何か正しいことをしていることになります。それで、

[02:41 - 02:45]
実装コードを記述してテストを実行します。すると、

[02:42 - 02:47]
6つのテストが

[02:45 - 02:48]
失敗しました。YOLOモードを

[02:47 - 02:50]
オンにしているので、ディレクトリを作成してテストを実行できるようにし、

[02:50 - 02:54]
テストが通るまでコードを反復処理できるようにしました。 パスしました。何もしていません。

[02:54 - 02:58]
テストは1つ合格、5つ不合格です。つまり、

[02:56 - 03:00]
最初は6つ不合格でした。合格は

[02:58 - 03:02]
1つ、合格は5つです。

[03:00 - 03:04]
また進捗があるかどうか見てみましょう。

[03:02 - 03:06]
手は不要です。これらのことを監視する必要があります。

[03:06 - 03:11]
明らかに軌道から外れている場合が多々あります。

[03:09 - 03:13]
実際には正しい動作をしていないので、方向

[03:11 - 03:15]
転換する必要があります。停止ボタンを

[03:15 - 03:19]
押して「待って、待って、ちょっと待って、

[03:17 - 03:21]
軌道から大きく外れていました。リセットして再

[03:19 - 03:23]
調整して正しい軌道に戻してください」と言う必要があるのは非常に

[03:23 - 03:26]
よくあることです。これで良い更新が行われています。私には良さそうです。Rexを

[03:24 - 03:29]
使用しているのは素晴らしいことです。4

[03:26 - 03:31]
つのテストが合格し、2つが不合格です。

[03:29 - 03:34]
徐々に進捗しているのがわかります。ああ、

[03:31 - 03:36]
テストが合格しました。さあ、

[03:34 - 03:38]
上にスクロールしてみましょう。

[03:36 - 03:40]
エージェントが問題に取り組んでいるのを見るのは素晴らしいことです。

[03:40 - 03:44]
どれくらい時間がかかったかわかりませんが、

[03:42 - 03:46]
1、2分間動作し、

[03:46 - 03:50]
すべての質問に答えてすべてのテストに合格しました。 テストが終わると、私たちが

[03:47 - 03:51]
求めていた大きな美しい緑色のスクリーンが表示されます。

[03:50 - 03:52]
これは素晴らしいですね。

[03:51 - 03:54]
これは様々な用途で使えます。私はこれまで様々な用途で使ってきました。また、

[03:54 - 04:00]
既存のテストスイートをベースに、テストケースをいくつか追加して、

[04:00 - 04:04]
コードがパスすることを確認してみましょう。

[04:02 - 04:06]
私が別のプロジェクトで行っていることの一つは、既に多くのテストセットがあり、

[04:07 - 04:11]
Builder用の特定のコンパイラとコンバーターを使って、とてもクールなことをやっていることです。この

[04:09 - 04:14]
コンバーターには時々エラーが出るものがあり、

[04:11 - 04:17]
変換できなかったコードはログに出力します。私がやっていることは、

[04:14 - 04:19]
数日おきに

[04:17 - 04:22]
Google Cloud ConsoleにアクセスしてGoogle Cloud Runを使うことです。うまく動作しなかった

[04:22 - 04:26]
コードをコピーしてカーソルに貼り付け、「

[04:24 - 04:29]
このコードを実行して

[04:26 - 04:31]
コンパイルできない部分を確認」し、

[04:29 - 04:33]
その問題に対するテストを記述して、

[04:31 - 04:35]
すべてのテストがパスするまでコードを更新するだけです。これは素晴らしいことです。私は

[04:33 - 04:37]
数日おきにこれを繰り返し、

[04:35 - 04:39]
新しいケースをいくつか取り込んでいきます。すごいですね。これで

[04:37 - 04:41]
テストがパスしたようです。今は11個のテストがあります。

[04:39 - 04:43]
以前は

[04:41 - 04:44]
すべてパスしていなかったようです。このように、ビルドを何度も何度も繰り返して構築できます。

[04:44 - 04:47]
素晴らしいですね。今、ここのコメントをいくつか読んでいます。

[04:47 - 04:51]
皆さんは何を言っているのでしょうか？カーソル上でデザインをきれいに見せることはできますか？

[04:51 - 04:57]
残念ながら、カーソルや他のLMSは、

[04:57 - 05:00]
コード内でデザインが正しく表示されているかどうかを確認するのが非常に苦手

[05:11 - 05:15]
です。まだ確認していない場合は、build.ioやfigmaプラグインを使ってデザインをコードに変換できます。特にデザインファイルを少し設定すれば、ある程度の保証が得られます。もう一つ効果的な方法は、すぐにいくつか壊してみましょう。私が気に入っているテクニックを紹介します。いくつか

[05:15 - 05:18]
ファイルを見てみましょう。ちなみに、私は

[05:16 - 05:20]
左側にチャット、右側にファイルツリーを表示するのが好きです。

[05:20 - 05:24]
最近人気が高まっています。こちらももう一つ。

[05:22 - 05:25]
これは奇妙なVSSコードのバグで、

[05:24 - 05:27]
ファイルが存在しないと認識されます。

[05:25 - 05:29]
何でも無視します。

[05:27 - 05:31]
いくつかファイルに行って、いくつか壊してみましょう。TypeScript

[05:29 - 05:32]
エラーをいくつか発生させてみましょう。JSXではこのようなことは

[05:31 - 05:35]
許可されていないはずです。

[05:32 - 05:38]
もっと壊してみましょう。

[05:35 - 05:40]
メインのもの。  TSXの識別子が間違っています。

[05:38 - 05:42]
ここでもいくつか壊してみましょう。ここに行って

[05:40 - 05:44]
混乱させましょう。無効なRexを実行してみましょう。

[05:44 - 05:48]
閉じないグループのように面白いと思います。よし、これで

[05:47 - 05:50]
混乱ができました。TypeScriptの

[05:48 - 05:52]
問題がたくさんありました。今何ができるか見てみましょう。TSCを

[05:52 - 05:57]
実行するコマンドがあるかどうかすぐに

[05:54 - 05:59]
確認してみましょう。TSC DBをビルドします。ビルドしてみましょう。

[05:57 - 06:00]
ビルドは簡単です。これが私の

[05:59 - 06:02]
好きなところです。しばらくコードに取り組んでいたとします。Cod

[06:00 - 06:05]
Cody

[06:02 - 06:07]
c c c Codyと書いていたのですが、TypeScriptの問題に気づきました。

[06:05 - 06:09]
ビルドを実行します。

[06:07 - 06:11]
ここでビルドで実行します。さて、

[06:09 - 06:12]
これらすべての問題があり、

[06:11 - 06:14]
BLのように、これらを

[06:12 - 06:17]
1つずつ確認したくないです。ここで行うことは次のとおりです。

[06:14 - 06:21]
ここに行って、ビルドエラーがあると言うだけです。

[06:17 - 06:25]
ビルドを実行してエラーを確認し、

[06:21 - 06:27]
修正してから、ビルドが成功するまでビルドを実行します。

[06:25 - 06:29]
これで私の多くの このように作業します。L の

[06:29 - 06:34]
問題など、いろいろありますが、誰が気にするでしょうか。文字通り

[06:31 - 06:36]
curs にすべてを修正するように指示するだけです。

[06:34 - 06:39]
すべてのプロジェクトでコマンドを保持することがよくあります。prepr と

[06:36 - 06:40]
いうだけです。これは通常、

[06:39 - 06:42]
最も高速に実行されるビルド ステップです。CI

[06:42 - 06:46]
で実行されるエンドツーエンドのテストは実行されない可能性がありますが、

[06:44 - 06:48]
それらを壊すことはほとんどありません。webpack を

[06:46 - 06:49]
使用している場合は、webpack ビルドのように完全なビルドは実行されない可能性があります。TSC

[06:48 - 06:52]
のみを実行する可能性がありますが、

[06:49 - 06:53]
基本的には TSC のように実行されます。prettier、eslint など、

[06:55 - 06:59]
CI ビルドが壊れるかどうかを非常に迅速に判断できる高速なものがすべて揃っています。そのため、

[06:57 - 07:01]
私は単に prepr を実行して

[06:59 - 07:03]
PR の準備を整えます。1 つずつうまくいっています。

[07:01 - 07:05]
修正しているので、

[07:03 - 07:06]
エラーが検出されます。明らかに、より

[07:05 - 07:07]
重大なエラーが発生する可能性があります。Claud は

[07:06 - 07:09]
この作業に非常に長けており、

[07:07 - 07:11]
解決に向かっています。では、いくつの

[07:09 - 07:13]
エラーがあるでしょうか。ここでめちゃくちゃになってしまいました。cursor に

[07:11 - 07:14]
修正するように指示しただけで、数回の反復処理で修正されました。

[07:14 - 07:18]
何もする必要はありませんでした。これは私の

[07:16 - 07:20]
ワークフローについてですが、皆さんは忘れがちです。

[07:18 - 07:22]
エージェントがうまく

[07:20 - 07:24]
機能していて、

[07:22 - 07:26]
特定のタスクのコーディングには本当に手を出さないアプローチが取れるということです。AIの

[07:24 - 07:28]
あらゆることと同様に、試行錯誤してフィードバックを与えることを忘れないでください。

[07:28 - 07:31]
いくつか例を挙げますが、

[07:30 - 07:33]
良いフィードバックが得られないと、おそらく

[07:31 - 07:36]
脱線してしまうでしょう。実際、これらはかなり

[07:33 - 07:38]
スムーズに進んでいます。アムステルダムのDevOpsカンファレンスでデモを行いました。1、2

[07:36 - 07:42]
週間

[07:38 - 07:44]
前とその後別のカンファレンスでデモを

[07:44 - 07:48]
行いましたが、どちらの場合も、これらの例の1つまたは両方で、完全に脱線してしまいました。そういうことはよくあることです。ですから、

[07:50 - 07:52]
時にはそれを見て、

[07:51 - 07:54]
止めなければなりません。今日は素晴らしい結果が出ています。

[07:52 - 07:55]
素晴らしいことですが、

[07:54 - 07:57]
常に完璧になるとは思わないでください。それでは

[07:55 - 07:59]
UIの例を見てみ

[07:57 - 08:01]
ましょう。UIを少しやってみましょう。

[07:59 - 08:03]
このFigmaプラグインに取り組んでいて、

[08:01 - 08:05]
いくつか改善してみましょう。これはかなり難しいものです。

[08:05 - 08:09]
このFigmaプラグインで実際に行っているワークフローをお見せし

[08:09 - 08:12]
ましょう。やりたいことが2つあります。

[08:11 - 08:16]
例えば、このCに追加した

[08:12 - 08:18]
機能の一つとして、Figmaを

[08:16 - 08:20]
Builderで使う場合、Builderに何かをインポートするのと同じような感じになります。

[08:18 - 08:22]
いくつか面白い機能をお見せしましょう。

[08:22 - 08:24]
今回はデモ用に少し速くなるように精密モードを使います。これは

[08:24 - 08:27]
eコマースのホームページを

[08:26 - 08:30]
FigmaからBuilderにインポートする世界です。ここで、

[08:27 - 08:31]
コンポーネントも再利用します。そして、

[08:31 - 08:34]
AIを使ってBuilderで編集します。これは

[08:33 - 08:36]
後ほどお見せします。そして、

[08:34 - 08:38]
その変更をFigmaに戻します。

[08:36 - 08:41]
これは今回

[08:38 - 08:42]
追加した機能です。Builderで確認してみましょう。コンポーネントなどが再

[08:41 - 08:44]
利用される様子をお見せします。さあ、

[08:44 - 08:49]
Builderで

[08:47 - 08:50]
デザインが完成しました。これは

[08:49 - 08:53]
ライブWebサイト上に表示されています。これも

[08:50 - 08:55]
コンポーネントを使用しているのでクールです。これは

[08:53 - 08:56]
Figmaのレイヤーをplingしただけではなく、

[08:55 - 08:58]
Reactコンポーネントです。

[08:56 - 09:00]
切り替えたり、別のコレクションを追加したりできます。

[08:58 - 09:01]
何でも

[09:00 - 09:03]
好きなように公開できます。 このサイトから好きな

[09:01 - 09:05]
コードをダウンロードできます。AIを

[09:03 - 09:08]
使って変更を加えていきましょう。

[09:05 - 09:10]
まずはここに行きましょう。

[09:08 - 09:12]
このセクションでは、Figoにはあまり

[09:10 - 09:13]
良いAI機能がないので、

[09:12 - 09:14]
ビルダーでやってみましょう。AIは

[09:13 - 09:17]
コードにとても優れているので、

[09:14 - 09:21]
ここにプロンプ​​トを入力して、

[09:17 - 09:23]
4番目の列を追加し、これを

[09:21 - 09:25]
内部でフルスクリーンにします。これは

[09:23 - 09:26]
カーソルで見られるようにCLAを使用しているだけです。もう少し

[09:25 - 09:27]
視覚的にわかりやすくなっていますが、

[09:26 - 09:28]
1秒以内に何ができるか、そして

[09:27 - 09:30]
それをFigmaに戻す方法をお見せします。

[09:28 - 09:32]
そして、この上にいくつかのものを構築します。

[09:30 - 09:34]
フルスクリーンになり、

[09:32 - 09:35]
4番目の列が追加されました。インタラクティブ性を追加できます。

[09:35 - 09:39]
コールドカーソルボルトやLevなどで以前行っていた操作を実行できますが、

[09:37 - 09:41]
すべて視覚的に編集可能です。

[09:39 - 09:42]
ここに移動して

[09:41 - 09:45]
別の列を追加し、

[09:42 - 09:47]
この色やこの画像などを変更したり、

[09:45 - 09:50]
ビルダーで編集できるものは何でも、

[09:47 - 09:53]
Figmaなどと同じように変更できます。とにかく、これをダーク

[09:50 - 09:54]
LOEスタイルにしましょう。 私の

[09:53 - 09:56]
ダークモードのスタイリングがこの見た目を気に入っているので、

[09:54 - 09:58]
これをチェックしてください。今できることは

[09:56 - 10:01]
本当にクールです。これをコピーして、

[09:58 - 10:03]
hey command see と入力し、

[10:01 - 10:05]
Figma に戻ってこれをチェックします。インポート タブに移動して

[10:03 - 10:07]
、

[10:05 - 10:09]
ここに貼り付けます。コピーできます。Figma から

[10:07 - 10:11]
Builder にインポートし、Builder で

[10:09 - 10:13]
AI を使用して編集してから、Figma に貼り付けます。これで

[10:13 - 10:17]
美しいものができました。これが美しいものです。これを

[10:15 - 10:18]
大きくすることができます。何でも

[10:17 - 10:21]
できます。とてもクールです。Figma

[10:18 - 10:23]
Builder に戻って編集したり、好きなことをしたりできます。

[10:21 - 10:24]
アイデアがわかりますか。

[10:23 - 10:26]
これはかなり楽しいので、

[10:24 - 10:28]
これに機能を追加したいと思います。

[10:26 - 10:30]
現時点では、これは単純なフラット レイヤーとして提供されており、

[10:30 - 10:33]
編集が最も簡単な場合がよくあります。自動レイアウトは

[10:31 - 10:34]
非常に面倒な場合があります。文字通り、

[10:33 - 10:36]
buom BM bom のように、

[10:34 - 10:38]
どこにでも移動したいだけです。しかし、

[10:36 - 10:41]
かなり複雑な機能を追加したかったのです。

[10:38 - 10:44]
自動レイアウト

[10:41 - 10:46]
とフレームまたはフレームの階層を使用したいと思います。

[10:44 - 10:47]
コードをコミットすることを 100% 推奨します。 これは

[10:46 - 10:50]
機能しています。カーソルで完全なエージェントフローに入る前に、

[10:50 - 10:54]
チェックポイントを復元するなど、履歴を遡ることができます。これは

[10:52 - 10:56]
優れたボタンです。覚えておいて

[11:04 - 11:08]
ください。VS Codeでは、タイムラインビューに移動して、以前に保存したファイルまで時間を遡ることができる機能もあります。それでは私が

[11:06 - 11:10]
やっていることをお見せしましょう。これはcserエージェントの中でも最も面倒な部分です。

[11:10 - 11:14]
ここにUIも追加したいので、

[11:11 - 11:16]
HTML to figma fuckプラグインに移動しました。

[11:14 - 11:17]
これが内部的にどのように機能するかというと、

[11:16 - 11:19]
HTMLをFigmaに変換し、

[11:17 - 11:22]
計算された

[11:19 - 11:23]
スタイルを調べて、それをFigmaの

[11:22 - 11:25]
スタイルに変換します。Figmaはこれらすべての異なるスタイルをどのように処理するのでしょうか。

[11:25 - 11:30]
このuse framesオプションがあり、現在

[11:28 - 11:32]
この関数を呼び出すたびに

[11:30 - 11:35]
常にfalseを渡しています。

[11:32 - 11:36]
今のところ、代わりに私が

[11:35 - 11:39]
やったことをお見せします。

[11:36 - 11:40]
簡単にするためにuse framesをtrueにハードコードしましたが、

[11:39 - 11:42]
ここで重要なことがあります。 クロードさん、ヒント。

[11:40 - 11:43]
クロードはそれを見て、

[11:42 - 11:45]
何かのバージョンのように動作します。CLAに指示します。CLA

[11:43 - 11:46]
またはカーソルに更新するように指示します。

[11:45 - 11:47]
そして、何が起こるか保証します。

[11:46 - 11:49]
それを見て、それは間違っているように見えるので、

[11:49 - 11:52]
それを削除し、GNAで元に戻します。これはこれを実行し、これを実行しようとします。

[11:50 - 11:53]
私は

[11:52 - 11:55]
気づかず、なぜ

[11:53 - 11:57]
これが

[11:55 - 11:58]
正しく動作しないのか疑問に思うでしょう。そのため、

[11:57 - 12:00]
クロードをできるだけ

[11:58 - 12:01]
共同作業者のように扱うことを強くお勧めします。つまり、何かが

[12:00 - 12:03]
おかしい場合は、他の開発者が

[12:01 - 12:04]
それをクリーンアップする可能性があり、「これは一体何だ、

[12:03 - 12:06]
これは間違っている」と思うかもしれません。そのため、コメントを追加します。「

[12:04 - 12:08]
動作がおかしい」のように、

[12:06 - 12:11]
今はテスト用に意図的にハードコードされています。クロードに

[12:08 - 12:13]
何かが

[12:11 - 12:15]
おかしいように見える場合は、これは

[12:13 - 12:17]
意図的であると伝えてください。そうすれば、

[12:15 - 12:19]
勝手に変更されることはありません。保存します。

[12:17 - 12:21]
これで、常にこれを使用するようになります。

[12:19 - 12:22]
フレームオプションを使用するので、

[12:21 - 12:24]
何が起こるか見てみましょう。おそらくうまくいか

[12:22 - 12:26]
ないでしょう。 動作しますが、

[12:24 - 12:28]
AIから完全に離脱する必要がある場合もあります。

[12:26 - 12:31]
特定のものが

[12:28 - 12:32]
AIにうまく機能することを私は知っていますが、多くの場合試してもいません。私は

[12:31 - 12:35]
両方を組み合わせて使用​​しています。

[12:32 - 12:37]
ここでクリップボードからもう一度貼り付けます。

[12:37 - 12:40]
リロードされたと思います。貼り付けてみましょう。

[12:39 - 12:41]
今回はおそらく機能しません。おっと、

[12:41 - 12:45]
クリップボードに何が入っているか見てみましょう。いいえ、問題なさそうです。

[12:44 - 12:47]
ああ、それは実際には悪いエラーメッセージです。これは

[12:45 - 12:48]
私のせいです。コンソールに行って

[12:47 - 12:50]
、ここのどこが間違っているか確認してみましょう。

[12:48 - 12:52]
最大の呼び出しSt exがあると思います。わかりました。これは

[12:50 - 12:54]
面白い例です。私がすることは、

[12:52 - 12:56]
これのスクリーンショットを撮って、

[12:54 - 12:59]
クラウドに移動してスクリーンショットを貼り付けます。

[12:56 - 13:01]
これが表示され、

[12:59 - 13:03]
ループ内にありませんでした。修正してください。今、1つの問題があります。

[13:01 - 13:05]
実際には、

[13:03 - 13:06]
ショートカットで問題を説明します。私は

[13:05 - 13:08]
すでにこれを2回実行したので、

[13:06 - 13:09]
ストリームにジャンプする前に実際にいくつか試しました。

[13:08 - 13:12]
同じ問題が発生しています。

[13:09 - 13:15]
修正してください。 スクリーンショットをアップロードしました。

[13:12 - 13:18]
そして、ここでも同じ問題です。修正してください。

[13:15 - 13:20]
もちろん、クロードの得意技は

[13:18 - 13:22]
「問題が分かりました。GNAです。今すぐ実行してください。問題が分かりました。いつもこうなります。分かりまし

[13:22 - 13:27]
た。分かりました。それで、

[13:24 - 13:29]
改善できる点の1つは、

[13:27 - 13:32]
もう少しよく考えてくださいというスタイルの

[13:29 - 13:34]
プロンプトを出すことです。これからやることは、

[13:32 - 13:36]
より多くの指示を与えることです。

[13:36 - 13:41]
少なくとも3つの原因の可能性について考えてください、と言うことです。

[13:39 - 13:42]
そして、実際には、

[13:41 - 13:45]
あまりやらないのですが、

[13:42 - 13:48]
非常に効果的だと聞いた別の手法を試してみましょう。

[13:48 - 13:52]
履歴を維持できます。いいですね。

[13:50 - 13:54]
今回は、

[13:54 - 13:57]
複数の選択肢を検討して

[13:55 - 14:01]
最適なものを選択する、非常によく考えられた計画を作成してもらうようにします。これは、

[13:57 - 14:02]
O1やO3などのツールが訓練されていることです。これは、

[14:01 - 14:04]
クラウドがこの

[14:02 - 14:06]
訓練を受けていないかもしれませんが、人々がこれがうまく機能することだと感じていることです。

[14:06 - 14:09]
誰かが複雑な質問をして、スラスラ答えるように

[14:07 - 14:11]
要求した場合と少し似ています。

[14:09 - 14:13]
すぐに答えを出すか、少し時間をかけてじっくり

[14:11 - 14:15]
考えるか、これは似たような話な

[14:13 - 14:18]
ので、3つの

[14:15 - 14:21]
可能性を挙げてみます。3つの可能性を考えてください。

[14:18 - 14:24]
それぞれについて詳しく説明してください。

[14:21 - 14:27]
最も可能性の高い原因と思われるものを選んでください。

[14:24 - 14:30]
上で述べたように、すでに2つの

[14:27 - 14:33]
方法を試しましたがうまくいきませんでした。どちらも全く同じエラーが

[14:30 - 14:36]
発生するため、再度試さないでください。

[14:36 - 14:41]
最も可能性の高い

[14:40 - 14:43]
解決策を選んだら、すぐに別の

[14:41 - 14:45]
トリックも紹介します。Cに

[14:43 - 14:47]
ログを追加するように指示し、コードを実行してログを確認し、

[14:47 - 14:49]
解決策が見つかるまで反復処理します。これは

[14:48 - 14:51]
かなり良いものです。これは少し

[14:49 - 14:53]
不確実ですが、良いものです。

[14:51 - 14:54]
時間の経過とともに、このようなケースが増えると思います。

[14:53 - 14:57]
モデルはこの点で改善されると思います。後で

[14:54 - 15:00]
詳しく説明します。解決策の実装方法を詳しく説明してください。

[15:00 - 15:05]
初心者のエンジニアでもうまく解決できるような綿密な計画が得られる場合があります。そのため、

[15:05 - 15:08]
CLA（

[15:07 - 15:10]
カーソルなど）に綿密な

[15:10 - 15:15]
計画を書いてもらうなど、非常に綿密な計画を書いてもらってからコーディングを開始する方が

[15:13 - 15:17]
はるかに効果的です。 じっくり

[15:15 - 15:18]
考えます。3

[15:17 - 15:20]
つの可能性を書き留めています。5

[15:18 - 15:22]
つを選ぶべきだったのかわかりません。3つにします。3

[15:20 - 15:26]
つが一番可能性が高いと考えています。

[15:22 - 15:27]
そのまま読み進めています。

[15:26 - 15:29]
大丈夫です。コードを書くのではなく、

[15:27 - 15:31]
計画を立てることになっていますが、

[15:29 - 15:33]
とにかくこれで作業します。

[15:31 - 15:34]
すべて考えさせられます。それでは、

[15:34 - 15:40]
エージェントに「素晴らしいです。

[15:38 - 15:42]
これを実装してください」と言います。その後、実際に

[15:40 - 15:44]
考えを巡らせます。「これが

[15:42 - 15:46]
役立つかどうか見てみましょう。これを修正してください」と言うと、修正されません。それで

[15:46 - 15:49]
修正されませんでした。もう一度試してくださいと言うと、修正されません。2回試しても

[15:47 - 15:50]
おそらく

[15:49 - 15:52]
改善されません。

[15:50 - 15:54]
無限に続く可能性があります。そこで、どのように

[15:54 - 15:58]
考え、解決策を検討すべきかについて、より徹底的に質問するようにします。それがうまくいくこともあります。それでもうまく

[15:58 - 16:02]
いかない場合は、次に

[16:00 - 16:05]
ログを作成させます。ログをフィードバックします。それでもうまくいか

[16:02 - 16:06]
ない場合は、中止して

[16:05 - 16:09]
人間として作業を開始します。これ

[16:06 - 16:10]
については後で説明します。  CLA やカーソルが行う他の動作で、

[16:10 - 16:15]
注意すべき点はありますか？

[16:12 - 16:17]
ここに戻ってインポートを選択し、クリップボード

[16:15 - 16:19]
に既に保存してある内容を貼り付けます。

[16:17 - 16:22]
間違った内容です。はい、

[16:19 - 16:24]
クリップボードにコピーしたものを貼り付けます。

[16:22 - 16:25]
エラーと最大コストが表示されています。わかりました。

[16:24 - 16:27]
今回はうまくいきませんでしたが、うまくいくこともあります。では

[16:27 - 16:32]
次の作業に進みましょう。コードにログを追加して、

[16:30 - 16:35]
何が起こっているかをより明確にし、

[16:32 - 16:38]
修正方法を見つけられるようにしてください。コードを

[16:35 - 16:40]
実行してログの

[16:38 - 16:42]
結果を表示します。

[16:40 - 16:45]
それでは、コンソールをクリアします。繰り返しますが、

[16:45 - 16:50]
人間ならどのように解決するかなど、多くのことをよく考える必要があります。AI は

[16:47 - 16:52]
魔法ではありません。

[16:50 - 16:55]
人間はより多くの情報を必要とする場合があり、

[16:52 - 16:57]
AI も多くの場合より多くの情報を必要とするため、計画を立てることが役立つことがあります。

[16:55 - 16:59]
ちなみに、

[16:57 - 17:01]
人間にとって、より

[16:59 - 17:02]
徹底的に計画を立てることは良いことです。問題を

[17:01 - 17:03]
試行錯誤することが良い場合もあれば、問題を計画することが良い場合もあります。

[17:03 - 17:07]
計画に対するフィードバックを得ることが良い場合もあります。そして、

[17:07 - 17:10]
ログを作成させる必要がある場合もあります。本当によく考えたいですか？

[17:09 - 17:12]
重要な点はすべてどこにあるのでしょうか？ ログ

[17:10 - 17:13]
記録のポイント 何を

[17:12 - 17:16]
ログに記録するのが最適かは分かりませんが、あまり良くないので

[17:13 - 17:17]
Claudに任せましょう。では、

[17:16 - 17:19]
これを印刷して、このごちゃごちゃした

[17:17 - 17:20]
ログを取り除きましょう。それらの多くは

[17:19 - 17:23]
Figmaのログです。ちなみに、これは私の

[17:20 - 17:25]
ごちゃごちゃしたログではありません。ちょっと走ってみましたが、うまく

[17:23 - 17:28]
いくと思いました。では、

[17:25 - 17:33]
これを

[17:28 - 17:35]
友人のClaudy CLAに貼り付けましょう。Bam Bam

[17:33 - 17:39]
戻って、これがログ

[17:35 - 17:42]
出力です。無限再帰の原因は何だと思いますか？

[17:39 - 17:45]
また、どのように修正しますか？

[17:42 - 17:47]
Bamは間違った出力を貼り付けました。CLAには

[17:45 - 17:49]
Superは必要ありません。

[17:47 - 17:50]
つまり、LLMには適切にフォーマットされた

[17:49 - 17:53]
ものが必要なので、これらがログであることを理解できます。ログを確認します。

[17:53 - 17:56]
問題がより

[17:54 - 17:58]
明確にわかります。無限再帰は

[17:56 - 18:00]
フェーズ4の位置処理中に発生しています

[17:58 - 18:01]
が、実際には

[18:00 - 18:03]
フェーズ3で作成された循環参照が原因です。これが

[18:01 - 18:05]
私の見たものです。これは

[18:03 - 18:06]
私がまだ考えていなかった計画です。 今回は計画を立てるように言われました。

[18:06 - 18:09]
今回はもっと綿密な計画を立てました。これがうまくいくかどうか見てみましょう。うまくいけば、

[18:08 - 18:11]
将来的には素晴らしいことです。

[18:09 - 18:13]
特に

[18:11 - 18:15]
カーソルチームがポッドキャストなどで共有している作業を知っているので、

[18:15 - 18:20]
彼らはさらにエージェント化していくと思います。

[18:17 - 18:21]
オリジナルのDevonのデモを見たことがあるなら、

[18:20 - 18:23]
Devonはログを追加してデバッグし、

[18:21 - 18:25]
ブラウザを開いてなどなど。

[18:23 - 18:27]
クラウドは

[18:25 - 18:29]
もっと多くのことを行うと思います。すみません、カーソルは

[18:27 - 18:32]
時間の経過とともにもっと多くのことを行うと思います。Cもそうするかもしれません。よく

[18:29 - 18:36]
わかりません。Open AIは

[18:32 - 18:39]
アプリの使用にますます取り組んでいるので、ネイティブアプリが

[18:36 - 18:42]
ツールにアクセスできるようになります。

[18:39 - 18:44]
これは試したことがないのですが、実際に

[18:42 - 18:47]
設定した場合どうなるのでしょうか。アプリのインストール方法を教えてください。

[18:47 - 18:51]
拡張機能が必要ですね。わかりました。

[18:49 - 18:54]
いつか試してみます。チャットは最適なモデルではありません。

[18:51 - 18:57]
えーと、止まりました。なぜ止まったのですか？2

[18:54 - 18:59]
つ変更しました。なぜ止まったのか聞いてみましょう。

[18:57 - 19:01]
続行します。なぜ止まったのかわかりません。わかりません。止まっていません。

[19:01 - 19:05]
待っていました。 ログを共有してください。ああ、わかり

[19:03 - 19:08]
ました。後で謝りますが、これが

[19:05 - 19:09]
止まりました。

[19:08 - 19:12]
彼女がクロードと本当に議論したのはこれが初めてでした。

[19:09 - 19:14]
止まるようで、私は止まりませんでした。それでは試してみましょう。

[19:12 - 19:17]
ここに入りましょう。ログを消去しましょう。

[19:14 - 19:20]
フィグマプラグインを起動しましょう。

[19:17 - 19:23]
パスタをしましょう。おっと、これは私が望んでいたものとは違う。

[19:20 - 19:26]
パスタ、パスタ、できた。ツリーを

[19:23 - 19:29]
完成させましょう。これを貼り付けましょう。私の

[19:26 - 19:33]
オーバーロードが私に命令し、

[19:29 - 19:35]
私と議論したので、新しいログがあります。わかりました。AI

[19:33 - 19:38]
オーバーロード、私は

[19:35 - 19:41]
あなたの指示に従いました。今度は私が頼んだ

[19:38 - 19:44]
ことをしてください。修正してください。修正してください。

[19:41 - 19:46]
ミームはどこにあるのですか？お願いします。ロー、お願いし

[19:44 - 19:47]
ます。クロード、クロード、

[19:46 - 19:50]
もっと大きなバージョンが欲しいです。これをどうやって開けばいいですか？

[19:47 - 19:53]
さあ、行きます。クロード、

[19:50 - 19:55]
とにかく見てみましょう。見てみましょう。

[19:53 - 19:56]
これをできますか。助けてくれませんか。

[19:55 - 19:59]
まだファンを打っているのがわかりますが、別の

[19:56 - 20:01]
場所で。複数のレブがクッションにいます。わかりました

[19:59 - 20:02]
ね。

[20:01 - 20:04]
これを永遠に続けることはないでしょうが、

[20:02 - 20:07]
この方法で多くの問題を解決できます。同じ

[20:04 - 20:09]
ことがUIにも当てはまります。UIがあり、

[20:07 - 20:10]
UIを更新するように指示するだけです。

[20:09 - 20:12]
機能を備えたボタンを追加して、

[20:10 - 20:13]
ボタンをクリックして、

[20:12 - 20:15]
正しく実行されるかどうかを確認します。正しく実行されない場合は、

[20:13 - 20:16]
何が間違っているかがわかります。

[20:15 - 20:19]
ボタンが何をしたかがわかります。これは違います。スクリーンショットを送信します。

[20:16 - 20:21]
すべてうまくいきます。AI

[20:19 - 20:23]
オーバーロードとして実行して、

[20:21 - 20:25]
問題があればお知らせください。

[20:23 - 20:27]
ログをコピーし続けているからです。これらすべてを行った後、

[20:25 - 20:29]
元の問題に戻ります。

[20:27 - 20:31]
元の問題は特にありませんでした。

[20:29 - 20:33]
インポートすると、1つのフレームが再び取得されます。

[20:31 - 20:34]
これが文字通り

[20:33 - 20:36]
今日解決しようとしている問題です。なぜなぜなぜなぜ

[20:34 - 20:38]
これは私が

[20:36 - 20:39]
過去に書いたコードです。これを修正しましょう。

[20:38 - 20:41]
私が行うことは次のとおりです。

[20:39 - 20:43]
スクリーンショットを撮って、これが

[20:41 - 20:47]
起こったことを確認します。Cladに戻ります。さて、

[20:43 - 20:50]
元の問題に戻ります。

[20:47 - 20:53]
空のフレームが1つしかインポートされません。figma

[20:50 - 20:56]
のスクリーンショットを参照してください。修正してください。もっと

[20:53 - 20:59]
親切にしましょう。Clan お願いします、

[20:56 - 21:01]
あなたはあなたはエキスパートプログラマーです、

[20:59 - 21:04]
史上最も賢いプログラマーです、

[21:01 - 21:07]
問題を見ると必ず実際に

[21:04 - 21:10]
問題に気づきます、クラウド、お願いします、今回はバグはありません、

[21:07 - 21:11]
お願いします、これが私のエキスパートプロンプトのヒントです、これが

[21:10 - 21:13]
CLA を毎回望みどおりに動作させる方法です、それが

[21:13 - 21:16]
できるかどうか見てみましょう、試してみます、考えてみましょう、

[21:16 - 21:20]
ここで他のいくつかのラピッドファイアカーソルのヒントをすぐに見てみましょう、よし、

[21:18 - 21:21]
何かが起こっています、それが何をしたかを説明しています、

[21:21 - 21:27]
他のクールなものをいくつかお見せする前にもう一度試してみましょう、

[21:24 - 21:30]
ここにバム、クリップボード、バム、見てみましょう、できますか、できますか、

[21:30 - 21:33]
フレームがありませんでした、

[21:33 - 21:37]
ここで他のいくつかのラピッドファイアをお見せします、これが私が使用する主なワークフローですが、

[21:36 - 21:39]
ここにあなたが

[21:37 - 21:40]
既に知っているかもしれない、または知らないかもしれない他のいくつか、本当に本当に

[21:39 - 21:43]
便利なものがあります、最近私がやったことをお見せしましょう、

[21:43 - 21:48]
今日私がやったことはこれです、私が書いたこの美しいコードを見てください、

[21:45 - 21:51]
内部 HTML イコールインライン

[21:48 - 21:52]
スタイル、これは Peak シニア開発です、

[21:51 - 21:54]
ここに入ってください、何を

[21:52 - 21:55]
変更したいですか、もっときれいにしたいです、私は

[21:54 - 21:57]
すべてのフォントを大きくしました 小さくしたいので、

[21:57 - 22:02]
メインのコピーされたテキスト以外のすべてのフォントを小さくします。

[22:01 - 22:04]
コマンド K でそれができます。コマンド K を使用すると、

[22:02 - 22:07]
何かを選択してインラインで処理できます。

[22:04 - 22:09]
コマンド I はエージェントを開きます。

[22:07 - 22:12]
これは便利です。コマンドと Enter は

[22:09 - 22:14]
便利な機能です。時々使います。これを

[22:12 - 22:16]
選択して

[22:14 - 22:17]
コマンド I を実行すると、コンテキストに配置されます。

[22:17 - 22:20]
エージェントのチャットが開きます。

[22:19 - 22:21]
コンテキストにそれが投げ込まれ、チャットして

[22:20 - 22:23]
更新できます。これも

[22:21 - 22:25]
うまく機能します。なぜ

[22:23 - 22:27]
コマンド I ではなくコマンド K を使用するのでしょうか。主な理由は、

[22:25 - 22:29]
その方が高速であることです。

[22:27 - 22:30]
このコードのみを操作していることを認識しています。

[22:29 - 22:32]
インライン UI も良いと思います。使い

[22:30 - 22:34]
心地が良いです。シンプルで

[22:32 - 22:36]
素敵ですが、

[22:34 - 22:37]
選択したときにのみ再生成されることを認識しています。そのため、

[22:36 - 22:39]
非常に高速です。エージェントではそれほど高速になることはありません。

[22:37 - 22:41]
エージェントは少し

[22:39 - 22:43]
おしゃべりです。少しおしゃべりです。

[22:41 - 22:44]
いつもおしゃべりしたいわけではないので、これは便利です。もう

[22:43 - 22:46]
1 つは、Pro はターミナルを知らない可能性があります。

[22:44 - 22:47]
これについて不満を言いました しかし、

[22:47 - 22:51]
ターミナルでKコマンドを使うのも素晴らしいです。ターミナルで一番好きなのは

[22:49 - 22:54]
キーストロークを節約することです。

[22:51 - 22:56]
最近の5つの

[22:54 - 22:58]
ブランチを一覧表示すると、キーストロークを節約しているのではなく、

[22:56 - 22:59]
単に節約しているだけです。 うん、

[22:58 - 23:03]
キー入力をかなり節約できてるよ。この

[22:59 - 23:05]
美しい実行ファイルを見て。これが私の最新の

[23:03 - 23:08]
ブランチだ。この素晴らしいタイプミスを見て。

[23:05 - 23:09]
すごい。覚えてない。君が

[23:08 - 23:11]
私より記憶力がいいか分からないけど、

[23:09 - 23:14]
このクソは覚えてない。各参照に対して取得する。一体全体、

[23:11 - 23:16]
剣とフォーマットが等しいって何だ。

[23:14 - 23:17]
このクソは覚えてない。

[23:16 - 23:18]
覚えてない。

[23:17 - 23:20]
こういうことを覚える気にもならない。それが

[23:18 - 23:22]
私を少し悪くしてるのかな。Cod にしろ、いや、私には最も重要な問題を

[23:20 - 23:23]
解決する時間と精神力がある。

[23:22 - 23:25]
でも、美しいものは私がやり

[23:23 - 23:26]
たいことをやってくれる。大好きだ。

[23:25 - 23:27]
もう少し説明しよう。オートコンプリートについてはみんな知っているから、

[23:30 - 23:34]
カーソルで直感的ではないことがあることをお見せしよう。でも、これを 1 年以上使ってきて、

[23:34 - 23:39]
ほとんどの場合正しく行う方法がわかったと思う。

[23:36 - 23:41]
いつもそうとは限りません。では、これを使おう。すばらしい。

[23:39 - 23:42]
これに追加しよう。これをチェックしてみ

[23:41 - 23:45]
て。ここにクールなものがある。ここにある

[23:42 - 23:46]
灰色のテキストを見て。もう一度 Tab キーを押すと、

[23:45 - 23:47]
オートコンプリートされる。

[23:47 - 23:52]
カーソルについて混乱する点は、この「タブをもう一度」機能が

[23:49 - 23:54]
少し変わっていることです。なぜ変わったのか、いつ変わったのかはわかりませんが、

[23:52 - 23:56]
これは非常にシンプルで、「タブをもう一度」は

[23:54 - 23:58]
素晴らしいです。実際に2つのことが行われていて、これはクールでした。そして、今度は

[23:58 - 24:02]
どのように表示されているのか、なぜ以前は表示され

[24:00 - 24:05]
なかったのかわかりません。これとは異なるUIを使用しているため、

[24:02 - 24:09]
時々わかりません。バン、

[24:05 - 24:11]
そしてバン、素晴らしいバン、バン、タブ、わかりました。

[24:09 - 24:13]
タブでジャンプ、何が起こるか見てみましょう。タブでジャンプ、

[24:11 - 24:15]
ああ、ジャンプするはずです。これは

[24:13 - 24:17]
興味深いものです。今度はタブで、

[24:15 - 24:21]
何かを完了せず、ジャンプしただけだったので、

[24:17 - 24:22]
もう一度タブを押します。

[24:21 - 24:24]
今は非常にうまく機能しています。時々

[24:22 - 24:26]
何が起こるか、文字通りタブだけであることに気づきます。

[24:26 - 24:30]
そこで、タブで完了しようと思うと、コードが終了します。

[24:28 - 24:32]
なぜかわかりません。これが最も

[24:30 - 24:33]
重要な機能ですか？いいえ、明らかに

[24:32 - 24:35]
カーソルは自動で動作します。他の皆さんと同じように、

[24:33 - 24:37]
特に優れています。

[24:35 - 24:38]
コスト遅延は、私がいつもこれを書いているように、

[24:37 - 24:40]
遅延関数があり、いつでも

[24:38 - 24:42]
待機して遅延できます。

[24:40 - 24:43]
これが最も好きな

[24:42 - 24:45]
機能です。 理想的には、ワールドはジョブスクリプトで構築されるべきです。Rで

[24:45 - 24:48]
いくつか質問させてください。Builderの開発スペース

[24:46 - 24:49]
でコードボタンを使用することをお勧めします

[24:48 - 24:51]
か？それとも

[24:49 - 24:53]
公開スペースでも使用できますか？コードボタンは開発スペース

[24:51 - 24:55]
で使用する必要があります。Builderで

[24:55 - 24:59]
コードを取得したい場合は、これをお見せします。

[24:57 - 25:02]
開発スペースでは、デザイン、

[24:59 - 25:03]
コード生成などが中心になります。コードタブに移動して

[25:02 - 25:05]
現在の

[25:03 - 25:07]
選択範囲などを選択すると、

[25:05 - 25:09]
すべてがコードとして出力されます。また、

[25:07 - 25:11]
この素晴らしいCLIもあります。CLIはコード内で実行され

[25:09 - 25:12]
、cursのように

[25:11 - 25:14]
コードを分析し、コードに統合します。これは

[25:14 - 25:19]
本当にクールですが、いわゆる

[25:16 - 25:21]
公開スペースでは、

[25:19 - 25:24]
API経由で接続して文字通り公開することができます。

[25:21 - 25:26]
レビューが完了したら、

[25:24 - 25:28]
PRレビューのようなオプションのワークフロー

[25:26 - 25:30]
機能である公開するだけで、

[25:28 - 25:31]
ライブサイダーアプリに公開されます。

[25:30 - 25:33]
これは非常にクールです。Figma

[25:33 - 25:37]
からドラッグアンドドロップしてプルするだけで新しい ページを

[25:35 - 25:38]
React Angularやその他のサイトにリンクします。とにかく、

[25:38 - 25:43]
ここでもう2つクールな機能を紹介しましょう。カーソルでコミットメッセージを生成できることをご存知ないかもしれません。

[25:43 - 25:47]
実際、私はいつも忘れてしまうのですが、

[25:45 - 25:49]
もっと頻繁に行う必要があるので、これをチェックしてください。

[25:47 - 25:53]
ソース

[25:49 - 25:55]
管理タブに移動すると、小さな魔法が表示されます。

[25:53 - 25:58]
魔法が実行されます。魔法を実行し

[26:12 - 26:18]
てください。申し訳ありませんが、これは期待していたメッセージではありません。Claudeと1時間も議論しても、ey apollやその他の奇妙なものが表示されないことなどあり得ません。わかりました。もう一度試してみましょう。わかりません。G

[26:15 - 26:20]
to apoll、申し訳ありませんが、何らかの

[26:18 - 26:22]
couchingだと思っていましたが、残念です。

[26:20 - 26:24]
ここに移動して、

[26:22 - 26:27]
I apollよりも良いものがないか見てみましょう。

[26:24 - 26:29]
ここに読み込みインジケーターが表示されないので、ああ、

[26:29 - 26:33]
UI付きの小さなブログがあります。

[26:30 - 26:34]
悪くありません。フレームとレイヤー階層生成を改善するために、Make Treeをリファクタリングしましょう。K、

[26:34 - 26:38]
より

[26:36 - 26:40]
堅牢なマルチフェーズアプローチのために、Make Treeを再作成します。詳細ログ

[26:38 - 26:43]
記録 フレームとクール。これはクールだ。では

[26:40 - 26:45]
バグファインダーに行ってみよう。

[26:43 - 26:47]
他にどんなクールなことができるのか。

[26:45 - 26:49]
こう言う人がいるが信じない。

[26:47 - 26:52]
ここでもモデルを変更できることを覚えておいてくれ。

[26:49 - 26:53]
すごい。GBD 4.5 は良くないのに、

[26:52 - 26:56]
こういうことには実際向いていない。

[26:53 - 26:59]
なぜ 01 が無効になっているのか。面白い。01 は

[26:56 - 27:01]
推奨されていない。

[27:01 - 27:04]
複雑な問題を解決してじっくり考えるには 01 のほうが優れていると示唆する人もいる。K は

[27:03 - 27:06]
推奨していない。納得。バグ

[27:04 - 27:09]
ファインダーに行ってみよう。バグファインダーはただクールだから。Comm

[27:06 - 27:11]
ofp つまり、バグファインダーだ。バグファインダーを

[27:09 - 27:14]
表示。ああ、

[27:11 - 27:16]
こちら側にバグファインダーがある。よし​​、彼らは

[27:14 - 27:19]
私を混乱させ続けている。よし、ここで変更を加えたことで

[27:16 - 27:22]
いくつかバグがあることはわかっているので、

[27:19 - 27:24]
バグファインダーがバグを見つけてくれるかどうか見てみよう。これは

[27:24 - 27:29]
面白いアイデアだ。新しい実行。ああ、

[27:26 - 27:32]
それはダークモード用にもっと良い UI が必要だ。

[27:29 - 27:35]
とにかく 30,000 を追加したかな?

[27:32 - 27:37]
30,000行はおかしい。ちょっと待って、

[27:35 - 27:39]
30,000行あるんだ。変更を分析するために追跡するんだ。

[27:37 - 27:41]
何を言っているんだ。

[27:39 - 27:45]
これらのファイルすべてを変更したわけではない。何と

[27:41 - 27:47]
比較しているんだ。実行結果は$76。なんてことだ。

[27:45 - 27:49]
何かがおかしい。

[27:47 - 27:52]
そのボタンを押さないで。カードは$76になる。

[27:49 - 27:55]
おそらくバグは見つからないだろう。でもそれは何ですか。

[27:52 - 27:58]
ベース参照と比較しているに違いない。

[27:55 - 28:00]
ああ、これは元のメインだ。メインが欲しい。メインだけでいい。ほら、ほら、ほら、それが

[28:00 - 28:05]
私が変更したものだ。よし、素晴らしい。$3。

[28:04 - 28:09]
息を止めて、

[28:05 - 28:10]
科学の4つをやろう。後で連れて行って。

[28:09 - 28:13]
誰がバグを見つけたか教えて。かなり

[28:10 - 28:15]
すごいことだろう。もしこれが非常に難しい

[28:13 - 28:17]
問題で行き詰まっていて、$3で行き詰まっていたとしたら、

[28:15 - 28:19]
つまり、

[28:17 - 28:21]
問題を解決するのにさらに30分かかったとしたら、ほとんどの

[28:19 - 28:23]
プログラマーは1時間あたり6ドル以上稼いでいるので、

[28:21 - 28:26]
$3はかなりいいことだ。

[28:23 - 28:28]
これを解決するのに何時間もかかる可能性があるので、やらせてみよう。

[28:28 - 28:32]
元のコードにバグがあったことには気づかないだろう。 これは

[28:30 - 28:35]
変更を確認しています。

[28:32 - 28:36]
おそらく気付いていない人のために説明すると、これはメインを確認しています。

[28:35 - 28:39]
メインからの変更を確認しています。つまり、

[28:36 - 28:40]
私が新しいバグとして何をもたらしたかということです。

[28:39 - 28:42]
少し違った話をしましょう。

[28:40 - 28:44]
カーソルは素晴らしいと指摘しています

[28:42 - 28:45]
が、今日は

[28:44 - 28:47]
1時間

[28:45 - 28:49]
以上かけてリファクタリングするソリューションを生成しました。しかし、その後、

[28:47 - 28:50]
すべてを拒否して15分で修正しました。

[28:49 - 28:52]
他の作業には驚くほどうまく機能しました。100

[28:50 - 28:54]
%、そうする必要があります。時には、それが

[28:52 - 28:56]
脱線したときにそれをキャッチする必要が

[29:03 - 29:09]
あります。停止するように指示する必要があります。カーソルが行うもう1つのことは、大きな問題になる可能性があることです。それは、一瞬でも軌道から外れる可能性があることです。ステージ上で大勢の人に向けてライブデモを行っていたとき、

[29:06 - 29:11]
カーソルがReactでUIを追加することを示していましたが、

[29:09 - 29:14]
何らかの理由で、UIをReact

[29:11 - 29:16]
スタイルで適切に実行する代わりに、クリック時に追加され

[29:14 - 29:19]
、ドキュメントを実行し始めました。

[29:16 - 29:21]
要素を作成し、

[29:19 - 29:22]
命令型のJavaScriptを使ってDOMを作成します。

[29:21 - 29:24]
残念ながら、

[29:22 - 29:28]
カーソルやエージェントフローなどで

[29:24 - 29:30]
コードが追加され、それを確認します。

[29:28 - 29:33]
そして

[29:30 - 29:35]
次の更新時に、コードに

[29:33 - 29:36]
いくつかの非常に悪いプラクティスが含まれているため、それが

[29:35 - 29:38]
一種の真実の源となり、

[29:36 - 29:40]
そこから構築され続け、さらにドキュメントが追加されます。

[29:40 - 29:44]
ペンの子要素や

[29:42 - 29:46]
クエリセレクターなどをドキュメント化するために要素が作成されます。そして、それは

[29:44 - 29:48]
崖から落ちてしまいます。そのため、

[29:46 - 29:50]
それを止めなければなりません。何度も元に戻す必要があります。そのため、チェック

[29:50 - 29:55]
ポイントの復元ボタンを押してリセットし、

[29:53 - 29:56]
再試行することを忘れないでください。これがバグファインダーの仕組みです。

[29:55 - 29:58]
これらの

[29:56 - 30:00]
仮説的なバグが表示され、1つずつ受け入れることができます。これが1つです。何が

[30:00 - 30:04]
間違っているか、ゼロ値の扱いです。ああ、これは抜けています。

[30:03 - 30:07]
いつも私を悩ませているのは、

[30:07 - 30:11]
何かではなく、ゼロのような偽の値が

[30:08 - 30:14]
有効であるということを忘れていることです。つまり、実際には、

[30:14 - 30:17]
位置がz zになる可能性があるため、正当なバグである可能性が高いということです。

[30:16 - 30:19]
特に 自動レイアウトを使用していますが、うまくいきません。

[30:17 - 30:20]
実際にはよくあることかもしれません。

[30:20 - 30:26]
正しく考えれば、これをリセットして、

[30:23 - 30:28]
どこかにボタンがあります。Boot Fix Inc

[30:26 - 30:30]
Composer はすばらしいので、修正する必要があります。

[30:28 - 30:31]
次のものを見てみましょう。$3 で

[30:30 - 30:33]
問題がいくつか見つかり、将来多くの頭痛の種を省くことができます。関数は、

[30:35 - 30:41]
1 つのフレーム レイヤーだけでなく、すべてのノードをすべて返します。これは、

[30:38 - 30:44]
1 つのフレームが

[30:41 - 30:46]
間違っていたことを除いて、私たちが遭遇した問題でした。これが確信が持てませんが、まあ、そうしましょう。やってみましょう。これでうまくいくかどうか

[30:46 - 30:52]
調べてみましょう。AI なので、

[30:48 - 30:54]
$3 で解決するはずです。

[30:52 - 30:57]
これで問題が解決するかどうか見てみましょう。

[30:54 - 30:58]
これはかなり楽しいです。Cur と

[30:57 - 31:00]
作業するのは好きです。Claude と作業するのはイライラすることもあります。

[30:58 - 31:02]
誤解しないでください。

[31:02 - 31:05]
コーディングで経験した中で最もイライラすることもあります。

[31:04 - 31:07]
時々そうなることもありますが、最も楽しかったこともあります。

[31:05 - 31:09]
ものを作るのが好きです。目標が

[31:07 - 31:11]
構築して顧客に出荷すること以上のものである場合、

[31:09 - 31:13]
またはそれ以外の場合は

[31:11 - 31:15]
難しいかもしれません。 繰り返しますが、

[31:13 - 31:16]
企業が

[31:15 - 31:17]
ソフトウェア開発者としてあなたを雇う際にあなたに求めているのは、

[31:16 - 31:20]
悪いコードを書かず、

[31:17 - 31:22]
何かを壊さないことです。重要なのは、

[31:20 - 31:23]
より良い製品を顧客に提供し、最終的に

[31:22 - 31:26]
企業の収益を増やすことです。

[31:23 - 31:28]
それでは、

[31:26 - 31:29]
前回、使いたいクリップボードのようなものがあったときに戻りましょう。

[31:29 - 31:34]
今回は2つのフレームがあります。これは

[31:32 - 31:35]
進捗状況かもしれませんし、そうでないかもしれません。とにかく、

[31:34 - 31:37]
私がおそらく行うことは、

[31:35 - 31:39]
チャットで話していたことと同じです。おそらく、

[31:39 - 31:42]
これらすべてを完全に中止するでしょう。これは残念なことです。なぜなら、

[31:40 - 31:43]
私はUIの小さな変更をいくつか行ったからです。これは

[31:42 - 31:45]
私が強くお勧めするもう1つのことです。Claudeが

[31:43 - 31:47]
コードを編集する場合は、

[31:45 - 31:49]
そのコードも手動で更新しないでください。

[31:49 - 31:53]
後続のパスで変更が消去される可能性が高いためです。

[31:51 - 31:54]
これは完璧ではありませんし、いつか完璧になるかどうかはわかりませんが、

[31:56 - 31:59]
エージェントの実行に時間がかかることがよくあります。

[31:57 - 32:00]
他のファイルの場合は、別の作業に取り掛かります。

[31:59 - 32:02]
たとえば、Cloudがバックエンドで動作している場合などです。私は

[32:00 - 32:03]
微調整しています。 フロントエンドクラウドはこのコンポーネントに注力しています。

[32:02 - 32:05]
このUIを調整していますが、

[32:03 - 32:06]
問題が何であれ、

[32:05 - 32:07]
今私がいるよう

[32:06 - 32:09]
な状態、つまり「ちょっとめちゃくちゃになってしまった。

[32:07 - 32:11]
何も改善されていない」という状態になっている場合は、

[32:09 - 32:12]
コミットメッセージで確認したように、一部の機能を完全に書き換えただけで、改善は見られ

[32:11 - 32:14]
ませんでした。

[32:14 - 32:19]
空のフレームの後にも同じ問題が発生しました。変更内容をそのまま保存します。

[32:16 - 32:20]
ここで1つ言及したいことがあります。「

[32:20 - 32:25]
コーディングスキルを失うことを心配したことはありますか？」というコメントが寄せられまし

[32:34 - 32:41]
た。これは非常に有効な質問です。いくつかの角度から検討してみましょう。日々のコーディングのほとんどが、ボックスにプロンプ​​トを入力してAIがコードを書くのを見ているだけの場合、コーディングスキルにとって何を意味するのでしょうか？私の意見では、コーディングスキルを

[32:41 - 32:45]
維持または向上させるために、毎日一日中ソフトウェアを手動でコーディングする必要はないと思います。

[32:43 - 32:47]
実際、

[32:45 - 32:50]
コーディングスキルを「コードを使って

[32:50 - 32:53]
良い方法で良い製品を作ることができる」と定義するのであれば、

[32:52 - 32:55]
おそらく

[32:53 - 32:58]
ほとんどの企業が採用しているものと同じでしょう。

[32:55 - 32:59]
人を雇うときは、

[32:58 - 33:01]
良いコードで製品をさらに良くしてほしいと思っています。

[32:59 - 33:03]
悪い

[33:01 - 33:05]
コードになって大きな問題を引き起こすようなコードは欲しくありません。過剰に

[33:03 - 33:06]
エンジニアリングされたり、

[33:05 - 33:09]
完璧に仕上げられたコードも欲しくありません。コードを過剰に考えすぎたり、細心の注意を払って

[33:11 - 33:14]
問題を深く掘り下げようとしすぎて時間のかかる人を

[33:13 - 33:16]
雇うのは好きではありません。私はそういうことを好む人をたくさん雇ってきましたが、

[33:14 - 33:17]
多くの人はそれが自分のやるべきことだと思っていますが、それは間違い

[33:17 - 33:21]
なく会社が

[33:19 - 33:23]
あなたを雇う目的ではないでしょう。会社は

[33:21 - 33:25]
問題を解決するために良いコードを書くことをあなたを雇うのです。

[33:23 - 33:26]
スタックの領域によっては、

[33:25 - 33:28]
問題はより複雑になる可能性があるため、

[33:26 - 33:30]
時には問題を本当に深く掘り下げる必要があります。それが

[33:28 - 33:32]
実際には

[33:30 - 33:34]
非常に複雑な領域における深い課題である場合、

[33:34 - 33:39]
ボタンや UI コンポーネント、基本的な crud

[33:37 - 33:40]
API などに深く入り込みすぎてはいけません。過剰に

[33:39 - 33:42]
エンジニアリングしたり、考えすぎたりせず、

[33:40 - 33:43]
物事を終わらせて次のことに移ってください。

[33:42 - 33:44]
結局のところ、私たちは顧客の

[33:43 - 33:47]
ために素晴らしい製品を作ろうとしているだけなのですから、

[33:44 - 33:49]
AI はどのように役立つのでしょうか。AI は

[33:47 - 33:51]
自動化できます。 基本的な作業の多くは、

[33:49 - 33:53]
AIにフォント1つ、ピクセル1つを変更するように指示するのが好きではありません。

[33:53 - 33:57]
自分でやりたいのですが、これにより多く

[33:55 - 33:59]
の時間を節約できます。この時間から得られるのは

[33:57 - 34:01]
精神的なエネルギーです。コンポーネントの構成がどうなるかなど、基本的なことを考えるために頭を悩ませる

[33:59 - 34:04]
必要がなくなれば、1日に多くのことを実行

[34:07 - 34:11]
できます。難しい問題に集中して、

[34:08 - 34:13]
カーソルのコンポーザーを使用してこれらのUIを構築するようにAIに知らせることができます。

[34:11 - 34:15]
その後、

[34:13 - 34:16]
物事が難しくなったら、私が飛び込むことができます。

[34:15 - 34:18]
私の意見では、

[34:16 - 34:20]
製品全体をVibeコードで記述できる世界はありません。

[34:18 - 34:21]
誰もそれをやっているのを見たことがありません。

[34:20 - 34:23]
誰もできるようになることはないと思います。GPT

[34:21 - 34:25]
3.5やclod 37を見たことがあるかどうかはわかりませんが、

[34:23 - 34:27]
これらのモデルは

[34:25 - 34:29]
遅くなっています。6か月ほど前にこれに関するビデオを作成しましたが、

[34:27 - 34:31]
Open EYは

[34:29 - 34:32]
GPT3に圧倒され、世界最高の開発者全員が「

[34:32 - 34:36]
ご存知のとおり」と言っていました。 早口で何やら言い過ぎで、

[34:34 - 34:37]
4.5が登場して、

[34:36 - 34:40]
3つのSavが登場すると、人々は「

[34:37 - 34:41]
いや、03はどこだ？」「わからないな」と言う。

[34:40 - 34:43]
これらのツールは短期間でそれほど良くなるとは思えない。確かに、

[34:43 - 34:46]
彼らは成長していると思うし、

[34:45 - 34:48]
Sカーブがさらにいくつか見られるかもしれない。03は

[34:46 - 34:49]
大きな急上昇になるかもしれないが、いずれまた横ばいになる。それが

[34:48 - 34:51]
テクノロジーというもので、

[34:49 - 34:53]
永遠に上昇し続けることはない。上昇し続けると

[34:51 - 34:55]
思いたくなるが、そうはならない。

[34:53 - 34:58]
だから私の意見では、永遠に

[34:58 - 35:00]
コードを修正したり、手動で実装したりする必要がある。コーディングの

[34:59 - 35:02]
仕方が全くわからない場合、

[35:00 - 35:03]
デバッグの仕方がわからない場合、これらは身に

[35:02 - 35:05]
付けるべき良いスキルであり、身に付けるべきだ。

[35:03 - 35:06]
なぜなら、

[35:05 - 35:08]
VIコーディングで行き詰まり、自分で問題を解決しなければならないからだ。誰もコーディングの

[35:08 - 35:11]
スキルを持っていない場合、彼らは自分で解決するか、

[35:10 - 35:13]
誰かに助けを求める必要がある。私の

[35:11 - 35:15]
妻はコーディングブートカウントを終えたばかりだ。AIは

[35:15 - 35:18]
できるだけ使わないようにすることをお勧めします。学ぶ必要があるからだ。

[35:16 - 35:20]
まず、AIが最も役立つのは上級

[35:18 - 35:21]
開発者だと思います。ですから、誰にできる最善のことは、

[35:21 - 35:25]
できる限り多くの開発スキルを学び、

[35:23 - 35:26]
AIに助けてもらうことです。しかし、実際に

[35:25 - 35:27]
コードの操作方法を知っておく必要があります。コードを

[35:26 - 35:29]
操作している限り、コーディングスキルを磨き続けていると言えるでしょう。

[35:27 - 35:30]
私は、Vibe Codeで何かをコーディングする方法をまだ見つけていませんが、

[35:30 - 35:33]
コーディングスキル、そして

[35:32 - 35:35]
最も重要なのは、

[35:33 - 35:37]
生産性と効率性を高めていると言えるでしょう。私は、

[35:37 - 35:41]
カーソルをうまく使いこなす開発者を雇いたいです。

[35:39 - 35:42]
何でも手作業でカットする開発者よりも。できるだけ

[35:41 - 35:44]
無駄なく、効率的に作業する開発者を求めています。

[35:44 - 35:49]
毎日8時間もかけて難しい問題を解決することはできません。4

[35:49 - 35:54]
時間かけてUIをVibe Codeでコーディングし、残りの2時間で本当に

[35:51 - 35:55]
難しい問題を手作業で解決すれば、

[35:54 - 35:57]
最終的にはより多くの成果を上げることができます。

[35:55 - 35:59]
今日では、多くの人にとって理想的なワークフローだと思います。

[35:57 - 36:01]
作業内容にもよりますが、

[36:01 - 36:05]
ここではフロントエンド開発とフルスタック開発について多くを語っています。とにかく、

[36:03 - 36:07]
全体的に見て、カーソルは素晴らしいツールです。

[36:05 - 36:08]
オートコンプリートだけを使用していると、

[36:07 - 36:10]
おそらくその魅力を逃していることになります。

[36:08 - 36:12]
エージェント機能を試したり、他の

[36:10 - 36:14]
エキサイティングな機能を試したり、型に慣れたりしてみてください。 うまく機能する

[36:12 - 36:15]
ワークフロー、

[36:14 - 36:17]
エージェントでうまく機能するもの、テストに適したもの、

[36:17 - 36:20]
ビルド コマンドを自動実行するもの、そしてもちろん

[36:18 - 36:23]
特定の種類の問題の場合、

[36:20 - 36:25]
これらの機能を使用しようとせず、すぐに作業に取り掛かり、

[36:23 - 36:27]
全体を手動でコーディングします。

[36:25 - 36:28]
ときには、ちょっとした作業の

[36:27 - 36:30]
ために K コマンドをインラインで使用することもあります。CLA が

[36:30 - 36:34]
コードに干渉しないようにしたい場合もあります。

[36:32 - 36:35]
多くのポジションがあり、

[36:34 - 36:37]
一般的に試行錯誤する必要があるためです。AI

[36:35 - 36:40]
にフィードバックすることを忘れないでください。

[36:37 - 36:42]
継続的にワンホットな操作を試してください。

[36:42 - 36:47]
他のすべてが失敗した場合は、Dash で回避してください。とても

[36:45 - 36:50]
楽しかったです。ご参加いただきありがとうございました。とても楽しかったです。

[36:50 - 36:56]
毎週金曜日の朝に配信しようとしているので、

[36:52 - 36:58]
太平洋時間の午前 9 時 30 分頃に配信できればと思っています。

[36:56 - 37:00]
来週もぜひご覧ください。同じ時間になるよう努めています。そうでなければ、

[36:58 - 37:03]
皆さん、どうもありがとうございました。それではまた。

## コメント

### 1. @nicholasprice5137 (👍 43)
For writing excellent unit tests with AI ala TDD, you might also consider:

-doing only one small implementation/feature at a time; the smaller it is, the better the LLM output will be. If you have trouble thinking of how to break the problem up, use a reasoning model like DeepSeek or o3-mini. 

-follow Dave Farley’s recommendations regarding how to write tests, and in particular, unit tests. Essentially, you should make sure the tests test some sort of outcome or functionality, NOT any particular implementation. You can then write these test-generation instructions into a cursor rule that you invoke when having AI draft tests. 

-after a model has written a test, use a separate model to evaluate/critique that test and ask the other model what kinds of things it might be missing, or whether those are actually good unit tests given the goal. Make sure the second model also knows the TDD philosophy of Dave Farley, mentioned above (i.e. don’t merely test implementation). 

-then you can finally have the model actually write those tests in your codebase, and you can then have it YOLO mode for just passing one test at a time. If something goes wrong, go back to prior commit via GH, or restore version via cursor, or go back version via VS Code. 

-make sure to commit after each successful implementation. 

Rinse and repeat!

If anyone else has any other suggestions or tweaks, let us all know!!

> **@nicholasprice5137** (👍 0): Amazing and practical content, per usual. I love this channel and now not-pushy you are about your product.

> **@stevenbraun918** (👍 1): gold thank you

> **@WellVan-w2y** (👍 1): golden rules to be followed

### 2. @nwsome (👍 17)
This is one of the most useful channels on YouTube. Keep up the great work!

### 3. @lookingoffswitch4344 (👍 5)
Steve, I spent 16 years as a dev on both the Visual Studio and Xcode teams. I absolutely agree with your thoughts on future improvements and how the meaningful the saved mental energy can be. I feel like I'm solving harder problems more quickly with Cursor (most of the time).

### 4. @djosefandersson7605 (👍 27)
In case you wonder the prompt for Yolo:

any kind of tests are always allowed like vitest, pnpm test, also build commands, tsc, etc. For file/folder operations, specifically allow: mkdir *, touch *, echo * > *, vim *, rm -rf *, cp *, mv *. Also allow package management commands like npm/pnpm/yarn install/add/remove *, and git commands like git add/commit/push/pull/checkout/branch *.

> **@guddisAlex** (👍 6): the actual prompt he is using is that: 

any kind of tests are always allowed like vitest, npm test, nr test, etc. also basic build commands like build, tsc, etc. creating files and making directories (like touch, mkdir, etc) is always ok too

 (can be read on his blog and be careful with the prompt above and using those wildcards)

> **@DanielSerodio** (👍 0): Are these commands executed within a VM?
I'm wary of allowing `rm -rf *` if it's not isolated, because a mistake could wipe out files outside the code workspace.

> **@hyperstarter** (👍 0): YOLO mode isn’t on cursor anymore?

> **@bet__ai** (👍 0): @@hyperstarter Now the name is "Enable auto-run mode"

### 5. @mark_rios (👍 0)
Steve, don't get me wrong, Build is great, but no one is looking for a simple solution. 
Everyone is creating this website generator, which is cool but doesn't turn out exactly how we want it to. 
And it gets worse when you've created a design in Figma and you can't faithfully transfer it to the way you designed it. 

The big difference is to faithfully transfer the entire project, structured in code (HTML, CSS, React, Talwing) in short, in code and transfer it to Cursor. 
That, yes, is an incredible difference. And since Cursor doesn't have a visual editor like Builder (a solution for beginners) or designers can fully develop their projects, you would integrate it within Cursor. In this case, you would stand out from the crowd, this, yes, is a valuable solution, you could transfer codes from Figma Design, Make and especially Figma Sites. 

Think about it. 
I like your work. 

Thanks for this video.

### 6. @ricko13 (👍 8)
Steve, I think if you're into Cursor you are going to love Cline. Their Plan/Act mode works like a charm and it's pretty awesome.  I have no idea how they pull it off but you have to try it

> **@megamehdi89** (👍 1): Cline is great

> **@nishilbhave3555** (👍 3): It works very well because its expensive. It uses a huge amount of tokens, sending a lot of context to the AI model. Due to this, the results are great.

> **@jackrobert-h4z** (👍 0): I want to do my project do you think cline will be better than cursor and is it also 20 dolar ​@@nishilbhave3555

### 7. @johnnysitu (👍 1)
I have a feeling either builder is gonna turn into figma one day, or vice versa. Good job Steve!

### 8. @bubsztyn (👍 25)
No wonder builderio is buggy if your senior engineers are vibe coding on yolo mode

### 9.  (👍 0)
Steve, another great tutorial 🙏 (I called it a tutorial because it exceeds any tip's limitation). We are close to writing apps without adding test cases because AI can analyze, test if needed, and correct our code. Keep up your great work!

### 10. @mitchellrcohen (👍 3)
Dude. So smart. Thank you endlessly

### 11. @juanbetancourt5106 (👍 0)
Cursor is the king of new projects, it might be interesting if you consider some aproach on Augment for refactoring, in my case it reach 80% of cursor results but with 20% of time for cursor case

### 12. @dawid_dahl (👍 0)
Awesome video! Would love more content like this.

### 13. @13kgOfPersimmon (👍 8)
hi Steve
recently you gave good feedback for claude-3.7. are you actually using it now? what model are you actually using at work?
i noticed that claude 3.7 seem smarter at first look, but when doing tasks it goes full rogue ignoring rules and instructions, breaking more stuff than creating, and adding alot of irrelevant changes.

also could you please make a more detailed guide on cursor rules and notebooks? what are the best practices? fe does it make sense to build instruction pipelines for complicated tasks?

### 14. @nickwoodward819 (👍 8)
Tests: "DW guys, the fox told me the hen house is safe"

### 15. @000zeRoeXisTenZ000 (👍 0)
The thing with the unpredictable tab-behavior is that auto-complete only works for a limited amount of characters/lines. It can only operate in the space around the position of the cursor, or jump to other lines with possible edits.

### 16. @chompnn (👍 0)
Amazing!!! I’ve started canceling all my no code platforms ever since I’ve started vibe coding and using cursor!

### 17. @hyunjae-m1c (👍 2)
You said AI needs information. Tips: before you start promting target the folders that needs and make him study first. And then do your prompt. It is 10× better

### 18. @alihesaridev (👍 0)
Yo Steve, appreciate the video! 🔥

### 19. @mouzarimusic (👍 0)
Bro, what you said is great, but you don’t need to repeat that TDD instruction every time in your prompt! 
Cursor actually lets you set Project Rules under the “Rules” tab. Just add something like:

"Always follow Test-Driven Development: write tests first, then iterate on the code until all tests pass."

After that, Cursor will automatically apply it to every code generation inside that project, no need to type it again. Total game changer if you’re building smart assistants or scalable backends.
Try it out and let your AI do the heavy lifting the right way

### 20. @dzzlucas (👍 0)
te quiero mucho capo!

