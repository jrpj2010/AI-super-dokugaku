# How to Use Cursor Agent and Supabase to Maximize Productivity!

**チャンネル:** Supabase
**公開日:** 2025-02-26
**URL:** https://www.youtube.com/watch?v=6eUL1Wo9ZRc

## 説明

Cursor agent is taking the world by storm by allowing developers and builders to ship at record time! Combining it with Supabase, anyone can build a fully functional app with a scalable backend!

Learning and utilizing various tools around Cursor and Supabase is key to creating an efficient app development workflow. We will take a look at how we can use MCP, Supabase CLI, Cursor rules, giving Cursor Agent a screenshot, and many other techniques that could be used to streamline building modern, beautiful apps with the power of AI. 

Pre-built Cursor rules: https://supabase.com/docs/guides/getting-started/ai-prompts
Local development with Supabase CLI: https://supabase.com/docs/guides/local-development
Postgres MCP server: https://github.com/modelcontextprotocol/servers/tree/main/src/postgres

CHAPTERS:
00:00 Intro and outline
00:28 Start creating a frontend
01:07 Using Claude to generate instructions
05:17 Create a UI from a screenshot
09:50 Spinning up local Supabase instance
13:35 Setting up the tables
15:58 Connecting the app to local Supabase
18:37 Updating the schema to fix a UI issue
24:09 Intro to MCP to give database schema to the agent
28:47 Secure the app with RLS
34:21 Push the migration to the cloud version of Supabase

💻 Videos to watch next:
▶ https://youtu.be/9z54zkmK-to?feature=shared
▶ https://youtu.be/GFxOwNiioT0?feature=shared
▶ https://youtu.be/nEyTgo4l_eI?feature=shared

👇 Learn more about Supabase 👇

🕸 Website: https://supabase.com/
🏁 Get started: https://app.supabase.com/
📄 Docs: https://supabase.com/docs

🔔 Subscribe for more tutorials and feature updates from Supabase: https://www.youtube.com/channel/UCNTVzV1InxHV-YR0fSajqPQ?sub_confirmation=1

📱 Connect with Us:
🐙 Github: https://www.github.com/supabase 
💬 Discord: https://discord.supabase.com/
🐦 Twitter: https://www.twitter.com/supabase/
▶ Instagram (follow for memes): https://www.instagram.com/supabasecom/ 


ABOUT SUPABASE:
Supabase is the open source Firebase alternative. Supabase provides a full Postgres database for every project with pgvector, backups, realtime, and more. Add and manage email and password, passwordless, OAuth, and mobile logins to your project through a suite of identity providers and APIs.

Build in a weekend, scale to millions.

#Supabase #AppDevelopment #DeveloperTools

## 字幕

[00:02 - 00:06]
コーディングを支援するだけでなく、

[00:04 - 00:08]
データベースを理解し、ベスト

[00:06 - 00:11]
プラクティスに従い、これまでにないほど生産性を向上させるAIシステムを想像してみてください。

[00:08 - 00:13]
今日、私たちは

[00:11 - 00:15]
カーソルAIエージェントのパワーをスーパー

[00:13 - 00:17]
ベースと組み合わせることで、

[00:15 - 00:19]
ベテラン開発者でも初心者でも、アプリ開発をこれまで以上に簡単に行えるように

[00:17 - 00:22]
します。

[00:19 - 00:24]
カーソル領域の仕組み、それらを

[00:22 - 00:27]
スーパーデータベースに接続する方法、そして

[00:24 - 00:30]
ユーザーが使用できる美しいアプリの構築方法を説明します。

[00:27 - 00:30]
それでは始め

[00:30 - 00:34]
ましょう。まずはフロントエンドの作成から始めましょう。

[00:32 - 00:36]
カーソルはすでに開いていますが、作業用の

[00:34 - 00:40]
ディレクトリを開きましょう。ファイル > フォルダを

[00:36 - 00:44]
開くに移動し、

[00:44 - 00:49]
開発ディレクトリを選択します。

[00:46 - 00:50]
ここに新しいフォルダを作成します。カーソル名を「

[00:50 - 00:53]
cursor

[00:54 - 01:00]
next」にして「開く」をクリックします。これで

[00:58 - 01:04]
ディレクトリができたので、

[01:00 - 01:06]
コマンドIを押してComposerを開き

[01:04 - 01:08]
、開発を開始できます。

[01:06 - 01:11]
しかし、すぐにプロンプ​​トを書くのではなく、

[01:11 - 01:17]
AIエージェントから始めるのが好きです。チャットCPTクラウド

[01:15 - 01:19]
私はクラウドを使うのが好きです。

[01:17 - 01:21]
一般的に、クラウドの方がアプリケーション開発の成果が向上するように感じるからです。

[01:23 - 01:30]
サンプルプロンプトから始めましょう。ここでは、

[01:33 - 01:38]
現在の作業ディレクトリ内に NextJS アプリケーションを開発したいと Cloud に指示しています。

[01:36 - 01:40]
また、デフォルトの NextJS アプリに付属

[01:38 - 01:43]
する初期の定型コードを削除するように指示しています。NextJS が

[01:43 - 01:48]
何かご存じない方のために説明すると、NextJS はおそらく今日の

[01:45 - 01:51]
Web アプリケーション開発で最も人気のある方法です。

[01:48 - 01:53]
そして、

[01:51 - 01:56]
私が追加したこれらの機能の中には、TypeScript と

[01:53 - 01:58]
Tailwind があります。これらも非常に人気のある

[01:56 - 02:00]
テクノロジーで、

[02:00 - 02:05]
NextJS と TypeScript と Tailwind を使えば間違いありません。これらは最近の

[02:03 - 02:07]
アプリ開発で主流のテクノロジーです。

[02:05 - 02:09]
最後に、

[02:07 - 02:12]
出力は Markdown 形式にする必要があると指示しています。[

[02:09 - 02:13]
送信] をクリックすると、一連の指示が生成されます。これを

[02:13 - 02:20]
Curser Agent に渡すことで、

[02:17 - 02:24]
最小限の NJS アプリケーションがセットアップされ、

[02:20 - 02:24]
すぐに作業を開始できます。[コピー先] をクリックして

[02:30 - 02:35]
指示全体をコピーし、そこに貼り付けます。

[02:32 - 02:36]
一番下までスクロールします。[コピー先] は

[02:35 - 02:39]
不要です。最後に、[

[02:36 - 02:43]
説明しましょうか] などです。  blahの

[02:39 - 02:48]
部分を削除して、末尾の

[02:43 - 02:50]
3つのドットとカンマを削除できます。また、

[02:48 - 02:52]
上部の「ステップバイステップのガイドを提供します」という部分も削除できます。

[02:52 - 02:58]
これでうまくいくはずです。

[02:55 - 03:00]
この指示をCurser Agentに渡すことができます。

[03:00 - 03:06]
通常モードではなくアジアモードが選択されていることを確認し、「

[03:11 - 03:16]
送信」をクリックします。表示される指示はすべて受け入れます。

[03:16 - 03:21]
これらのプロンプトでは、

[03:18 - 03:25]
カーソルが危険な動作をすることは期待できませんが、

[03:21 - 03:28]
Curser Agentには

[03:28 - 03:34]
受け入れるかどうかのオプションがあります。

[03:30 - 03:37]
この段階に達したら、受け入れる必要があります。

[03:34 - 03:40]
基本的に、コードをソースディレクトリ内に置くかどうかなど、いくつかの項目を選択する必要があります。Returnキーを

[03:45 - 03:51]
何度も押してデフォルトの

[03:48 - 03:53]
選択肢を使用することもできます。デフォルトの選択肢は常に

[03:51 - 03:56]
最適です。必ずしも必要ではありませんが、この

[03:53 - 04:00]
場合はこれで十分です。

[03:56 - 04:02]
ほとんどの人が選択するものです。それで

[04:00 - 04:05]
今はCurser Agentは nextjs コマンドを実行して、

[04:02 - 04:10]
すべてのスポイラー

[04:05 - 04:13]
プレート コードを設定し、それが完了すると、

[04:10 - 04:15]
2 番目の指示の処理に進みます。

[04:13 - 04:18]
これは、すべての弾丸プレート コードを削除することです。

[04:18 - 04:24]
ええ、それは

[04:22 - 04:28]
本当に扱いたくない大量の混乱である

[04:24 - 04:30]
ため、すべてをシンプルにしたいので、

[04:30 - 04:37]
ページ上の大量のコードを削除しました。  TSX ファイルと

[04:34 - 04:40]
レイアウト。  TSX ファイルでは、

[04:37 - 04:43]
最初から存在する CSS スポイラー プレートも処理され、

[04:43 - 04:48]
未使用の

[04:49 - 04:54]
画像がいくつか削除され、最後に

[04:52 - 04:56]
アプリケーションをローカルで実行するためのターミナル コマンドが表示されます。

[04:56 - 05:03]
アプリケーションが起動して

[04:59 - 05:05]
実行されると、これをクリックして開いて

[05:03 - 05:10]
アプリケーションの動作を確認できます。

[05:05 - 05:14]
美しいアプリケーションができました。エラーが 1 つありますが、

[05:10 - 05:17]
今のところは問題ないと思います。アプリケーションはきれいに

[05:14 - 05:19]
表示されています。

[05:19 - 05:23]
操作できる空のアプリケーションができたので、カーソル エージェントに

[05:21 - 05:25]
美しい UI を構築してもらいます。そのためには、

[05:25 - 05:30]
画像をカーソル エージェントにドラッグ アンド ドロップします。Dribble に移動して、

[05:28 - 05:33]
いくつかのアイデアを参照します。

[05:30 - 05:34]
シンプルな Web アプリケーションを検索しましたが、

[05:33 - 05:39]
この最初の

[05:34 - 05:39]
デザインが気に入ったので、スクリーンショットを撮って、ここに持ってきます。

[05:39 - 05:47]
新しい

[05:43 - 05:50]
カーソル コンポーザー ウィンドウを開いて、ドラッグします。

[05:47 - 05:55]
そこにドラッグします。アジア モードになっていることを確認し、

[05:50 - 05:58]
カーソルにこのデザインを再作成するように依頼します。

[06:00 - 06:06]
現在のページにタグを付けることができるので、

[06:03 - 06:09]
カーソルに現在のページ (つまりページ) に作成するように依頼できます

[06:06 - 06:12]
。  Source slapp の下にある TSX ファイルを選択して [

[06:14 - 06:20]
送信] をクリックします。Cursor Agent が

[06:17 - 06:21]
コードベース内を検索して、

[06:20 - 06:23]
何が起こっているか、どのようなコンポーネントが

[06:21 - 06:27]
既に存在し、どのようなコンポーネントが

[06:23 - 06:30]
存在しないのかを分析し、

[06:27 - 06:32]
現在

[06:30 - 06:35]
このプロジェクトに存在しないものをインストール

[06:32 - 06:38]
していることに注意してください。このコマンドによって、使用可能なアイコン

[06:35 - 06:41]
と、ダッシュボードを

[06:38 - 06:43]
再作成するために使用できるチャートライブラリがインストールされました。

[06:41 - 06:45]
私の経験では、画像をアップロードして

[06:43 - 06:49]
Cursor Agent に

[06:45 - 06:51]
コードでそのデザインを再作成させるのにかなり時間がかかるので、

[06:51 - 06:59]
1、2 分ほど待てば完了すると思います。ようやく作成できまし

[06:54 - 07:02]
た。

[06:59 - 07:03]
見栄えが良くなるはずです。

[07:02 - 07:07]
すべてが完了したら、簡単に確認してみましょう。生成された

[07:03 - 07:10]
ので、

[07:07 - 07:13]
戻って美しいアプリケーションを確認できます。

[07:10 - 07:16]
この素敵な

[07:13 - 07:19]
アニメーションも作成されました。

[07:16 - 07:22]
作成された UI には非常に感銘を受けました。[

[07:19 - 07:24]
例外をすべて削除] をクリックします。

[07:22 - 07:25]
この時点で、スーパー ベース コードの作成をほぼ開始できます

[07:24 - 07:28]
が、その

[07:25 - 07:30]
前にいくつかクリーンアップを行いましょう。ソース コードで気付いたことの 1 つは、

[07:28 - 07:33]
これらの

[07:30 - 07:35]
データの多くはハードコードされています。つまり、

[07:33 - 07:38]
コードベース内に文字通り入力されているだけです。

[07:35 - 07:41]
例えば、ここにあるクレジットカード

[07:38 - 07:42]
番号は、静的なHTMLに入力されている

[07:41 - 07:45]
だけです。

[07:45 - 07:51]
コード内でこの値を更新する効率的な方法はあり

[07:49 - 07:54]
ません。これは、

[07:51 - 07:57]
後でsuperを追加するときにうまく機能しません。

[07:54 - 07:59]
クリーンアップは後で、または今すぐ行うことができますが、

[07:57 - 08:02]
今すぐ実行しましょう。

[07:59 - 08:04]
コードベースは、簡潔な状態で変更する方が常に良いからです。

[08:02 - 08:07]
新しいカーソルウィンドウを開きます。これが

[08:07 - 08:12]
使用できるマジックプロンプトです。カーソルに、変数と思われる

[08:10 - 08:15]
ものを抽出して

[08:15 - 08:20]
別のファイルに保存するように指示します。これを

[08:17 - 08:23]
hersと呼びます。これは

[08:20 - 08:26]
Reactのコンテキストでよく使用される用語ですが、

[08:26 - 08:31]
すべての値を個別の変数として抽出して、

[08:28 - 08:33]
扱いやすくすることを意味します。

[08:33 - 08:38]
送信しましょう。Cはページ内で見つかるすべての変数をリストし

[08:38 - 08:46]
、それらを抽出します。  「

[08:43 - 08:50]
use Financial data」と呼ばれるファイル。

[08:46 - 08:53]
TS は次のようになります。

[08:50 - 08:55]
基本的に、これらすべての変数が

[08:53 - 08:58]
抽出され、アプリケーションによって変更できます。

[08:55 - 09:00]
後で

[08:58 - 09:02]
実際にスーパーベースを追加するように要求すると、

[09:02 - 09:07]
スーパーベースからすべての値が取得され、

[09:04 - 09:08]
それらの値がこれらの変数の値として挿入されます。

[09:10 - 09:17]
ページも変更されると思います。  TSX ファイルを作成して、先ほど作成した

[09:14 - 09:20]
使用済み財務データ フックを実際に使用できるようにします。これで

[09:21 - 09:27]
完了です。

[09:24 - 09:31]
良さそうです。試してみましょう。

[09:27 - 09:33]
更新すると、すべてのデータがまだそこにあります。

[09:31 - 09:36]
この

[09:33 - 09:41]
使用済み財務データに変更を加えると、たとえば

[09:36 - 09:44]
3 月に大幅な増加が見られます。

[09:41 - 09:46]
ページを更新すると、

[09:44 - 09:48]
3 月にその大きな増加が見られるため、

[09:46 - 09:51]
変数がアプリケーション内に反映されていることがわかります。これで

[09:51 - 09:55]
Super Base を開始する準備ができたと思います。

[09:52 - 09:58]
データベースに移動できます。

[09:55 - 10:01]
新しいスーパーベースプロジェクトを作成するか、

[09:58 - 10:04]
スーパーベースCLIを使用して

[10:01 - 10:06]
スーパーベースプロジェクトをローカルで起動することもできます。

[10:04 - 10:08]
つまり、プロジェクトは自分のマシン上に置かれます。スーパーベースのインスタンスの

[10:06 - 10:10]
ローカルバージョンを使用する利点は数多くあります。これについては

[10:10 - 10:15]
後で説明します。

[10:13 - 10:16]
カーソルエージェントにローカルのスーパー

[10:15 - 10:20]
ベースインスタンスを作成させましょう。

[10:16 - 10:22]
ファイルを参照する必要はありません。カーソルにローカルでスーパーベースを設定するように指示します。

[10:22 - 10:26]
基本的にはスーパーベースCLIを使用します。

[10:30 - 10:36]
まず、

[10:32 - 10:36]
スーパーベースinitコマンドを実行しようと

[10:41 - 10:50]
します。これを実行し、リターンキーを押して

[10:46 - 10:53]
これらの

[10:50 - 10:56]
パッケージのインストールを受け入れます。VSコード設定やDoo設定を生成する必要はありません。

[10:56 - 11:03]
すべてリターンキーを押して完了です。

[11:00 - 11:06]
これで、ここにスーパーベースディレクトリが作成され、

[11:03 - 11:08]
さまざまな設定ファイルなどがありますが、

[11:08 - 11:13]
今は特に触る必要はありません。次に

[11:11 - 11:16]
進みましょう。ローカルのスーパーインスタンスを

[11:13 - 11:19]
起動するスーパー再起動コマンドを実行しようとします。

[11:16 - 11:23]
実行する

[11:19 - 11:23]
と

[11:25 - 11:30]
エラーが発生します。たくさんの

[11:28 - 11:34]
エラーが発生しています。 それを解決しようとしています

[11:30 - 11:36]
が、実際にはここで停止しましょう。ker は、

[11:38 - 11:43]
マシンで Docker が実行されていないため、super be Star コマンドの実行に失敗したためです。Docker は、

[11:41 - 11:45]
開発者がアプリをパッケージ化して

[11:43 - 11:47]
実行するために必要なすべてのものを提供するために使用

[12:01 - 12:06]
するツールです。これにより、自分のマシンでもサーバー上でも、同じように実行できます。インストール後は、クリックするだけで暗いデスクトップが開きます。微調整する必要がある構成は一切ありません。バックグラウンドで実行するだけです。Docker が実行されているので、先ほどと

[12:03 - 12:06]
同じプロンプトをもう一度実行してみ

[12:07 - 12:12]
ましょう。

[12:10 - 12:14]
このディレクトリが作成されたことがわかったと思いますが、念のため

[12:12 - 12:16]
実行しているだけなので、

[12:14 - 12:20]
害はありません。同じプロセスを実行するだけで、

[12:16 - 12:22]
superbas CLI はそれが

[12:20 - 12:25]
すでに存在していることを認識しているため、

[12:22 - 12:29]
何もしませんが、Super Star コマンドに到達しました。

[12:25 - 12:29]
これを実行すると、

[12:29 - 12:35]
super base のローカルインスタンスが起動します。

[12:35 - 12:41]
初めて実行する場合は、かなり時間がかかる可能性があります。

[12:38 - 12:43]
さまざまな要因に応じて数分かかる場合があります。

[12:41 - 12:47]
これはあなたのマシン上で起こっていることです

[12:43 - 12:49]
が、そこに座って

[12:47 - 12:52]
コーヒーでも飲んで数

[12:49 - 12:55]
分後に戻ってくると起動しています。

[12:52 - 12:58]
上にスクロールすると、

[12:55 - 13:02]
Super Baseのローカルインスタンスに関するさまざまな情報が表示されます。P

[12:58 - 13:05]
URLが表示され、Anonキーを見つけることができます。

[13:02 - 13:09]
このStudio URLをコピーして貼り付けるか、

[13:05 - 13:12]
クリックするだけで、

[13:09 - 13:16]
Super Baseダッシュボードが開きます。これは

[13:12 - 13:19]
基本的に、クラウド版のSuper Baseで見たことのあるダッシュボードです。

[13:19 - 13:23]
このダッシュボードの良いところは、

[13:21 - 13:25]
Super Baseのローカルバージョンなので

[13:23 - 13:28]
安全な環境だということです。好きな

[13:28 - 13:33]
テーブルを作成したり、好きなデータを削除したり、

[13:31 - 13:36]
Super Baseのすべてをテストしたりできます。

[13:33 - 13:38]
これでローカルのSuper Base

[13:36 - 13:40]
インスタンスが稼働しているので、

[13:38 - 13:42]
アプリケーションをSuper Baseインスタンスに接続します。

[13:40 - 13:45]
新しいComposer

[13:42 - 13:47]
ウィンドウを開き、

[13:45 - 13:50]
このアプリケーションに必要なテーブルを作成するようにカーソルに指示します。

[13:47 - 13:52]
このプロンプトで、カーソルに

[13:50 - 13:55]
Super CLIの移行コマンドを実行するように指示します。

[13:52 - 13:57]
この移行コマンドは、

[13:55 - 14:00]
Super Base

[13:57 - 14:02]
ディレクトリ内に新しい移行ファイルを作成します。 移行ファイルが作成される

[14:02 - 14:06]
と、データベース内でどのような更新が行われたかを追跡する単純なファイルです。

[14:06 - 14:13]
カーソルに、

[14:13 - 14:18]
この使用済み財務データ内に存在するデータを保持できるテーブルを作成するように要求しています。  TS

[14:16 - 14:21]
ファイルを作成し、テーブルが作成されたら、

[14:23 - 14:27]
このアプリケーション内で読み込むために使用できるサンプル データである C データを作成するように指示します。

[14:25 - 14:31]
最後に、

[14:27 - 14:34]
カーソルに superbase database reset を実行するように指示します。これにより、

[14:34 - 14:42]
作成されたすべてのサンプル データを取得できるようになります。

[14:36 - 14:47]
そのコマンドを実行するために use MPX を追加します。

[14:42 - 14:49]
実行してみましょう。

[14:47 - 14:51]
最後に追加した use MPX ビットは、superbase コマンドを

[14:49 - 14:54]
実行する方法がいくつかあることを意味します。

[14:51 - 14:57]
先頭に MPX があると、

[14:59 - 15:04]
superbase CLI のインストール プロセスを経ずに superbase コマンドを実行できます。

[15:02 - 15:07]
簡単に言うと、MPX バージョンを使用する方が簡単です。

[15:04 - 15:10]
それでは、

[15:07 - 15:13]
superbase Migration

[15:10 - 15:15]
new を実行し、財務データ テーブルという名前を付けて、

[15:15 - 15:20]
この移行ファイルを作成しました。この

[15:18 - 15:24]
移行ファイルは super CLI によって作成されたもので、

[15:27 - 15:33]
アプリ内にあるすべてのデータを保持するためにこれらのテーブルを多数追加しています。

[15:29 - 15:37]
また、C も作成しています。

[15:33 - 15:40]
superv ディレクトリ内の SQL ファイルには

[15:37 - 15:45]
サンプル データがいくつか保持されています。すべて問題ないと思います。

[15:40 - 15:49]
すべてを受け入れて

[15:45 - 15:53]
コマンドを実行しましょう。これには 1 分ほどかかる場合があり

[15:49 - 15:55]
ます。アプリ自体は

[15:53 - 15:57]
まだ superbase に接続されていませんが、

[15:55 - 15:59]
superbase ダッシュボード内ですべてのデータを表示できます。

[15:57 - 16:01]
コードを更新して、アプリが

[15:59 - 16:04]
superbase インスタンスからデータをロードできるようにします。

[16:01 - 16:08]
このプロンプトでは、

[16:04 - 16:11]
カーソルに superbase からデータをロードするように求めています。また、

[16:14 - 16:18]
カーソルがサブベース データベース内にどのようなテーブルがあるか認識できるように、テーブル構造の SQL ファイルも提供しました。

[16:18 - 16:24]
まず、

[16:27 - 16:33]
このアプリケーション内でデータをロードするための正しいライブラリである superbase JS をインストールするように求められます。これで、

[16:33 - 16:40]
これらのデータをロードするための環境変数が生成されました。これは

[16:37 - 16:43]
正しい環境変数であり、

[16:40 - 16:45]
プレースホルダーやランダム値ではないので

[16:43 - 16:48]
問題ないはずです。これで新しい superb が生成されました

[16:45 - 16:51]
。  TS ファイルは

[16:48 - 16:53]
環境変数を読み込み、

[16:51 - 16:56]
スーパーベースのクライアント ライブラリを初期化します。このライブラリは、

[16:56 - 17:01]
サブデータベースからデータを取得するために必要なものです。次に、

[16:59 - 17:05]
使用されている財務データ フックを更新して、

[17:05 - 17:13]
実際にスーパーベースからデータを読み込むことができるようにします。

[17:13 - 17:19]
一見すると問題なさそうです。承認する前にいつでもテストできます。

[17:19 - 17:24]
アプリに戻って

[17:21 - 17:28]
更新すると、アプリが

[17:24 - 17:32]
読み込まれているように見えます。エラーが 1 つあります。通常、この

[17:28 - 17:36]
ハイドレーション失敗エラーはそれほど大きな

[17:32 - 17:39]
問題ではないため、問題ない可能性があります。

[17:36 - 17:42]
数値を微調整します。合計

[17:39 - 17:44]
残高。この値はどこから来ているのか疑問に思います。たとえば、

[17:44 - 17:53]
収益データです。

[17:48 - 17:55]
収益データをツイートします。3 月

[17:53 - 18:00]
に数字を膨らませたことを思い出します。

[17:55 - 18:03]
これはこれです。

[18:00 - 18:04]
順序がおかしくなっている

[18:03 - 18:08]
ので、

[18:04 - 18:12]
何か対処する必要がありますが、

[18:08 - 18:14]
今は忘れて、

[18:12 - 18:17]
3 月の数字をさらに

[18:14 - 18:23]
大きなものに変更しましょう。 だって、100ドルじゃなくて13万

[18:23 - 18:29]
3500ドルでいいじゃないですか。更新ボタンを押すと

[18:27 - 18:32]
データが更新されていることが確認できます。Super

[18:32 - 18:37]
からデータが読み込まれていることを確認

[18:34 - 18:39]
できます。「すべて承認」ボタンを押すと、

[18:37 - 18:41]
Superbeがアプリに接続され、

[18:41 - 18:45]
Superbeデータベースからデータが読み込まれています。

[18:43 - 18:47]
チャートで発生した問題を修正しましょう。

[18:45 - 18:49]
チャートを見ると、

[18:47 - 18:51]
月が

[18:49 - 18:55]
数字順ではなくアルファベット順でソートされていることに気づきました。

[18:55 - 19:02]
これは問題です。

[19:00 - 19:05]
データベースでこれらの

[19:02 - 19:07]
データがどのように保存されているかを確認すると、月は実際には

[19:05 - 19:11]
単なる文字列で、数値でも日付を

[19:07 - 19:15]
表すものでもなく、単なる

[19:11 - 19:19]
テキストの文字列です。データ

[19:15 - 19:23]
形式が実際の日時や日付などではないため、

[19:19 - 19:26]
問題が発生しています。

[19:23 - 19:27]
適切な解決策は、

[19:26 - 19:30]
この月の列を削除し、適切な日付型の列を持つ

[19:27 - 19:32]
新しい月の列を導入することです。この列は、

[19:32 - 19:38]
日時値を適切に保持し、

[19:35 - 19:39]
日付などでソートできます。

[19:38 - 19:43]
アプリケーションはそれをうまく処理できるはずです。

[19:39 - 19:46]
それでは、Curser に戻って

[19:43 - 19:49]
、カーソルにそれを実行するように指示します。

[19:46 - 19:50]
カーソルに伝えている問題は、まず、

[19:54 - 19:59]
Revenue データ テーブルの月列で並べ替えの問題が発生していることです。

[19:56 - 20:01]
原因は、

[19:59 - 20:05]
月列が文字列型であるため、

[20:01 - 20:07]
DAT 型に更新するように指示しています。

[20:05 - 20:10]
また、Superb CLI を再度使用して

[20:07 - 20:14]
移行ファイルを作成し、そこで列の型を更新

[20:10 - 20:17]
するように指示しています。また、

[20:17 - 20:23]
テーブルを更新するだけでなく、c も更新する必要があることにも言及しました

[20:20 - 20:27]
。  SQL ファイルを作成して、

[20:23 - 20:29]
ダミーの日付型列を適切に挿入できるようにします。

[20:27 - 20:32]
最後に、アプリケーション コードを更新して、

[20:29 - 20:34]
アプリが文字列型ではなく

[20:32 - 20:37]
日中の列を処理できるようにしています。

[20:40 - 20:46]
そのため、最初に

[20:44 - 20:48]
superv 移行コマンドを実行して

[20:46 - 20:51]
この新しい移行ファイルを作成した後、

[20:48 - 20:55]
この移行ファイルに書き込んで

[20:51 - 20:56]
テーブル データを更新する必要があります。これにより、

[20:56 - 21:04]
c も更新されます。  SQL

[21:00 - 21:08]
ファイルなので、月が

[21:04 - 21:12]
文字列としてではなく、実際の日付

[21:08 - 21:16]
値が設定されます。すべて問題なさそうです。

[21:12 - 21:17]
すべてを受け入れて DB

[21:16 - 21:20]
リセット

[21:17 - 21:23]
コマンドを実行します。これも 1 分ほどかかる場合があります

[21:20 - 21:25]
が、データベースが再

[21:23 - 21:29]
起動したら、新しい形式のデータを表示できるはずです。DB

[21:29 - 21:35]
リセットの実行が完了すると、

[21:32 - 21:38]
新しい月の列が表示され、型が

[21:35 - 21:42]
更新されています。

[21:38 - 21:45]
アプリケーションを見てみましょう。更新をクリックすると、

[21:42 - 21:48]
日付が

[21:45 - 21:50]
表示されています。これは正常に動作しています。

[21:50 - 21:57]
ここではアルファベット順の表示形式が気に入っていますが、これも正常

[21:54 - 22:01]
に動作しています。カーソルに形式を更新するように簡単に依頼できるかどうか、ちょっと質問します。

[22:01 - 22:07]
カーソルに、

[22:05 - 22:10]
ほとんどの更新は

[22:07 - 22:13]
良好ですが、月の 3 桁の略語表示が気に入っている、と伝えています。

[22:10 - 22:16]
そのため、アプリを更新して、

[22:16 - 22:23]
デザインを面白く保つようにします。実際には、

[22:18 - 22:26]
使用されている財務データを更新しています。  TS は

[22:23 - 22:29]
それを行うために、p でそれを処理すると思いました

[22:26 - 22:32]
。  TSX ファイルです

[22:29 - 22:36]
が、カーソルを信頼して、何が起こるか見てみましょう。

[22:32 - 22:38]
データが

[22:36 - 22:41]
スーパーベースから入ってくると、実際にその場でフォーマットが更新されます。これは機能します。

[22:41 - 22:48]
はい、確かにそれを受け入れて、見てみましょう。

[22:44 - 22:50]
更新をクリックします。

[22:50 - 22:57]
エラーが 1 つあります。これは、

[22:53 - 22:59]
水分補給 aor ではないためです。

[22:57 - 23:02]
何が起こったのか疑問に思います。

[23:05 - 23:11]
ページを確認すると、月 H が表示されます。  TSX

[23:09 - 23:13]
ファイル

[23:11 - 23:17]
[音楽]

[23:13 - 23:21]
収益

[23:17 - 23:25]
データはここにあります。財務データを使用します。

[23:21 - 23:28]
収益の結果と収益データのフォーマット。

[23:28 - 23:34]
カーソルにもう一度聞いてみましょう。

[23:31 - 23:36]
このプロンプトが機能することを願いますが、機能しない

[23:34 - 23:38]
場合でも大したことではないと思いますので、先に

[23:36 - 23:42]
進み、

[23:38 - 23:44]
CER がそれを理解できるかどうか見てみましょう。これは、

[23:44 - 23:49]
以前は実行しなかった

[23:46 - 23:53]
コード ベースをスキャンすることであり、実際に

[23:49 - 23:58]
ページを微調整しています。  TSXファイルを使って

[23:53 - 24:02]
表示月を変更します。これは

[23:58 - 24:05]
正しいアプローチのように思えます。

[24:02 - 24:08]
3月、4月、5月、6月、7月、8月です。

[24:05 - 24:10]
素晴らしいですね。気に入りました。これで

[24:08 - 24:12]
受け入れましょう。テーブルの1つを編集したので、

[24:10 - 24:14]
移行ファイルが2つあります。

[24:14 - 24:19]
動画の冒頭で、データベーススキーマを理解できる

[24:16 - 24:21]
ように、移行ファイルの1つをカーソルのコンテキストとして提供したことを覚えているでしょうか。

[24:21 - 24:25]
しかし、移行ファイルが2つになったので、

[24:23 - 24:27]
プロジェクトが

[24:25 - 24:29]
拡大し続ければ、さらに多くの

[24:27 - 24:32]
移行ファイルが必要になるでしょう。データベーススキーマを理解させたいからといって、すべての移行ファイルをカーソルに渡すのは全く現実的ではありません。

[24:36 - 24:40]
どうすればこれを

[24:39 - 24:44]
解決できるでしょうか？この問題には、

[24:40 - 24:46]
モデルContexプロトコル、つまりmCPを使用できます。mCPは

[24:46 - 24:52]
クラウドの背後にある企業であるAnthropicによって開発されたもので、基本的に

[24:49 - 24:55]
AIがデータベースなどのさまざまなツールと通信するための標準化されたプロトコルです。

[24:55 - 25:00]
幸いなことに、Superbaseで使用できる公式のPostgress mCPサーバーがあります。

[25:03 - 25:09]
ドキュメントを見ると、ローカルのSuperbase

[25:06 - 25:14]
インスタンスでは、まずこのnpx

[25:09 - 25:17]
superb statusコマンドを実行してすべての

[25:14 - 25:19]
資格情報です。そして、基本的には

[25:17 - 25:22]
このコマンドをカーソル設定ページにコピー＆ペーストするだけです。

[25:22 - 25:29]
新しい

[25:25 - 25:32]
ターミナルを開いて、このスーパーステータス

[25:29 - 25:35]
コマンドを実行すると、これらの資格情報がすべて取得されます。

[25:32 - 25:39]
必要なのは

[25:35 - 25:43]
DB

[25:39 - 25:47]
URLです。これはこれです。これをコピーして

[25:43 - 25:49]
設定に移動し、

[25:47 - 25:54]
このターミナルの

[25:49 - 25:58]
機能を閉じます。mCPサーバーがあります。mCP

[25:54 - 26:02]
サーバーを追加しましょう。

[25:58 - 26:03]
クリップボードにあるものを貼り付けます。

[26:02 - 26:08]
タイプをコマンドに変更します。

[26:03 - 26:11]
サーバー名はローカルスーパーベースなど好きな名前にできます。

[26:11 - 26:19]
この文字列をコピーします。DB

[26:15 - 26:22]
URLは最後に追加します。先頭に戻って、

[26:22 - 26:34]
これをすべて削除します。これで

[26:28 - 26:36]
すべて完了です。curerが

[26:36 - 26:41]
mCPを介してデータベーススキーマを確認できるかどうかを確認します。データベースにどんなテーブルがあるかなど、簡単に尋ねることができます。

[26:41 - 26:45]
データベースにどんな

[26:43 - 26:48]
テーブルがあるかを伝え、

[26:45 - 26:49]
mCPを使用していることを確認します。mCPを

[26:48 - 26:53]
使用するように指定すると、

[26:49 - 26:57]
カーソルは呼び出しを行います。

[26:53 - 26:59]
mCPをデータベースにインポートして、

[26:57 - 27:02]
カード情報、

[26:59 - 27:06]
取引、経費、カテゴリ、週次

[27:02 - 27:08]
指標、収益データなど、すべてのテーブル情報を取得しました。これは、データベース

[27:06 - 27:12]
にあるテーブルセットと一致します。

[27:12 - 27:16]
これらのテーブルの構造について、もっと詳しく教えていただけますか？もちろんです。

[27:20 - 27:25]
どんな

[27:23 - 27:27]
クエリが実行されるのか確認できるはずです。

[27:25 - 27:30]
テーブル名、

[27:27 - 27:33]
列名、データ型を調べて、基本的に

[27:33 - 27:39]
テーブルの詳細な内訳を返します。テーブル名に加えて、列名と列タイプも

[27:36 - 27:40]
返します。

[27:40 - 27:46]
素晴らしいですね。このビデオでは、テーブルコンテキストを必要とする別の機能を

[27:44 - 27:48]
追加する方法については説明しません。

[27:48 - 27:54]
このプロンプトなどを使用して、

[27:54 - 28:03]
データベーススキーマをカーソルにコンテキストとして追加できます。

[27:59 - 28:06]
このmCPサーバーの1つの問題は、

[28:03 - 28:10]
現在、mCPにプロジェクトレベルの

[28:06 - 28:13]
設定がないことです。つまり、このmCP

[28:10 - 28:16]
サーバーのコマンドをここで設定しましたが、

[28:13 - 28:19]
別のスーパーベースプロジェクトがある場合は、

[28:16 - 28:21]
まったく異なる構成になります。

[28:21 - 28:26]
例えば、SuperBaseインスタンスを見てみましょう。

[28:24 - 28:29]
リモートインスタンスに接続している場合は、

[28:29 - 28:33]
ここで更新する必要があります。

[28:31 - 28:36]
このプロジェクトに戻ったら、

[28:33 - 28:38]
再度更新する必要があります。

[28:36 - 28:41]
将来的にはプロジェクト

[28:38 - 28:43]
レベルのmCP設定が可能になり、プロジェクトごとに

[28:41 - 28:47]
異なるmCPサーバー設定が可能になります。

[28:43 - 28:49]
今のところは、これが

[28:47 - 28:51]
最善の方法です。アプリケーションは

[28:49 - 28:52]
完成しつつあり、公開もほぼ完了していますが、

[28:52 - 28:56]
忘れてはならないのがセキュリティです。Super

[28:54 - 29:00]
ダッシュボードを開くと、

[28:56 - 29:03]
RLSが無効になっていることがわかります。RLSはロール

[29:00 - 29:06]
レベルセキュリティの略で、

[29:03 - 29:10]
ロールアクセスからデータを保護するための最も強力なメカニズムです。

[29:06 - 29:12]
無効になっていると、

[29:10 - 29:14]
基本的にすべてのユーザーがこのデータベースに対してあらゆる操作を実行できます。

[29:14 - 29:18]
すべてのデータの読み取りや削除など、

[29:16 - 29:22]
これはあまり良いことではありません。そこで、

[29:18 - 29:25]
これを有効にします。有効にすると、

[29:25 - 29:31]
テーブルに対するすべての操作が実際に遮断され、特定の条件下で特定の操作を実行できる条件の

[29:28 - 29:34]
ようなポリシーを定義できます。

[29:39 - 29:44]
有効にしたいのですが、

[29:42 - 29:47]
有効化する方法は2つあります。

[29:44 - 29:49]
ダッシュボードからこれをクリックして有効化するか、

[29:47 - 29:51]
Curserに戻って

[29:49 - 29:55]
Curserに処理させるかです。後者の方法は今回やります。

[29:51 - 29:57]
これは別の移行になりますが、

[29:55 - 30:00]
Ciserの解説に入る前に、もう

[30:00 - 30:05]
一つヒントをお伝えしたいと思います。Super

[30:02 - 30:08]
Baseでは、

[30:05 - 30:10]
私たちが作成した定義済みのプロンプトを多数提供しています

[30:08 - 30:14]
。sub.comの

[30:10 - 30:18]
ドキュメントを開いて一番下までスクロールすると、

[30:21 - 30:26]
Super Baseでよく使われるユースケースをカバーするAIプロンプトのセットがあります。その中に、

[30:24 - 30:29]
Roレベルのセキュリティポリシーを作成するためのプロンプトがあります。

[30:29 - 30:38]
このプロンプトをコピーして、Curserに戻り、

[30:33 - 30:39]
Command + Shift + Pを押して「新しいカーソルルール」を検索します。

[30:39 - 30:48]
一番上にある「新しいカーソルルール」をクリックして

[30:43 - 30:50]
名前を付けます。「新しいカーソルルール」と入力します。「

[30:48 - 30:55]
Roレベルの

[30:50 - 30:57]
セキュリティルール」と入力します。コンテンツ本文セクション

[30:55 - 31:01]
に貼り付けます。

[31:01 - 31:08]
このルールの良いところは、説明が付いていることです。

[31:04 - 31:11]
glob の説明は、

[31:08 - 31:13]
基本的にこのルールをいつ、どのような

[31:13 - 31:18]
条件で、どのファイルに、人間の言語で適用するかを指定します。glob は、

[31:16 - 31:22]
どの種類のファイルに適用するかを指定します。

[31:18 - 31:24]
今回の場合は

[31:22 - 31:27]
SQL ファイルに適用したいので、

[31:24 - 31:29]
SQL を指定します。このプロンプトの良いところは、

[31:29 - 31:35]
説明とグローブのセットが付属しており、

[31:31 - 31:38]
コピーして貼り付けて保存できることです。これは、

[31:35 - 31:41]
この do cursor SL ルールの下に配置されます。これを設定したら、

[31:45 - 31:50]
カーソルが glob または説明に一致する何かをトリガーするたびに、ルールが

[31:50 - 31:57]
自動的に

[31:51 - 32:00]
適用されます。curser に渡すプロンプトです。curser のセキュリティで

[31:57 - 32:02]
Ro を有効にし

[32:00 - 32:05]
、アプリケーションを安全に保護するためのポリシーをいくつか記述します。

[32:05 - 32:10]
実際のアプリケーションでは、

[32:10 - 32:15]
ユーザーに適切なアクセス権を付与する必要があるでしょうが、この例では、

[32:15 - 32:20]
すべてのユーザーに読み取りアクセスを許可し、

[32:17 - 32:22]
書き込みアクセスは許可しないようにします。

[32:20 - 32:24]
つまり、送信します。この

[32:22 - 32:26]
プロンプトでは、MPX と

[32:24 - 32:30]
優れた CLI を使用して、curser に再び移行ファイルを作成するように指示します。

[32:26 - 32:32]
次に、ロールオーバーセキュリティを有効にします。

[32:30 - 32:34]
実際の本番

[32:32 - 32:36]
環境アプリでは、ユーザー

[32:34 - 32:38]
に何らかのアクセス権を付与する必要があるでしょう。

[32:36 - 32:41]
今回の例では、

[32:41 - 32:47]
ダッシュボードへのアクセスは誰でも許可しますが、

[32:44 - 32:50]
データベースへの書き込みは許可しません。

[32:47 - 32:53]
送信ボタンを押して、cser がどのような結果を返すか確認してみましょう。

[32:53 - 32:57]
このルールが cursor に自動的に適用されているのがわかります。うまくいっていますね。

[32:57 - 33:04]
このコマンドを実行して、

[33:01 - 33:07]
新しい移行ファイルを再度作成します。この

[33:04 - 33:10]
ファイル内に、cursor は

[33:07 - 33:13]
Roller World セキュリティポリシーを書き込みます。

[33:10 - 33:16]
これにより、

[33:13 - 33:20]
すべてのユーザーに読み取りアクセスが許可され、

[33:16 - 33:23]
他のテーブルへのアクセス権は一切許可されません。

[33:23 - 33:30]
つまり、ポリシーがないということですね。よさそうです。

[33:30 - 33:38]
すべて承認して、

[33:38 - 33:44]
データベースをリセットします。プロンプトに含めるのを忘れましたが、

[33:40 - 33:50]
cursor は、このロールセキュリティポリシーを、実行中のスーパーベースのローカルインスタンスに適用する

[33:44 - 33:52]
ために、このスーパー VDB リセットコマンドを実行する必要があります。

[33:58 - 34:04]
それでは、アプリに戻って

[34:00 - 34:08]
更新し、ダッシュボードに移動してすべての数値が読み込まれていることを確認します。

[34:10 - 34:15]
警告がなくなったことがわかります。

[34:12 - 34:18]
認証ポリシーに移動すると、ユーザーによる特定のアクションの実行を許可する一連のポリシーがあります。

[34:20 - 34:25]
これでアプリはすべて保護されたので、

[34:25 - 34:29]
クラウドにデプロイする時が来たと思います。

[34:27 - 34:32]
まずは、データベースに移動できる新しいスーパーベース インスタンスを作成します

[34:29 - 34:35]
。 新規作成して、新しい

[34:32 - 34:36]
SuperBaseプロジェクトを作成します。

[34:35 - 34:39]
私のプロジェクトは「

[34:36 - 34:42]
チャート」と「データベースパスワード」です。パスワードを生成できます。

[34:42 - 34:47]
このパスワードは後で使用するのでコピーしておきます。

[34:47 - 34:52]
パスワードが手元になくても心配ありません。SuperBaseダッシュボードから

[34:49 - 34:54]
いつでも新しいパスワードに更新できます。

[34:52 - 34:56]
これで

[34:54 - 35:01]
SuperBase

[34:56 - 35:04]
プロジェクトの準備ができました。URLからこの最後の文字列を取得しましょう。これはSuperBaseリファレンスと呼ば

[35:01 - 35:05]
れます。

[35:05 - 35:13]
新しいカーソル

[35:09 - 35:16]
コンポーザーまたはアジアンウィンドウを開き、カーソルにリモートSuperBaseインスタンスへの接続を指示します。

[35:16 - 35:21]
実際には、SuperBaseプロジェクトリファレンスを

[35:21 - 35:28]
提供するリモートSuperBaseインスタンスへの接続を指示します。

[35:25 - 35:32]
そして、

[35:34 - 35:41]
MPXを使用するように指示します。

[35:37 - 35:44]
プロジェクトをリモートSuperBaseプロジェクトにリンクするコマンドが実行されています。

[35:41 - 35:48]
ここで

[35:44 - 35:51]
データベースパスワードの入力を求められます。クリップボード

[35:48 - 35:52]
に保存されているので、そのまま貼り付けます。

[35:52 - 35:58]
これで

[35:56 - 36:01]
接続されました。

[35:58 - 36:06]
サブプロジェクトが正常にリンクされました。

[36:01 - 36:08]
これで、リモートインスタンスからデータベースの移行をプルする super DB ポールを実行できます

[36:11 - 36:17]
が、移行は行われていません。これは、

[36:17 - 36:22]
新しく作成された

[36:20 - 36:25]
サブ

[36:22 - 36:27]
インスタンスなので予想どおりですが、ここでは行いません。

[36:25 - 36:29]
ローカルの

[36:27 - 36:32]
移行履歴に不一致があるようです。提案されているように、移行履歴を修復しましょう。

[36:38 - 36:46]
新しいスーパーインスタンスに対しては、

[36:42 - 36:50]
Super steb push を呼び出すだけでよいと思います

[36:46 - 36:53]
が、これは機能する可能性があるため、

[36:50 - 36:53]
super beb

[36:54 - 37:01]
pull を実行できます。

[36:58 - 37:01]
ローカルデータベースとこのリモートデータベースの移行ステータスは

[37:06 - 37:13]
同じになっていると思います。

[37:09 - 37:16]
想定どおりには動作していませんが、

[37:13 - 37:21]
カーソルを信頼して少し待つことができます。

[37:21 - 37:28]
何かから大量のデータのプルが完了し、

[37:26 - 37:32]
移行履歴テーブルを更新するように求められます。

[37:28 - 37:35]
はい、新しい移行テーブルも作成されました。

[37:35 - 37:41]
考えてみると、

[37:39 - 37:45]
最新バージョンの super CLI を使用していないため、コストが

[37:45 - 37:53]
かかっている可能性がありますが、  super be DB プルが

[37:50 - 37:55]
完了し、リンクされました。プロジェクトは

[37:53 - 37:58]
super be のリモート インスタンスに正しく接続されています。

[37:55 - 38:04]
これで

[37:58 - 38:06]
super TV プッシュを実行できるはずです。ローカル

[38:04 - 38:09]
データを

[38:10 - 38:17]
リモートにプッシュします。うまくいけば

[38:13 - 38:21]
成功しますが、そうでない場合は

[38:17 - 38:22]
CLI を最新バージョンに更新して

[38:22 - 38:29]
動作するか

[38:24 - 38:32]
どうかを確認できます。テーブル エディタを見ると、

[38:32 - 38:40]
テーブルはありません。super St be プッシュ。

[38:37 - 38:42]
リモート データベースに接続しています。リモート データベースは最新です。

[38:40 - 38:44]
このメッセージは、リモート データベースがローカルの変更で既に最新であることを示しています。つまり、

[38:48 - 38:52]
すべての移行とスキーマの

[38:50 - 38:55]
変更が既に

[38:52 - 38:59]
適用されているということです。これは明らかに正しくありません。3

[38:55 - 38:59]
つの移行があるためです。

[39:09 - 39:16]
はい、これはローカル バージョンです。これは

[39:12 - 39:19]
リモート バージョンです。

[39:16 - 39:22]
チャートを見ると、

[39:19 - 39:25]
移行、superv

[39:22 - 39:28]
移行、スキーマ

[39:25 - 39:31]
移行を確認できます。

[39:28 - 39:35]
これらの移行がすべて財務データ テーブルで

[39:31 - 39:37]
更新され、収益データが毎月有効になっています。Ro

[39:35 - 39:42]
レベルの

[39:37 - 39:44]
セキュリティが有効になっていますか? これは、

[39:44 - 39:52]
すべてのユーザーが無効にできることを意味します。はい、

[39:50 - 39:54]
これらの移行を削除しましょう。super

[39:59 - 40:03]
から削除します。 ベース

[40:06 - 40:12]
マイグレーション。これで

[40:09 - 40:17]
マイグレーションが更新されていない状態にリセットされ

[40:12 - 40:21]
、プッシュできるようになります。MPX

[40:17 - 40:25]
スーパーベース、つまり

[40:21 - 40:30]
マイグレーションを

[40:25 - 40:30]
再度プッシュします。これは

[40:31 - 40:34]
必須でしょうか？試してみましょう。

[40:38 - 40:42]
ああ、force

[40:44 - 40:48]
コマンドがあります。Forceコマンドはありません。

[40:49 - 40:58]
フラグはありません。同じコマンドです。

[41:07 - 41:14]
はい、これでマイグレーションが適用されました。

[41:11 - 41:14]
パブリックスキーマに移動して、

[41:21 - 41:27]
更新してみましょう。よし、何が起こったか？

[41:24 - 41:28]
モーションが正常にプッシュされました。マイグレーションが

[41:28 - 41:35]
リモートスキーマに適用されました。

[41:32 - 41:39]
データベースが

[41:35 - 41:43]
同期されていなかったため、このリモートスキーマファイルが作成され、

[41:39 - 41:45]
すべてが

[41:43 - 41:49]
同期されます。つまり、すべてのテーブルが削除されます。プッシュする

[41:45 - 41:53]
はずだったのにプルしようとしていた

[41:49 - 41:56]
ときにカーソルを修正する必要がありましたが、

[42:04 - 42:09]
フラグなしでもう一度プッシュします。これで、

[42:09 - 42:15]
スーパーDBプールが作成した追加のマイグレーションファイルを削除したので、

[42:13 - 42:19]
この

[42:15 - 42:22]
ファイルをプッシュできるはずです。これらのマイグレーションをプッシュすると、

[42:19 - 42:22]
すべてのテーブルが

[42:22 - 42:28]
作成されます。これで、SQLエディターから実行できるCデータを追加することもできます。

[42:34 - 42:42]
これで、

[42:37 - 42:43]
テーブル内に同じCデータがあります。 更新を押しました。

[42:42 - 42:47]
これで完了です。

[42:43 - 42:50]
この

[42:47 - 42:54]
アプリをリモートのスーパーベースインスタンスに接続するために必要なのは、

[42:54 - 42:58]
資格情報を更新することだけです。ローカルを見てみましょう。スーパーベースの

[42:58 - 43:06]
URLとスーパーベースの匿名キーをここに貼り付けます。

[43:06 - 43:12]
おそらく

[43:12 - 43:18]
mpm run Dev

[43:19 - 43:25]
コマンドを再度実行する必要があります。これは、このように実行できます。

[43:29 - 43:35]
アプリで更新を押すと、更新されます。

[43:32 - 43:37]
ハイドレーションエラーはわかりますが、

[43:37 - 43:43]
問題ありません。

[43:40 - 43:46]
このリモートチャートのサブインスタンスに実際に接続されていることがわかります。

[43:43 - 43:50]
カード

[43:46 - 43:50]
情報を

[43:51 - 43:59]
1111に変更すると、カード情報がどこにあるのかがわかります。カード情報は

[44:01 - 44:09]
消えてしまいましたが、

[44:03 - 44:15]
収益データは確かです。3月を途方もなく高いものに変更しましょう。

[44:15 - 44:21]
更新を押すと、3月が途方もなく高いことがわかります。これは、

[44:18 - 44:23]
このアプリが

[44:21 - 44:25]
リモートのスーパーベースインスタンスに実際に接続されていることを証明しています。

[44:25 - 44:30]
最後に少し問題がありましたが、

[44:27 - 44:34]
新しい監視

[44:30 - 44:38]
インスタンスに対してはDBポールを実行せず、常に

[44:34 - 44:41]
DBプッシュを実行することを忘れないでください。 そして最後に、

[44:38 - 44:44]
NextJSのSuper BaseとCurser、Curser Agentを使って素敵なアプリケーションを作ることができました。この

[44:48 - 44:51]
結果には本当に感心しています。この動画

[44:50 - 44:54]
で紹介したヒントを覚えていてください。Super

[44:56 - 44:59]
Baseを使ってどんな素晴らしいマップを作るのか、とても楽しみです。

## コメント

### 1. @dshukertjr (👍 14)
I always enjoy working with Cursor, and would like to hear what you all are building with it! BTW, at the end there is a credit card information stored on the database, but one thing you want to avoid is to store credit card information on your database 😅 Use Stripe or other payment processing services for it!

> **@lofi_Insomnia_** (👍 1): I'll be the first. I'm working on a micro SaaS where currently, someone sends in a request through a form (Google Form). then I have 3 python script running locally that sends an API call to openAI api, generate the result into a pdf, then email to the user. My goal is automating this whole process so I can hands-off. I've been trying to do this with Supabase Edge functions which I know nothing about, and I got in a lot of trouble because I couldn't debug it easily. My coding experience are limited to html/css and basic React, so I'm ok with frontend but very limited with backend/database stuff. I now decided to switch to hosting my 3 python script on pythonanywhere for now just to make things work, and keep learning and hopefully figure out the edge functions stuff so I can do everything in supabase.

> **@evgeniy9582** (👍 0): bla bla bla...

### 2. @RobShocks (👍 15)
I love that this is a realistic take on developing with AI. It's showing the actual issues you would encounter and how you step through them with prompts. It's traditional problem solving with AI not a cut out all the hard bits novelty build.

> **@shapesii** (👍 0): Delivered via AI video

### 3. @RamaKrishna-em5xt (👍 1)
This is absolutely incredible! I can't believe how quickly we can spin up new apps! Thank you so much for sharing this demo tutorial! 
You're saving lives!

### 4. @mpfiesty (👍 2)
For someone new to working with Supabase and Cursor, this video was absolutely gold. I have so many take aways and I’m looking forward to implementing them. Thank you for the video!

### 5. @abdallahshaban4804 (👍 1)
Such a great walkthrough! I love that you left the little hiccup at the end - exactly the type of stuff I stub my toe with all the time using Cursor and other coding LLMs!

### 6. @AlfredNutile (👍 3)
Thanks for keeping in all the rough edges that really helps!

### 7. @peeeeed52 (👍 2)
Amazing content! It helped me significantly speed up my app development. I’m currently building a small app to test the features before diving into my real project.

### 8. @kirilkirchev285 (👍 1)
Great video.  Congrats to Supabase for adding mcp server so fast

> **@Supabase** (👍 0): Thanks! Actually though, the MCP server used in this video is actually the official Postgres MCP server, which has been around since Anthropic announced MCP.

### 9. @thorwebdev (👍 1)
Absolutely love this, great work Tyler 🔥

### 10. @lofi_Insomnia_ (👍 3)
Finally! I've been struggle with Supabase cuz I'm amateur developer and don't know much on the database/backend stuff. Been working on my very first SaaS for a while using Cursor and got in a lot of trouble. Hope this is helpful!

### 11. @tirthb (👍 1)
Thanks a lot for teaching these hacks. I like your pace. Thanks for not speeding up the videos and showing us as

### 12. @momoii3838 (👍 3)
This was just what I needed. Thanks!

### 13. @PassionBrains (👍 0)
I made my first app with Cursor! Nice. Even with icon on screen.

### 14. @CraigCannon (👍 2)
Great video Tyler! 👏

### 15. @LucaTheNativeSpeaker (👍 0)
Pure Gold thank you!

### 16. @yurijmikhassiak7342 (👍 0)
Thanks! After convex and even firebase it still feels very oldschool. Migrations, sql, docker, local/remote dbs, tunneling. I love supabase and it definitely works. Promoted it to my colegues. 
Sime ideas: have install command that installs supabase with all cursor rules. 
Set dev and prod env in the cloud with simple switch. 
Good luck!

### 17. @SX_Flight (👍 4)
Great video, has helped greatly.

### 18. @sshblue0 (👍 3)
insane this guy is a genius

### 19. @andydataguy (👍 2)
Great tutorial, thank you!

### 20. @aleksiimmonen6983 (👍 2)
Really great stuff!

