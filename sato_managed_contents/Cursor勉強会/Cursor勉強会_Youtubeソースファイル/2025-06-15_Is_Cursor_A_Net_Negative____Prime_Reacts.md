# Is Cursor A Net Negative? | Prime Reacts

**チャンネル:** ThePrimeTime
**公開日:** 2025-06-14
**URL:** https://www.youtube.com/watch?v=pQzwlzS2AT0

## 説明

Twitch https://twitch.tv/ThePrimeagen
Discord https://discord.gg/ThePrimeagen

Become Backend Dev: https://boot.dev/prime
(plus i make courses for them)

This is also the best way to support me is to support yourself becoming a better backend engineer.  

### LINKS 
https://lukasatkinson.de/2025/net-negative-cursor/
By: Lukas Atkinson

Great News?  Want me to research and create video????: https://www.reddit.com/r/ThePrimeagen

Kinesis Advantage 360: https://bit.ly/Prime-Kinesis

## 字幕

[00:00 - 00:04]
これを実行すれば、ネットネガティブ

[00:01 - 00:08]
カーソルは完了します。 しかし、AI 編集も行う

[00:04 - 00:11]
テキスト エディターについては、かなりよく理解していると感じています

[00:08 - 00:13]
。 私

[00:11 - 00:15]
もゼッドについてとても興味があります。

[00:13 - 00:16]
Zed が十分な経験を持っているかどうか興味があります

[00:15 - 00:17]
。 始める前に、

[00:16 - 00:21]
私が

[00:17 - 00:24]
コードを書くときに独特な立場にいることを理解しておくことが重要だと思います。 私は

[00:24 - 00:30]
ここにいるのが好きなのと同じように、中にいるのが好きです、そうですよね？ ここが私の行きたい場所です。

[00:27 - 00:31]
ここにいたいです。 それを楽しみたいです。

[00:30 - 00:34]
私がいたいのはここです。私は

[00:31 - 00:38]
ネオイムにいたいのです。  VS Code には入りたくないです

[00:34 - 00:41]
。 ですから、私の意見は

[00:38 - 00:42]
明らかにそれによって色づけられています。

[00:41 - 00:45]
カーソルを時々使用しますか? ああ、そうですね、

[00:42 - 00:48]
私はカーソルを使います。 実際、

[00:45 - 00:50]
つい最近も数時間使ってみました。  Neim には

[00:48 - 00:52]
AI があります。  AIやアバンテなどが搭載されていることは知っています

[00:50 - 00:54]
。 また、Super Maven や

[00:52 - 00:57]
その他楽しいものもすべて含まれています。

[00:54 - 00:59]
私はプログラミングが好きなので、これまで

[00:57 - 01:00]
たくさん AI

[00:59 - 01:02]
エディターを使ってきましたし、今でも AI

[01:00 - 01:04]
エディターでたくさん遊んでいます。ただ、おそらくコマンドラインからの統合など、もっとやりたいことのある機能はまだ試していません

[01:06 - 01:09]
。 それが私が見逃している一つのことです

[01:07 - 01:12]
。 したがって、私の意見では、

[01:09 - 01:14]
コマンドラインの経験について話さない場合はお許しください

[01:12 - 01:16]
。 私はもうすぐここでオープン コードを実行する予定であり、

[01:14 - 01:17]
オープン コードについて詳しく調べて

[01:16 - 01:19]
、

[01:17 - 01:20]
それが良い感触であるかどうかを把握するつもりです。

[01:19 - 01:23]
わかりました。それを理解する必要があります。

[01:20 - 01:25]
さて、AI 支援開発は

[01:23 - 01:26]
最近大流行しています。 私は懐疑的ですが、

[01:25 - 01:28]
これらのツールを実際に試してみたいと思っています

[01:26 - 01:30]
。 しかし、これらの

[01:28 - 01:32]
ツールが実際に何を実現できたかを見ると、

[01:30 - 01:35]
幻滅してしまいます。 これらのツールは

[01:32 - 01:36]
役に立たないどころか、生産性を著しく低下させる可能性があります

[01:35 - 01:38]
。 はい、それは

[01:36 - 01:40]
かなり大きな

[01:38 - 01:41]
発言です。 さて、本題に入る前に

[01:40 - 01:43]
、簡単なアンケートを実施します。

[01:41 - 01:44]
この発言は明らかに

[01:43 - 01:47]
重い発言だからです。

[01:44 - 01:50]
新しい投票をしましょう。 新しい投票。 えっと、見てみましょう。

[01:47 - 01:53]
スキルの問題。 この発言により、この人はスキルの問題を抱えているのでしょうか

[01:50 - 01:55]
? だって、

[01:53 - 01:57]
その声明は最初からかなり重い内容で始まるから

[01:55 - 02:00]
。 すぐに、ああ、

[01:57 - 02:03]
これは純粋にマイナスだ、と思いました。 幻滅しました。

[02:00 - 02:05]
良くない。 これはスキルの問題ですか?

[02:03 - 02:07]
スキルの問題が見られますか?

[02:05 - 02:09]
私が行く前に、あなたたちはどこにいますか? これまでで最も簡単な投票

[02:07 - 02:11]
。 そう思いますか？ 彼らは

[02:09 - 02:14]
「skeptical」の綴りさえも知らない。 ああ、まあ、つまり、ね

[02:11 - 02:15]
。  Bro はこれを Vim で書きました。 彼は

[02:14 - 02:19]
スペルチェックをオンにしていませんでした。 わかった。

[02:15 - 02:22]
あなたは何について話しているのですか？ お前は負け犬か？

[02:19 - 02:23]
ああ、スペルチェック機能がありますね。 いいね。

[02:23 - 02:27]
AI によって生成されたコード変更の最も優れた例の 1 つを取り上げてみましょう。

[02:25 - 02:29]
非常に優れた例なので、カーソル エディターでは

[02:27 - 02:31]
これをフロント ページで宣伝に使用しています。

[02:29 - 02:33]
わかった。 わかった。 だから、今のところ彼は

[02:31 - 02:36]
大丈夫そうです。 つまり、今私が理解しているのは、

[02:36 - 02:39]
必ずしもカーソルが問題ではないという議論です。

[02:37 - 02:40]
LLM が生成したコードに

[02:39 - 02:43]
問題があるということについては、私もほぼ同意します。

[02:40 - 02:44]
LLM で生成されたコードは、

[02:43 - 02:46]
朝食にラッキーチャームを食べるようなものだと私は思います。

[02:44 - 02:48]
それは健康に悪いだけですよね？

[02:46 - 02:50]
それはあなたが思っているような W ではないのです。 それは

[02:48 - 02:52]
本当においしいかもしれません。 それは幸せへの近道のように感じるが、

[02:52 - 02:56]
その後は、

[02:54 - 02:58]
ひどいものを食べて体がひどいもので

[02:56 - 02:59]
いっぱいになり、人生が台無しになるので、なんだか気分が悪くなる。

[02:58 - 03:02]
あなたの生命力を吸い取ります。 わかった。

[02:59 - 03:03]
とにかく、カーソルが考える素晴らしいコードとはどの

[03:02 - 03:05]
ようなものでしょうか。 以下はこの記事の執筆

[03:03 - 03:08]
時点での Cursor エディター Web サイトのホームページです

[03:05 - 03:11]
。 ああ、とてもカラフルですね。

[03:08 - 03:13]
わかった。 最大文字列はこれと同じです。 おお。

[03:11 - 03:15]
ああ、彼らはフロントページに少し錆びを付けました

[03:13 - 03:18]
。 カーソル

[03:15 - 03:20]
がファーリーだとは知りませんでした。 わかった。 わかった。 カーソルが見えています

[03:18 - 03:22]
。 タップタップタップタップタップタップタップタップタップ。

[03:20 - 03:23]
ちなみに、タブは彼らの最高の機能です。

[03:22 - 03:26]
長さが最大エラー

[03:23 - 03:28]
プロトコル シリアル化より大きい場合。 わかった。 これは

[03:26 - 03:31]
大丈夫です。 ミュート バイト ベクトル。 このデバイスの

[03:28 - 03:33]
読み取りサイズは正確なバイト数です。 わかった。 これは

[03:31 - 03:34]
罰金という意味です。 読みやすさを考慮して、

[03:33 - 03:37]
ライト モード バリアントを使用してエディターからスクリーンショットを見ることができます

[03:34 - 03:39]
。 ああ、わかりました。

[03:37 - 03:41]
ライトモードが読みやすさのためだとは知りませんでした。 わかった。

[03:39 - 03:43]
いいね。

[03:41 - 03:44]
いいね。 よし。 この画像は、コード変更のための

[03:43 - 03:46]
AI の提案が保留中であるカーソル ID のスクリーンショットを示しています

[03:44 - 03:48]
。 このコードは、

[03:50 - 03:54]
あるバイナリ プロトコルから長さで区切られた文字列を読み取るために Rust で書かれた関数です。 コードの転写は

[03:52 - 03:56]
変更できます。 わかった。 強度を読み取るために

[03:54 - 03:59]
、少し強化された不変の実装読み取りを取得しました

[03:56 - 04:01]
。 文字列プロトコル エラーの結果が返されます

[03:59 - 04:04]
。 少しだけ読んでみます

[04:01 - 04:06]
。 ネットワークインディアン。 おお。 ネットワーク

[04:04 - 04:09]
インディアン。 それは大きなインディアンだ。

[04:06 - 04:11]
ところで、

[04:09 - 04:12]
インドについての私の楽しい話をまだ聞いていない人のために、楽しいサイドクエストを一つ。

[04:11 - 04:14]
私が大学生の頃、初めて「

[04:12 - 04:17]
インディアン」という言葉を耳にしたとき、

[04:14 - 04:19]
インディアンはインディアンだと思っていました。 そして私は本当に

[04:17 - 04:23]
混乱しました。

[04:19 - 04:25]
私のコードにはなぜ大きいインディアンや小さいインディアンがいるのでしょうか?

[04:23 - 04:28]
これと何の関係があるんですか?

[04:25 - 04:31]
私は

[04:28 - 04:33]
ちょっと混乱しています。 そして、それは

[04:31 - 04:36]
1週間ほど続きました。 そして

[04:33 - 04:39]
本を読み進めていくうちに、私はインド人になったような気がしました。

[04:36 - 04:41]
私は大きく外れていました。 ただの大きなインド人だと思っていました

[04:39 - 04:44]
。 よお、兄弟。 これは大きなインディアンです。

[04:41 - 04:47]
これはリトルインディアンです。 偉大なアヤックス、

[04:44 - 04:48]
小さなアヤックス。 知りませんでした。 ただ

[04:47 - 04:51]
混乱しただけです。

[04:48 - 04:52]
はい、それでは始めましょう。 つまり、

[04:51 - 04:55]
これらすべてのことを実行します。 ここで何をしているのか分かります

[04:52 - 04:56]
。 すべては理にかなっています。 わかった。

[04:55 - 04:58]
この提案には、

[04:56 - 05:00]
「

[04:58 - 05:02]
最大文字列長とサニタイズの検証を追加します。

[05:00 - 05:05]
トランスクリプトでは次のコードを提案します

[05:02 - 05:06]
。」というポップアップが表示されます。 わかった。 これを少しだけやってみましょう。 私たちには、

[05:05 - 05:08]
その不戦勝が少しだけあります。 わかった。

[05:06 - 05:10]
ここに一つ問題があります。 私は Rust に精通していないので、

[05:08 - 05:14]
これがなぜ良いのか

[05:10 - 05:17]
悪いのかを説明できません。 これは意味が分かりますか?

[05:14 - 05:21]
U16 を使用していることがわかります。 これは最大長を取得します。U16

[05:17 - 05:24]
U から

[05:21 - 05:27]
2 の 16 乗は 65536 です。したがって、明らかに

[05:24 - 05:29]
unsigned int の最大長は 2 (n から

[05:27 - 05:31]
1 を引いた値) です。 最大

[05:29 - 05:33]
リンク強度を素早くチェックします。 それを読み取ると、

[05:31 - 05:35]
これらすべてが実行されます。

[05:33 - 05:37]
バッファから 16 を読み取ったことがわかります。 つまり、私にとっては、

[05:35 - 05:38]
これがなぜ悪いのか理解できないんです

[05:37 - 05:40]
よね？ ちょっとしたコレクションをします

[05:38 - 05:42]
。 これは、バイトを

[05:40 - 05:45]
イテレータに少し入れるのと同じようなもので、これらのいずれかが

[05:42 - 05:46]
スペースを許可します。 これについてはあまりよく分かりません

[05:45 - 05:48]
。 これはちょっと

[05:46 - 05:49]
興味深い部分です。 私にとって、

[05:49 - 05:52]
彼らが言っていることの中でおそらく厄介なのは、

[05:52 - 05:56]
プロトコルは実行しているが、範囲外のものには何にも反応していないということだと思います

[05:54 - 05:58]
。 つまり、

[05:56 - 05:59]
サニタイズが悪いのかもしれません。 おそらく、

[06:02 - 06:07]
すべて順調で問題ないのではなく、サニタイズ エラーが発生しているはずですよね?

[06:04 - 06:08]
なぜこれが完全に合理的に見えるのかはよく分かりませんが、

[06:07 - 06:10]
深く議論されています。

[06:08 - 06:13]
長さの検証はまったく役に立ちません。

[06:10 - 06:15]
そうそう。 まったくその通りです。 いい判断だ。 いい

[06:13 - 06:18]
判断だ。 長さの検証が

[06:15 - 06:22]
まったく役に立たない理由をご存知ですか?  U16 を作成し

[06:18 - 06:25]
、次に U16 を読み取ります。  U16 は、

[06:22 - 06:28]
U16 の最大サイズよりも大きくなることはありません。

[06:25 - 06:30]
つまり、それは IQ 200 程度の発見です。 わかった。

[06:28 - 06:33]
おい、あの男はいいぞ。 彼はまったく

[06:30 - 06:35]
正しい。 長さのチェックは、

[06:33 - 06:37]
宇宙で最も冗長なコードです

[06:35 - 06:40]
。 まったくその通りです。

[06:37 - 06:41]
消毒は疑わしい。 わかった。 うん。 それで、

[06:40 - 06:43]
私たち二人とも、このコードはちょっと怪しい感じがすると言いました

[06:43 - 06:47]
。 しかし、これもまた疑わしいのでしょうか?

[06:45 - 06:48]
わからない。 なるほど、問題は、プロトコルが何な

[06:47 - 06:50]
のかが分からないということです

[06:48 - 06:51]
。 それで、これは疑わしいのでしょうか?

[06:50 - 06:52]
怪しいかどうかは分かりません。 おそらくこれは

[06:51 - 06:54]
まったく合理的です。 しかし、これは

[06:52 - 06:56]
実に良いのです。 さらに

[06:54 - 06:58]
、こういったものを見るたびに思うのは、

[06:58 - 07:02]
公平を期すために言うと、ウェブ

[07:01 - 07:04]
サイトを見て、

[07:02 - 07:06]
AI コード エディターのようなものを見たとき、

[07:04 - 07:11]
そこで披露されているのはコードそのものではなく、コードが

[07:06 - 07:13]
どのように相互作用したか、

[07:11 - 07:15]
またはエージェントがコードとどのように相互作用したかだということです

[07:13 - 07:17]
。 非常に初歩的なコードです。

[07:15 - 07:19]
ジュニアっぽいかどうかも分からないですよね？

[07:19 - 07:22]
ここで「ジュニアっぽい」という言葉が正しいのかどうかさえわかりません。 私たちは「ジュニアっぽい」という言葉を使います

[07:21 - 07:25]
。でも、それが

[07:22 - 07:27]
ジュニアだったときの自分と同じかどうかはわかりません。

[07:25 - 07:28]
このコードを書いたでしょうか? おそらくそうではない。 役に立たない

[07:27 - 07:30]
長さの検証。 まず、

[07:28 - 07:32]
AI が既存の 16 行

[07:30 - 07:35]
以外のすべての行を追加することを提案するコードの部分に注目しましょう。

[07:32 - 07:37]
さあ、

[07:35 - 07:39]
始めましょう。 ここにこれがあります。 これは、

[07:37 - 07:41]
値 65535 が

[07:39 - 07:43]
実際に U16 型の最大値であるという意味では正しいですが、

[07:41 - 07:45]
人間のプログラマーであれば

[07:43 - 07:47]
同等の定数 U16 max を使用する可能性があります

[07:45 - 07:49]
。 はい、その方が

[07:47 - 07:51]
ずっと良さそうです。 いずれにせよ、代わりに

[07:49 - 07:52]
コメントは不要になります。

[07:51 - 07:54]
まあ、絶対にそうすべきじゃない。

[07:52 - 07:55]
いずれにせよこのコメントは愚かだ。 そもそもそのコメントは

[07:54 - 07:57]
必要なかったのです。

[07:55 - 07:59]
ただし、これは

[07:57 - 08:01]
U16 が格納できる最大値です。 つまり、

[07:59 - 08:02]
この条件は決して真実ではないということです。

[08:01 - 08:05]
Clippy のような優れたツールは、プログラマーに指摘して

[08:02 - 08:07]
警告します。 うん。 はい、それでは

[08:05 - 08:09]
。 では、見てみましょう。 したがって、ここで AI は

[08:07 - 08:10]
せいぜい役に立たないコードを生成し

[08:09 - 08:12]
、実際には

[08:10 - 08:14]
到達不能なコードのためにコンパイラ警告を生成しました。 便利な

[08:12 - 08:16]
AI 駆動型開発ツールは、

[08:14 - 08:18]
この提案に反対したでしょう。

[08:16 - 08:19]
便利な AI 駆動型開発ツールで

[08:18 - 08:20]
あれば、

[08:19 - 08:22]
最大文字列長の検証を追加するという提案に反対し、

[08:22 - 08:27]
文字列の長さは

[08:25 - 08:30]
U16 から読み取られるため、文字列は

[08:27 - 08:32]
既に最大でこの長さになる可能性があるので、そのままで問題ないか、またはより

[08:30 - 08:33]
低い

[08:32 - 08:35]
制限を適用するかなどを説明するはずです。この点が、私が実際にこの

[08:33 - 08:37]
ステートメントに同意しない点です。

[08:35 - 08:39]
つまり、現時点では、彼の問題は

[08:37 - 08:41]
カーソルとはまったく関係がなく、

[08:39 - 08:43]
AI が生成されることにすべて関係しています。これは

[08:41 - 08:45]
カーソルの

[08:43 - 08:47]
問題ではなく、AI 生成の

[08:45 - 08:49]
問題だからです。

[08:47 - 08:50]
生成されるコードが大部分でひどいものであることには私も同意します。 私は

[08:49 - 08:54]
すべてのコメント、そういった類のものすべてを嫌っています

[08:50 - 08:56]
。 これらはすべて悪いことですが、

[08:54 - 08:58]
プロンプトも見てください。 プロンプトは、

[08:56 - 08:59]
プロトコルのバージョン管理用のヘッダーを追加し、

[08:58 - 09:00]
複数のバージョンを処理することです。 はい、ちょっと待ってください

[08:59 - 09:02]
。 それはどこですか？

[09:00 - 09:04]
連載のものがあったと思ったのですが。 そうですね、これは

[09:02 - 09:05]
正しいようにも思えません。

[09:04 - 09:06]
add のようなものがあるのか​​と思ったのですが。

[09:05 - 09:08]
とにかく、それはあまり問題ではありません。 さあ、

[09:06 - 09:10]
行きましょう。 最大文字列の検証を追加します

[09:08 - 09:11]
。 そこにあるよ。 そして消毒。

[09:10 - 09:13]
そこには間違ったものは何もありません

[09:11 - 09:15]
。 実際、私たちは、

[09:13 - 09:17]
これについて少し考えることができますか?

[09:15 - 09:20]
実際に、指示したとおりの動作をしました

[09:17 - 09:22]
。 最大文字列長の検証を追加します

[09:20 - 09:25]
。 まさに文字通り同じことをしたような気がします

[09:22 - 09:28]
。 まさにそれをやったみたい

[09:25 - 09:30]
。 それが良い答えだと言っているわけではない。

[09:28 - 09:33]
私が言いたいのは、

[09:30 - 09:34]
それが本来行うべきことと正確に一致しているということだけです。 実際に

[09:33 - 09:37]
彼らが指摘すべきことは、

[09:34 - 09:39]
カーソルがここで間違ったプロンプトを表示したということだ

[09:37 - 09:42]
。 結果が悪かったというわけではありません

[09:39 - 09:45]
。 結果は完璧でした。

[09:42 - 09:49]
サニタイズルールは設定されていません。 つまり、

[09:45 - 09:53]
白いスペースに asky があるようなものです。わかり

[09:49 - 09:54]
ました。これは良い答えです。

[09:53 - 09:56]
実際のところ、実際にはそうではありません。実際には、

[09:56 - 10:01]
b が

[09:58 - 10:03]
32 より大きく、小文字の

[10:01 - 10:05]
z がどこにあるかより小さい場合、小文字の z がどこにあるかは忘れましたが、

[10:03 - 10:06]
おそらく 128 のような値になるべきであり、実際には

[10:06 - 10:10]
その領域のどこかになるべきだったのですが、もう一度プロンプトを付けるという点では、

[10:10 - 10:14]
サニタイズ ルールとは何かについてまったく説明がありませんでした。また、

[10:14 - 10:17]
独自のサニタイズ ルールを記述する方が簡単かもしれません。 これらは、

[10:17 - 10:20]
私にとってはそれほど素晴らしいことではないと思うもののひとつです。

[10:18 - 10:22]
さて、疑問なのはサニタイズです。

[10:20 - 10:25]
これをやってみましょう。 サニタイズコードの説明を続けましょう

[10:22 - 10:27]
。 関連する抜粋。 ちなみに、

[10:25 - 10:31]
コードはほとんどそうですが、知らない人のために言っておきますが、

[10:27 - 10:33]
32 は 30 だと思いますが、31 は

[10:31 - 10:36]
記録破りの uh 文字です

[10:33 - 10:39]
よね? えっと、アスカイテーブル。  32 歳から

[10:36 - 10:41]
物事は変わり始めます。 さぁ

[10:39 - 10:43]
行こう。  32 を見ると、私たちは

[10:41 - 10:45]
宇宙に入っていることがわかります。 それ以前のすべては、

[10:43 - 10:47]
そこにあります。 記録スペースがあります

[10:45 - 10:48]
。

[10:47 - 10:50]
ここに、意味をすべて忘れてしまいましたが、これらは

[10:48 - 10:51]
すべて、

[10:51 - 10:55]
8 か

[10:53 - 10:56]
何かのバックスペースやタブを使用したい場合を除いて、使用したくないものです。 そう

[10:55 - 10:58]
ですよ。 タブは9です。 右？

[10:56 - 11:01]
ここには役に立つキャラクターが数人いますが、

[10:58 - 11:05]
罪や才能やカナダは決して使わないでしょう

[11:01 - 11:07]
。 右？ カナダを使っているのは誰ですか

[11:05 - 11:09]
? カナダを好きな人なんて誰もいない。

[11:07 - 11:12]
最近は51番目の州さえ誰も好きじゃない。

[11:09 - 11:13]
わかった。 君たちは赤ん坊の集まりだ。

[11:12 - 11:15]
コードは、ほとんどその通りの動作をします。

[11:13 - 11:16]
数字はコメントに記載されている文字に対応しています

[11:15 - 11:18]
。

[11:16 - 11:20]
コードが文字ではなくバイトに対して動作するという小さな懸念があります

[11:18 - 11:22]
。 しかし、

[11:20 - 11:24]
UTF8 は ASKI のスーパーセットなので、これで

[11:22 - 11:26]
十分です。 本当だ、本当だ、本当だ、本当だ、本当だ、

[11:24 - 11:28]
本当だ。 私の主な懸念は、コードがあまり良くないということです

[11:26 - 11:31]
。 つまり、それほど悪い

[11:28 - 11:33]
コードではないのです。 これは悪いコードですか? 例えば、これが

[11:31 - 11:35]
ルールだったら、これは悪い

[11:33 - 11:38]
コードでしょうか? 本当に、私は間違っているのでしょうか

[11:35 - 11:42]
? ルールが

[11:38 - 11:44]
32 以上、つまり 9 または 10 または 13 に相当する場合、

[11:42 - 11:46]
これは悪いことでしょうか? これは悪いコードですか? いいえ、

[11:44 - 11:48]
全然そうは思いません。

[11:46 - 11:49]
これはおそらくあまり良くないと思います。

[11:48 - 11:51]
ひどいことではないよ。 他にどうやってやるんですか？

[11:49 - 11:54]
追加割り当てです。 真実。

[11:54 - 11:56]
ヒープ上に新しいベクトルを割り当てています。 よし。  「はい、その通りです」という状況を考えると、

[11:55 - 11:58]
このコードが正しいかどうかは明らかではありません

[11:56 - 12:00]
。 まず、

[11:58 - 12:01]
スタイルについてお話しましょう。 まず、

[12:00 - 12:03]
不要な割り当てを含むコードを追加しました。 これは、

[12:03 - 12:10]
vec retain bytes retain を使用してインプレースの uh 操作に簡単に変更できます。

[12:06 - 12:12]
これにより、スペース、タブ、改行文字の回転が可能になります

[12:10 - 12:14]
。 ああ、

[12:12 - 12:15]
retain については知りませんでした。 いいね。 私は

[12:14 - 12:17]
Rust の専門家ではないのと同じように、Rust そのものでもありません。 もう一度言いますが、

[12:17 - 12:21]
ここでこれを生成した人も

[12:19 - 12:22]
おそらく Rust の専門家ではないと思うので、

[12:21 - 12:23]
おそらく問題ないですよね? これはおそらく、

[12:22 - 12:25]
先ほど

[12:23 - 12:28]
示したようにコードが生成された瞬間の 1 つです

[12:25 - 12:30]
。 また、Rust は

[12:28 - 12:33]
多くの LLM との互換性が低いと思われます。これは、

[12:30 - 12:35]
言語が頻繁に変更され、

[12:33 - 12:38]
新しいインターフェースが多数追加されるのに対し

[12:35 - 12:41]
、LLM は 1 年

[12:38 - 12:43]
半、2 年遅れていることが多いためです。

[12:41 - 12:44]
したがって、新しいものが入ってくると、

[12:43 - 12:48]
おそらく最新のものではないでしょう。 それらは

[12:44 - 12:50]
おそらく今日ではなく、しばらく前の最新のものでしょう

[12:48 - 12:53]
。  2 番目に、

[12:50 - 12:54]
述語が 10 ではなく 10 の小数の

[12:53 - 12:56]
代わりに文字リテラルを使用する場合、コメントは不要になります。

[12:56 - 13:01]
はい、ちなみに、読みやすさは良好です。

[12:59 - 13:03]
読みやすさは良好です。 これは実際あまり

[13:01 - 13:05]
読みにくいと思いますが、残りは

[13:03 - 13:08]
意味が通りますよね? タブ、

[13:05 - 13:10]
改行、またはキャリッジリターンの場合は、準備完了です

[13:08 - 13:12]
。 おそらく、これは少し

[13:10 - 13:14]
混乱を招くように感じます。

[13:12 - 13:16]
たとえば、

[13:14 - 13:18]
スペース以上というのはどういう意味ですか?  ASKYテーブルスペースから始まります

[13:16 - 13:19]
。 しかし、今私たちは

[13:18 - 13:21]
ただ意味論について議論しているだけです。 だから、それは

[13:19 - 13:23]
何でもいいです。 しかし、これは見た目が良いことには同意します

[13:21 - 13:25]
。 おそらく、コードでは

[13:23 - 13:26]
そのようなリテラルはまったく使用すべきではなく、

[13:25 - 13:28]
代わりに Rust 標準ライブラリによって提供される関数を使用する必要があります

[13:26 - 13:30]
。  Asky 制御

[13:28 - 13:33]
文字、asky の空白。 ああ、

[13:30 - 13:34]
それはとてもいいですね。 そうですよ。 それは

[13:33 - 13:36]
美しいです。 しかし、これは、このサニタイズが正しいかどうかは明らかでは

[13:34 - 13:39]
ないという 2 番目の懸念に近づきます

[13:36 - 13:40]
。

[13:39 - 13:43]
うん。  128 を超える空白範囲をすべて持っているからです。

[13:43 - 13:46]
空白文字とは正確には何でしょうか? たとえば、

[13:45 - 13:48]
提案されたコードではキャリッジリターンが許可されます

[13:46 - 13:50]
が、一部の非 Winds プログラムでは

[13:48 - 13:53]
これを通常の制御文字と見なします。

[13:50 - 13:56]
上記の uh U8 は ASKI 空白

[13:53 - 13:58]
関数であり、 uh /f フォーム フィードを空白文字として扱います

[13:56 - 14:01]
。 他のプログラム

[13:58 - 14:04]
では、/v 垂直タブが空白として使用されます。

[14:01 - 14:05]
削除するのはどうですか? これは、

[14:04 - 14:07]
あらゆる合理的な定義から見て明らかに制御文字です

[14:05 - 14:09]
が、

[14:07 - 14:12]
asky 範囲の一番端に位置します。 それ

[14:09 - 14:14]
も除外すべきではないでしょうか？ 真実。 真実。

[14:12 - 14:15]
非空白の間隔制御文字についてはどうでしょうか

[14:14 - 14:18]
?

[14:15 - 14:20]
その後すぐにバイトは UTF8 としてデコードされ

[14:18 - 14:21]
、

[14:20 - 14:24]
段落

[14:21 - 14:26]
区切り文字、行間注釈、

[14:24 - 14:27]
ビット分離文字などのさまざまな unic コード固有の制御文字があります。  Skibbidity は隔離されます。

[14:26 - 14:29]
疥癬分離株とは何ですか? スキビディティを

[14:27 - 14:31]
隔離します。 わからない。 それはscippidity isolateのようなものですか

[14:29 - 14:34]
? ええと、おそらく、ユニック

[14:31 - 14:36]
コード FE ゼロ幅、ブレーク スペースなしのバイト

[14:34 - 14:38]
オーダー マークは、先頭の位置にある制御文字です

[14:36 - 14:40]
。 双方向。 いや、それはそれは、

[14:38 - 14:44]
えーと、スキッピーだよ。 それは誰もが知っています

[14:40 - 14:46]
。 わかった。 それはそういう意味ではないです。

[14:44 - 14:49]
つまり、ここには 2 つの点があります。 まず、この

[14:46 - 14:51]
人が

[14:49 - 14:54]
言っていることはすべて絶対的に正しい。 私はチームに所属しています。 これは

[14:51 - 14:58]
正解です。 ルカは最高だよ。 わかった。

[14:54 - 15:00]
また、私が唯一反論したいのは、そもそも

[14:58 - 15:02]
サニタイズとは何かを定義していなかったということです

[15:00 - 15:05]
。 プロトコルのサニタイズを行う場合は

[15:02 - 15:07]
、

[15:05 - 15:09]
自分が何をしているのかも知っておく必要があります。 したがって、誰かが

[15:07 - 15:12]
これをプロトコルのサニタイズとして提出した場合

[15:09 - 15:14]
、私は

[15:12 - 15:16]
この人が正しいと想定する必要があります。 これが

[15:14 - 15:17]
私たちの要件である場合、

[15:16 - 15:19]
それが何であるかをもう一度確認したいと思うでしょう? つまり、

[15:19 - 15:22]
これが正しいかどうかは、私には判断できないということです。 そうだ、

[15:20 - 15:24]
人間は知る必要がある。

[15:22 - 15:25]
そこから抜け出すことはできない。 これさえも

[15:24 - 15:27]
混乱を招くようです。なぜなら、彼は

[15:25 - 15:28]
asy 空白文字を使用するべきだと言ったものの、その

[15:27 - 15:30]
直後に、このフォーム フィード

[15:28 - 15:32]
文字は空白文字とみなされる、と言っているからです。

[15:30 - 15:34]
上の空白部分を使用すると

[15:32 - 15:35]
フィード文字が使用可能になるということですか?

[15:34 - 15:37]
フォームフィード文字を使用したくない場合はどうすればよいでしょうか

[15:35 - 15:38]
?

[15:37 - 15:41]
ここでは、

[15:38 - 15:42]
プロトコル実装者が

[15:41 - 15:42]
おそらく理解しているであろう、おそらく答えられるべき多くの疑問が生じます。 ネットワーク ストリームから

[15:44 - 15:48]
データを読み取る低レベル関数において、サニタイズが適切であるかどうかについては多くの疑問があります

[15:46 - 15:50]
。 多くの

[15:48 - 15:52]
アプリケーションは、

[15:50 - 15:55]
文字列が

[15:52 - 15:57]
HTTP ヘッダーや端末出力などの特定のコンテキストで使用されない限り、そのような詳細については無知です。

[15:57 - 16:00]
通常、セキュリティへの影響もありません。

[15:59 - 16:02]
制御文字を事前に削除することは、文字列

[16:02 - 16:06]
からすべての引用符を削除してインジェクションのキーキー音を阻止しようとするのと同じようなものです

[16:04 - 16:08]
。 うん。 ええ、つまり、私がそうしていたとしたら、つまり、

[16:08 - 16:12]
それが私が最初に言った理由です。つまり、これらの文字のいずれかが

[16:10 - 16:13]
含まれている場合は、

[16:13 - 16:18]
プロトコル エラー、つまり無効な文字のようにエラーになるべきだと思ったのです。

[16:18 - 16:20]
少なくとも私にとっては、

[16:19 - 16:22]
それらの文字が含まれていないことを期待しているのであれば、

[16:20 - 16:24]
単に削除するべきではないというのがより合理的に思えます。

[16:22 - 16:25]
奇妙に感じます。

[16:24 - 16:28]
これは正しいかもしれませんが、

[16:25 - 16:29]
ここでアプリケーションが壊れる可能性もあります。その

[16:28 - 16:31]
結果、文字列の読み取り関数

[16:29 - 16:33]
と文字列の書き込み関数が互いにミラーリングされなくなり、

[16:33 - 16:36]
適切なテスト スイートが失敗することになります。 便利な

[16:35 - 16:38]
AI 駆動型開発ツールは、

[16:36 - 16:39]
1 つのソリューションを選択するだけでなく、

[16:38 - 16:41]
問題領域を説明して、プログラマーが

[16:39 - 16:43]
情報に基づいた選択を行えるようにします。

[16:41 - 16:45]
AIに求めすぎていると思います。

[16:43 - 16:48]
AIの問題は、これが目標ではないということです。

[16:45 - 16:50]
カーソルの質問

[16:48 - 16:52]
提案を使用して、「サニタイズを追加する必要があります

[16:50 - 16:55]
。どのようなテクニックを

[16:52 - 16:56]
使用すればよいですか？また、なぜそれを実行する必要があるのですか？」と尋ねたとします。

[16:55 - 16:58]
そしてその後、「これが

[16:56 - 16:59]
ベストなのか？」と考えます。  AIはそういうふうに使わなければならない、というわけです

[16:58 - 17:01]
。 本当に愚かな問題を解決するように扱わなければなりません

[16:59 - 17:03]
。

[17:01 - 17:04]
これはステートレスなソリューションです。 したがって、

[17:03 - 17:06]
解決策が見つかった後でも、

[17:04 - 17:08]
その解決策は正しいかどうかを尋ねる必要があります。

[17:06 - 17:11]
だって、たいていは「

[17:08 - 17:14]
いや、犬」って感じだから。 それは私が作り上げたものです。 それは

[17:11 - 17:16]
まったく正しくありません。 すいません。 完全に私のせいです。

[17:14 - 17:18]
そのような機能が存在することすら考えていませんでした

[17:16 - 17:21]
。 それは、推論も思考も行わない、単なるステートレスな愚かな

[17:18 - 17:23]
ソリューションです。

[17:21 - 17:24]
そして人々は、自分たちが考え、推論していると思い続けます

[17:23 - 17:27]
。 彼らは理屈を言わない。 彼らは

[17:24 - 17:28]
考えない。 やめて。 推論とは

[17:27 - 17:31]
文字通り、「いい

[17:28 - 17:33]
アイデアを出してもらえませんか？さあ、戻って。

[17:31 - 17:34]
あなたの言ったことを何度も繰り返し入力してみましょう。

[17:33 - 17:35]
これがここで起こっていることです。

[17:34 - 17:36]
よし。プログラミングとは決断のことです。この

[17:35 - 17:40]
記事のこの時点で、8行の差分

[17:36 - 17:41]
のexog exesus（エクセサス）を約800ワードほど読み進めています

[17:40 - 17:43]
。そこには多くの

[17:41 - 17:45]
隠れた複雑さがあります。この単純な例でさえ

[17:43 - 17:47]
、AIは解決策を提案しました

[17:45 - 17:49]
が、追加されたコードは役に立た

[17:47 - 17:51]
ないか間違っていると言えるでしょう。

[17:49 - 17:53]
考慮すべき決定空間は膨大ですが、

[17:51 - 17:56]
AIツールは、

[17:53 - 17:58]
その決定の根拠も、この決定の根拠もなしに、ある決定を選択しなければなりません

[17:56 - 18:00]
。つまり、これは、法学修士（LLM）がコーディングが苦手な理由について、

[17:58 - 18:02]
私が非常に明白だと感じる一つの点に帰着します

[18:02 - 18:05]
。彼らは

[18:03 - 18:06]
目の前の問題を解決し、それが

[18:05 - 18:09]
彼らをコーディングが苦手にするのです。

[18:06 - 18:11]
つまり、私たちがコードをレビューした時、

[18:11 - 18:15]
Devonにしばらくバイブコーディングをさせたのですが、

[18:12 - 18:16]
それが使われているかどうかは分かりません。  Claude 35 か OpenAI を

[18:15 - 18:17]
バックに使っています。

[18:16 - 18:19]
どちらを使ってもあまり問題ではありません。どれも全く

[18:17 - 18:21]
同じことをするのです。コード全体に大量のベクトル演算をインライン化しています

[18:21 - 18:25]
。つまり、

[18:22 - 18:27]
ベクトルの加算も乗算もありません。

[18:25 - 18:29]
ベクトルを作成し、その上で

[18:27 - 18:32]
距離計算、すべての

[18:29 - 18:34]
計算、すべての数学演算を

[18:32 - 18:36]
あらゆる場所でインラインで実行するだけです。AIを

[18:34 - 18:38]
使うたびに、全く

[18:36 - 18:40]
同じことが起こります。

[18:38 - 18:42]
単一空間でやや複雑な処理を

[18:40 - 18:43]
何度も

[18:42 - 18:45]
何度も繰り返します。

[18:43 - 18:46]
最近、オフラインで作っているちょっとしたゲームでやったことです

[18:46 - 18:50]
。まだ見ていないかもしれませんが、

[18:50 - 18:54]
サーバーからのデータに基づいて現在のプレイヤーを選択します。そして、

[18:52 - 18:56]
現在のプレイヤーを選択するたびに

[18:54 - 18:58]
計算をやり直します。mod 2 をやり直します。

[18:58 - 19:02]
配列のインデックス付けと合わせて、剰余演算のような計算をやり直し、

[19:02 - 19:05]
現在のプレイヤーを取り出すための追加処理をすべて行います。 どこにも保存しません

[19:04 - 19:08]
。その代わりに、

[19:05 - 19:10]
何度もインライン展開します。新しい

[19:08 - 19:12]
プロンプトが来るたびに、「ああ、

[19:10 - 19:14]
次のことをもう1つ追加できる」と判断します。そして、

[19:12 - 19:16]
それをやり直して次のことに進みます

[19:14 - 19:18]
。ああ、わかった。次の

[19:16 - 19:19]
ことをやり直せる。もう一度できる。そうでしょう？全く

[19:19 - 19:24]
同じことを繰り返し続けるだけです。素数ではありません。LLM

[19:22 - 19:25]
間でトークン化が異なるのです

[19:24 - 19:26]
。トークン化について話しているのではなく、

[19:26 - 19:30]
出力について話しているのです。LLMはどれも全く同じことをします。つまり、

[19:28 - 19:32]
あなたがサービスを生成し、

[19:30 - 19:35]
反復的に問題を解決していくと、関数の

[19:32 - 19:37]
背後にあるべき複雑なコードを繰り返し実行します

[19:35 - 19:38]
。その判断ができないのです

[19:37 - 19:40]
。その判断はしません。AIの

[19:40 - 19:44]
能力がないため、決してその判断はしません。AIを

[19:42 - 19:46]
使うのはそういう方法ではありません。優れた

[19:44 - 19:48]
プログラマーは、提案された変更を見て

[19:46 - 19:49]
、問題点に気づき、そこから

[19:48 - 19:51]
逆算して作業を進めることができます。例えば、

[19:49 - 19:53]
役に立たない文字列の長さ検証を見て、

[19:51 - 19:55]
代わりに下限値を設定するか、

[19:53 - 19:56]
AIの提案をスキップするかです。しかし、

[19:55 - 19:58]
一般的には自分でコードを書くよりも手間がかかります

[19:56 - 19:59]
。

[19:58 - 20:02]
多くのプログラマーは、

[19:59 - 20:04]
おそらくずっと後になってから問題に気づくかもしれません。まさにその通り

[20:02 - 20:06]
です。プログラミングとは、

[20:04 - 20:08]
大小さまざまな

[20:06 - 20:10]
アーキテクチャの決定、データ検証の

[20:08 - 20:12]
決定、ボタンの色の選択など、多く

[20:10 - 20:14]
の決定の積み重ねです。中には重要でない決定もあり、

[20:12 - 20:16]
安全にアウトソーシングできます。

[20:16 - 20:19]
ソフトウェア開発には確かに大量の定型コードが含まれており、定型コードの

[20:17 - 20:21]
多いコードを書くのにはほとんど

[20:19 - 20:23]
決定は必要ありませんが、

[20:21 - 20:24]
この種の仕事では他の決定が重要です

[20:23 - 20:26]
。コードをどれだけ速く

[20:24 - 20:28]
記述または生成できるかは重要ではありません。

[20:26 - 20:30]
重要なのは、いかに効率的に十分な決定に到達するかです

[20:28 - 20:32]
。AI搭載ツールは、

[20:32 - 20:36]
重要度の低い決定を

[20:34 - 20:38]
ほとんどの場合に正しく独立して解決し、

[20:36 - 20:40]
相関関係として、

[20:38 - 20:43]
追加のレビューが必要な決定にフラグを立てることができれば、ここで役立ちます。適切な決定を

[20:40 - 20:44]
下すために必要なコンテキストを提供できれば

[20:43 - 20:46]
。私たちはこの目標からどれくらい遠いのでしょうか

[20:44 - 20:48]
？彼はAIに責任を求めています

[20:46 - 20:50]
。

[20:48 - 20:52]
私の言いたいことは分かりますか？つまり、

[20:50 - 20:54]
仕事をしているとき、あなたは

[20:52 - 20:56]
他人や

[20:54 - 20:59]
将来の自分に対して、自分が

[20:56 - 21:01]
維持したいコードを書く責任。AIが

[20:59 - 21:03]
責任を感じられるかどうかは分かりません。もしかしたら、そうでは

[21:01 - 21:05]
ないのかもしれません。AIは比較的に

[21:03 - 21:06]
無限の速度でコードを書けるからです

[21:05 - 21:08]
。だから、AIが責任を感じる必要はなくなるかもしれません。

[21:08 - 21:11]
未来の栄光のマスターベーションAI

[21:09 - 21:13]
マスターベーションの時代は、すべてのコードが

[21:11 - 21:15]
簡単に置き換え可能になるからです。コードはもはや堀ではありません

[21:13 - 21:16]
。ただ、

[21:16 - 21:20]
あらゆるものを取り込んだり、取り出したり、置き換えたりできるのです。つまり、

[21:22 - 21:27]
同僚や

[21:24 - 21:29]
将来の自分に対して責任を感じているから、特定のことをしない、という状況があるのですが、行列の乗算に関して

[21:27 - 21:31]
は、そのような責任は存在しません

[21:29 - 21:33]
。しかし、2025年5月現在

[21:31 - 21:34]
、それは起こりません。

[21:33 - 21:35]
この例では、AIは

[21:34 - 21:37]
最適ではない判断を下し、

[21:37 - 21:40]
より良い判断を下すための文脈を与えてくれませんでした。でも、それは

[21:39 - 21:42]
良いことだと思いますよね？それが肝心な

[21:40 - 21:45]
ことではないでしょうか？まるで、私は…

[21:42 - 21:47]
この人のチーム、私とルーカス、

[21:45 - 21:50]
もしくはルカ。名前だけでは、

[21:47 - 21:53]
ルーカス・アトキンソンなのかルカ・サトキンソンなのか分かりません

[21:50 - 21:56]
。だから、

[21:53 - 21:57]
ルーカスだと仮定します。とにかく、ルーカス、私たちは

[21:56 - 21:59]
全く同じチームだと思います。AIは

[21:59 - 22:02]
コードを生成する時に、本当に良いコードにしたい

[22:01 - 22:04]
なら、それに伴う修正がたくさんあるという点で意見が一致しています

[22:02 - 22:05]
。でも、

[22:05 - 22:10]
決定を下すのはあなただと思います。

[22:08 - 22:13]
私がエージェントを使う時は、常にこればかり

[22:10 - 22:16]
考えています。エージェントとは、

[22:13 - 22:18]
とにかく超高速なオートコンプリートです。

[22:16 - 22:21]
オートコンプリートが優れているという意味ではありません。

[22:18 - 22:22]
ただ、私のためにオートコンプリートしてくれたという意味です。

[22:21 - 22:24]
さて、次はオートコンプリートを修正しなければなりません

[22:22 - 22:26]
。ところで、私は

[22:24 - 22:28]
AIにあまり詳しくないですよね？もうご存知でしょ

[22:28 - 22:32]
う。私はAIにあまり詳しくないんです。 これは私が恣意的に選んだわけではない

[22:31 - 22:34]
例です。これは、

[22:32 - 22:36]
カーソルが潜在的な顧客に、

[22:34 - 22:38]
AI を活用したツールがいかに優れているかを実証するために最初に示すものです。

[22:36 - 22:40]
はい。そして、

[22:38 - 22:42]
これは本当に優れていると主張したいと思います。

[22:40 - 22:45]
なぜ優れているのかを正確に示しています。あなたは

[22:42 - 22:46]
行内にインエディターの提案をしました。彼がここで何

[22:45 - 22:48]
を

[22:46 - 22:51]
しているのかわからない人のために、このようにしてみましょう

[22:48 - 22:54]
。このようにしましょう。カーソル、カーソル、カーソル。

[22:51 - 22:57]
ドカン。これらを

[22:54 - 22:58]
行うときはいつでも、

[22:57 - 23:00]
実際に誤って私を

[23:09 - 23:13]
困らせるようなことをしないようにします。この男のところへ行きましょう。よし、ここから出てください。それは何ですか? ええと、はい、はい。クリックします。ここに入れば、これをハイライトして

[23:11 - 23:16]
、コントロール K でクリックして、

[23:13 - 23:18]
これを現代の Go で書き直すことができますか

[23:16 - 23:20]
? 本当のことを言うとそれがどういう意味なのかさえわかりません

[23:18 - 23:22]
。 分かりました。いや、

[23:20 - 23:25]
もう既にモダンですね。slicescontain を使う代わりに、

[23:22 - 23:29]
これを反復的に記述することはできますか

[23:25 - 23:29]
？

[23:32 - 23:36]
まあ、それはそれでいいですよね？

[23:34 - 23:38]
まさに私が気に入っているのは、ここにある Ctrl + K という機能です

[23:36 - 23:40]
。

[23:38 - 23:42]
これは本当に楽しい機能です

[23:40 - 23:43]
。これは本当に

[23:42 - 23:45]
素晴らしいです。そして、

[23:43 - 23:48]
ここで示されているのは、

[23:45 - 23:50]
文字通りコードを開いて

[23:48 - 23:53]
特定のセクションをハイライト表示し、それを

[23:50 - 23:55]
実行できることです。これは素晴らしい

[23:53 - 23:57]
ツールです。正しいツールだと言っているわけではありません

[23:55 - 23:58]
。クールなツールです。全く

[23:57 - 23:59]
異なるものです。見てみましょう。これは

[23:58 - 24:01]
厳選された例ではありません。これは、

[23:59 - 24:02]
Cursor が

[24:01 - 24:04]
潜在顧客に

[24:02 - 24:06]
AI 搭載ツールの優秀さをアピールする際に最初に示すものです。

[24:04 - 24:08]
この例は、おそらく

[24:06 - 24:10]
Cursor のマーケティングチームが、可能な限り

[24:08 - 24:12]
最高のものを宣伝するために厳選したものでしょう

[24:10 - 24:14]
。良い仕事をしたと思います

[24:12 - 24:16]
。  AI搭載ツールが役に立た

[24:14 - 24:17]
ないコードを押し付け、

[24:16 - 24:19]
誤った判断でコードを壊し、

[24:19 - 24:23]
8行の差分表示に800ワードもの

[24:21 - 24:24]
レビューと議論が必要になるような微妙な誤りを加えるとしたら、そのツールは

[24:23 - 24:26]
誰の

[24:24 - 24:29]
生産性も飛躍的に向上させるどころか、

[24:26 - 24:31]
生産性にとってマイナスにしかならないのです。

[24:29 - 24:33]
つまり、私が

[24:31 - 24:34]
AIをあまり使わないのはそのためです。AIは、見たいとも思わないし、どうでもいいものを生成するために使っています

[24:34 - 24:39]
。

[24:36 - 24:40]
自分が生成するもののフロントエンドとして。

[24:39 - 24:42]
「さあ、生成してくれ」って感じですね。 それが

[24:40 - 24:45]
史上最も中程度のウェブサイトのように見えても構いません。

[24:42 - 24:48]
私はそうしようとも思っていません。 私は気にしない。 私は

[24:45 - 24:50]
ただそれをバイブコードして、

[24:48 - 24:51]
修正する必要のあるバグを修正しようとするだけです。

[24:50 - 24:53]
なぜなら私はそれを見たくないからです

[24:51 - 24:54]
。  CSS はやりたくないです。 私には

[24:53 - 24:56]
それと関わりたいことがありません。  「

[24:54 - 24:57]
それで終わりだ」と。だから、これを見ると、

[24:56 - 24:59]
私も同じように思います。

[24:57 - 25:01]
つまり、彼の言っていることは、

[24:59 - 25:03]
正しいと同時に間違っているとも思います。

[25:01 - 25:05]
コードを生成するたびに、それが

[25:03 - 25:07]
自分が大切にしているコードで、

[25:05 - 25:09]
座って全部書き直して

[25:07 - 25:11]
正しく動作するようにしなければならないなら、自分で

[25:09 - 25:13]
一度書けばいいという習熟度を身につけた方がいいでしょう

[25:11 - 25:14]
。コードを

[25:13 - 25:17]
生成しては、それを全部

[25:14 - 25:20]
書き直す必要はありません。それが、どう書き直すべきかを考える助けになるだけなら

[25:17 - 25:22]
、

[25:20 - 25:23]
悪いことでしょうか？もしかしたら、全然悪いことではないかもしれません。もしかしたら

[25:22 - 25:26]
、それは良い方法なのかもしれません

[25:23 - 25:28]
。だって、私は手を動かして考えるのが好きなんです。

[25:26 - 25:30]
コードを手に取って

[25:28 - 25:32]
ホワイトボードに

[25:30 - 25:33]
四角や矢印を描き出すのが好きな人もい

[25:32 - 25:35]
ます。そういう人はいつも「一日中コードを書く人の気持ちが分からない

[25:33 - 25:37]
」と言います。80

[25:35 - 25:39]
%の時間は考えるべきです。私は「ちくしょう、

[25:37 - 25:40]
全然考えない」って感じです。でも、私はそうしません

[25:39 - 25:42]
。私は手を動かして考えます。

[25:40 - 25:43]
そして、何かを書き上げます。書くんです、そうでしょう？

[25:42 - 25:45]
そう、そう、そう。そして、「ああ、

[25:43 - 25:46]
これいいね」って思うんです。 はい、これは気に入らないですね。 わあ、

[25:45 - 25:47]
それについては考えたこともなかったよ。 私は

[25:46 - 25:49]
それを決して理解できなかったでしょう。 はい、

[25:47 - 25:51]
これは気に入りました。 はい、その部分は気に入りました

[25:49 - 25:53]
。 ああ、そうだ。 本当に幸せな気持ちになります

[25:51 - 25:55]
。 はい、ドカン。 自分がやったことは気に入っています。

[25:53 - 25:57]
すべてを削除します。 読んでください。 ブーム。 これは

[25:55 - 25:59]
私の新しいお気に入りです。 これが

[25:57 - 26:01]
私です。 今私が書いたものが今の私のアイデンティティであり、

[25:59 - 26:03]
それは美しく、そして

[26:01 - 26:06]
素晴らしいものです。 終わりですよね？

[26:03 - 26:07]
私はそう思っています。 だから誰もが

[26:06 - 26:10]
そのように考えるわけではないのです。

[26:07 - 26:11]
ただ座って、紙に何かを書いたり

[26:10 - 26:14]
するのを好む人もいます。

[26:11 - 26:16]
私にはそれが狂っているように思えます。 しかし、繰り返しますが、

[26:14 - 26:17]
それはデザインと呼ばれています。 それがあなたのアイデンティティではないことは理解しています

[26:16 - 26:20]
。 しかし私はデザインをします。 ほら、

[26:17 - 26:23]
私は自分の手でデザインするんです。 私は

[26:20 - 26:25]
紙に書いてデザインするわけではありません。

[26:25 - 26:30]
すべてのエッジケースを知ることはできないので、すべてのエッジケースを発見します。

[26:28 - 26:32]
実際にそのものを構築するまで、エッジケースはわかりません

[26:30 - 26:34]
。 なぜなら、

[26:32 - 26:37]
あなたが構築するもののほとんどにおいて、

[26:34 - 26:39]
すべての問題点を把握していないことが問題だからです。 そして、

[26:37 - 26:42]
それを発見した瞬間、

[26:42 - 26:46]
それまで考えていたことのすべてが無効になるか、あるいは

[26:44 - 26:48]
半分が無効になることが判明します。 あらゆる創造物に当てはまります

[26:46 - 26:49]
。 その通り。 フィードバックループは

[26:48 - 26:51]
不可欠です。 わかったよ、ジェレミー。 それで、

[26:51 - 26:54]
生成されたコードを使って

[26:52 - 26:56]
解決策を見つける人がいるのは悪いことなのでしょうか? いいえ。

[26:54 - 26:59]
本当に悪いのは、

[26:56 - 27:00]
ただコードの雰囲気を漂わせている人たちだけだと思います

[26:59 - 27:03]
。

[27:00 - 27:04]
大規模なセキュリティ問題やバグが発生することになります。

[27:03 - 27:06]
彼らは

[27:04 - 27:08]
LLMの素晴らしさに夢中になるだろう。

[27:06 - 27:11]
つまり、本当に唯一の

[27:08 - 27:12]
危険は、自分の人生にどれほどひどいことが起ころうとしているかに気づかずに、

[27:11 - 27:15]
純粋にバイブでコード化した何かを解放してしまうことです

[27:15 - 27:19]
。 そして私は

[27:18 - 27:21]
本当にセキュリティについて最も懸念しています

[27:19 - 27:23]
。 私はまだ、私はまだ、

[27:21 - 27:25]
これをTwitterに投稿しました。 私は

[27:23 - 27:26]
実際にその写真を保管していたと思います

[27:25 - 27:29]
。 持続する。 ここに写真を保管しておいたと思いました

[27:26 - 27:30]
。 こんな感じで行きましょう。

[27:30 - 27:35]
面白いので写真を撮ったのは確かです。 はい、そうしました。 えっと、XDG

[27:33 - 27:37]
オープン。  XDGオープンは使えますか？

[27:35 - 27:39]
できるかどうか分かりません。 パスキーは必要ありません

[27:37 - 27:41]
。 わかりました。これを開くにはパスキーが必要そうです

[27:39 - 27:43]
。 セッションデータは安全ですか?

[27:41 - 27:45]
つまり、誰かのユーザー名

[27:43 - 27:46]
と ID を知っていたら、それを自分のセッションに追加して偽装できるのでしょうか

[27:45 - 27:50]
? 言い換えれば、ユーザーのなりすましを防ぐ

[27:46 - 27:52]
ために、データに署名したり、何らかの jot dwat を作成したりすることはできるでしょうか

[27:50 - 27:54]
? それはセキュリティ上の非常に

[27:52 - 27:55]
良い懸念です。 現在、

[27:54 - 27:57]
セッション データは改ざんに対して暗号的に安全ではありません

[27:55 - 28:00]
。 これを改善しましょう

[27:57 - 28:02]
。 カーソルを使用して Web サイトを構築したところ、

[28:00 - 28:04]
文字通り、Cookie を編集できるログインが作成されました

[28:02 - 28:06]
。 自分のセッションを編集して、

[28:04 - 28:08]
Twitch ユーザー名を入力するだけで

[28:06 - 28:11]
、あなたは今その人になります

[28:08 - 28:13]
。 それがあなたなのです。 あなたこそその

[28:11 - 28:15]
人です。 それは恐ろしいですね。

[28:13 - 28:19]
バイブコードに行く人のうち、おそらくそれを持っている人がどれくらいいるかご存じですか

[28:15 - 28:21]
? ああ、いい発見だ。

[28:19 - 28:25]
基本 B。たとえば、「

[28:21 - 28:27]
ねえ、データに署名したほうがいいかもしれないね」と提案する必要があります。

[28:27 - 28:31]
データに署名することが何であるかさえ知らないと、破滅することになります。

[28:29 - 28:35]
私がそれを知っているのは、

[28:31 - 28:36]
JWT が存在する前に JWT を書いて、

[28:35 - 28:38]
独自のログインを書かなければならなかったからです。 私は独自のログインを作成し

[28:36 - 28:40]
、独自のパスワードハッシュなどを作成しました

[28:38 - 28:41]
。 これは実際、

[28:40 - 28:44]
私たちの将来にとって恐ろしいことです。 それは

[28:41 - 28:46]
我々の将来にとって恐ろしいことだ。 ですから、

[28:44 - 28:48]
これらのことを知っておく必要があります。 ありがとうございます。

[28:46 - 28:52]
申し訳ありません、おっしゃる通りです。 病院は

[28:48 - 28:54]
合法的な軍事目標ではない。

[28:52 - 28:55]
それはとても面白いですね。 それは本当に

[28:54 - 28:57]
真実です。  Shaw 256 で独自のトークン システムも作成しました。 まさにその

[28:55 - 28:59]
通りです。  Shaw 256。MD5 は

[28:59 - 29:03]
不良だと考えられていたので、これを使用しました。 したがって、MD5 は使用しませんでした。

[29:01 - 29:06]
そこで、Shaw 256 を使用しました。バダビン、

[29:03 - 29:08]
バダボン。 それは実に単純なことでした。

[29:06 - 29:09]
私が昔最初にこれをやったときと同じように

[29:08 - 29:12]
、ユーザー オブジェクトである JSON オブジェクトを生成していました

[29:09 - 29:15]
。

[29:12 - 29:18]
次にこれを Base 64 でエンコードし、

[29:15 - 29:22]
最初に

[29:18 - 29:25]
Shaw 256 でエンコードされた SHA 256 ハッシュを添付して、

[29:25 - 29:29]
これをセッションとしてユーザーに送信します。

[29:27 - 29:32]
少なくとも、

[29:29 - 29:34]
これを生成したことはわかっているからです。 したがって、たとえ

[29:32 - 29:36]
あなたがこれを何らかの方法で操作したとしても

[29:34 - 29:38]
、私はあなたが何かをしたのであって、

[29:36 - 29:40]
それが私のものではないことを知っています。 それが私が知っていたすべてだったかのように

[29:38 - 29:42]
。 これは私が 2009 年に自分で O を作ったときのものです。MD5 は

[29:40 - 29:45]
操作可能です。 だから

[29:42 - 29:48]
私はMD5をやらなかったのです。 私は256を撃ちました。こんにちは、

[29:45 - 29:49]
名前は、ところで、私は大好きです、私は

[29:48 - 29:51]
実際にこの記事がとても気に入りました。

[29:49 - 29:53]
彼は、

[29:53 - 29:58]
コードに関して LLM のみに依存することがなぜ危険であるかという理由をすべて文字通り指摘していると思います。

[29:56 - 30:00]
素晴らしい記事でした。 問題はフレーミングだけです

[29:58 - 30:02]
よね？

[30:00 - 30:04]
カーソルは純粋にマイナスであるというフレーミングでした。 カーソルは、

[30:02 - 30:05]
実際にはこれらのツールとのかなり根本的な統合のセットです

[30:04 - 30:08]
。

[30:05 - 30:10]
爪がついてます。 ここで本当に問題となっているのはオープン AI です

[30:08 - 30:14]
よね? まるで私があなたのチームの一員であるかのように

[30:10 - 30:19]
、ルーカス。 素晴らしい指摘をいただきました

[30:14 - 30:19]
。 とても気に入りました。 名前は

[30:19 - 30:25]
プライムです。 ああ、わかりました。

[30:22 - 30:27]
でも、今はとても変な気分です。

[30:25 - 30:30]
インターネット上ではみんなが私を

[30:27 - 30:34]
反AI派として見ているのに

[30:30 - 30:37]
、私はここで擁護しているからです。

[30:34 - 30:41]
これは何なんだろう？という感じです。 私は

[30:37 - 30:43]
反 AI 派でしょうか、それとも AI 派でしょうか? 右？

[30:41 - 30:44]
私はAIじゃないよ。 わかったよ、僕は AI じゃないんだ

[30:43 - 30:46]
。 それはご存知ですよね。 あなたはそれが真実であることを知っています

[30:44 - 30:48]
。 おい、売り切れてるぞ。 おい、

[30:46 - 30:50]
私はとても変な気分だ、というのも、そうだ、

[30:48 - 30:52]
私も AI が好きじゃないけど、

[30:50 - 30:54]
君の前の提案のいくつかは

[30:52 - 30:56]
間違っているように感じるからだ。  AI、

[30:54 - 30:58]
兄弟、おい。 私はAI兄弟ですか？  AIブーマー。

[30:56 - 30:59]
ブルーマー。 ああ、私は AI ブルーマーです、

[30:58 - 31:01]
おい。 私はこれをブルマーと呼ぶというアイデアが気に入りました

[30:59 - 31:02]
。 そんなことは起こりません。 ブー。

[31:01 - 31:04]
知っている。 どうしてこんなことが起きたのでしょうか? どう

[31:02 - 31:06]
したの？ 私はただの男です。 何度も

[31:04 - 31:08]
同じことを繰り返すのではなく、微妙なニュアンスのある意見を持つことです

[31:06 - 31:10]
。

[31:12 - 31:16]
AIの超賛成派の人たちがいつもTwitterで私に意地悪なことを言ったり、

[31:16 - 31:20]
AI反対派の人たちがいつも私をAI小僧と呼んだりするから、あなたはただ単にみんなから嫌われているということでしょうか

[31:18 - 31:22]
。 だから、どうしてみんなを失ったのか自分でも分からないんです

[31:20 - 31:25]
。 どうして

[31:22 - 31:25]
負けたのか

## コメント

### 1. @KelvinShadewing (👍 471)
Is there nothing besides AI to talk about anymore?

> **@allesarfint** (👍 76): Shareholders yearn for AI

> **@themcdonal** (👍 32): never. keep up this tempo for another 3 years. just like the andrew tate stuff in 2020. more slop!!!!!!!!!!!!!!!!!!!

> **@loicjeannin6233** (👍 21): Well, according to the hype (and Jensen), there is no need for developers anymore, only AI. So I guess this is a existential question for us that live in techno (not really, the BS has short legs)

> **@livinghuman2298** (👍 3): ​@@themcdonali hope so.

> **@resin3624** (👍 5): I hope we get to the end of this

### 2. @InfiniteQuest86 (👍 479)
Prime defends AI by saying it's good because of the way no one uses it. Literally everyone just generates code and trusts it. Which is what this article is pointing out is terrible. Prime is like no one would do that. You are wrong. They do that.

> **@itztlacoliuhqui** (👍 46): So true. The thing is, if its a little bit of code then its faster for me to write it myself. If its a lot of code though, I aint reading all that

> **@aokijikuzan6453** (👍 18): He's saying that that is on them then, the developer is still responsible for what goes to production.

> **@InfiniteQuest86** (👍 18): @@aokijikuzan6453 Yeah I completely agree in principle. Of course that should be true. But how true is in reality? We recently got some psychotic clearly AI generated code. And a lot of pressure to merge it because of deadlines. It just makes unnecessary work for the reviewers. Because there's never going to be any accountability for the developer shipping features even if the code is terrible.

> **@TheOrionMusicNetwork** (👍 10): @@InfiniteQuest86 Getting pressure to ship shit code isn't an AI issue. You should have code quality standards, and if they are clearly not being met, it should be stopped by the tech lead, unless a decision is made that the situation is truly urgent enough that it actually makes sense for the business to risk (e.g. literally hours away from losing a key customer). Other than that, if someone keeps writing shit code, they should eventually see disciplinary action, and if they don't, then you have much much bigger issues (tbf, it's an issue that I see most tech companies having, but this was annoying before LLMs, and will continue to be so for companies that simply refuse to fire to shit developers no matter their lack of productivity)

> **@NottoriousGG** (👍 0): Lol no, trust only every single line you read.

### 3. @TennSeven (👍 204)
The "bro doesn't even know how to spell skeptical" person is an idiot.  "Skeptical" and "sceptical" are both correct.  The latter is how they prefer to spell it in the UK.

> **@AdamJorgensen** (👍 0): Less an idiot and more just illiterate, like a lot of Americans.

> **@fatboy158** (👍 0): Bri*ish 🤮

> **@nikarmotte** (👍 46): Scill issue.

> **@Dom-zy1qy** (👍 16): UK = wrong, so I have to agree with the chatter.

> **@diegofloor** (👍 0): You are probably right, but it does sound weird. Makes me want to read it like one reads "septic tank"; a tank that really isn't buying this whole covid bs.

### 4. @isodoublet (👍 49)
"You're prompting it wrong!!"

-- Steve Jobs, 2009

### 5. @0xCAFEF00D (👍 53)
16:50
He keeps missing the nuance in this critique of _cursor_.
It's not about the LLM just guessing it's way to the fact that you need to be more specific in the prompting within every query. It's cursor that should allow the LLM the space to validate this. The utility of cursor is severely deminished if it just tosses the problem to an LLM and naively accepts the output. It's a poor integration.

> **@TonyMurray** (👍 8): They also have to manage their token budget...

> **@MikeStoneJapan** (👍 0): @@TonyMurray This this this

> **@livinghuman2298** (👍 0): ​@@TonyMurrayi heard about these tokens recently, it's so expensive and no one talks about that.

> **@steveoc64** (👍 5): @@TonyMurray yep - let’s create a hard dependency in our dev tools to an external business model that is losing money on every transaction at a 3:1 ratio

Do you think one day they might 5x the pricing once we are hooked ?

> **@thenonsequitur** (👍 1): @@steveoc64 If it was 5x the price I would still purchase it. It's worth way more to me than they are charging right now.

### 6. @McZsh (👍 74)
A week and a half ago, I had a review with one of our junior guys, he called me he is ready to commit, but the darn thing won't build. 

Fast forward an hour, I sit next to him and watch him do what he wants to achieve. Build process fails with a message of a missing  brace, file and line give. We delve into the editor, the line has a red squiggly with a message "brace missing". I point at it and say "there it is". 

Junior copies the whole line into the prompt and asks "what is wrong with this code?" LLM generates half a novel of an answer , bottom line "missing brace" and returns the line, with a brace added, 7 letters in total longer. Copy, paste, build. Junior thanks me, full of himself. Real dev he his, right!? I stared on him for a full 10 minutes and then mangled  him on his own code for a full three hours. It was total and utter horseshit.

So, bottom line... the criticism of LLMs and their perceived vs their real world usage is totally correct.

And I'll add a question: "Is AI generated crap without any barriers and best practices applied what we  developers as a profession want to profess to the next generation, and to the customer, indeed?" 

(The original question is from Robert C. Martin, I just added the AI perspective)

> **@vipvip-tf9rw** (👍 3): Ai is cool when having strong base knowledge and willingness to proof read it's output, but In production I will not trust it enough on more complex matters, in my experience, I used it for terraform deployment for learning, it made some mistake over and over again, I gave it insert from manual, which described function and it fixed the issue, the thing is, I could totally fix it my self, but for less experienced coders I would think that would be big trouble, especially on less verbose platforms

> **@juanjosefarina** (👍 4): AI assistants will only make developers dumb. Psychology has known the importance of writing in learning and metacognitive processing since 100 years now, with Vigotsky's works. Many developers now don't think, don't write, and perhaps neither talk about code. A.K.A, developers will not know about code in a very near future if they insist on using AI assistants.

> **@mattymattffs** (👍 4): I hope you fired that junior

> **@jamesarthurkimbell** (👍 6): Error messages do the one thing that LLMs can't, which is to consistently and honestly disagree with you.

> **@hanifarroisimukhlis5989** (👍 1): If i were you, that junior "dev" is beyond 🔥🔥🔥

### 7. @dgo4490 (👍 66)
It doesn't t have to make money, just move money around.

> **@spaceowl5957** (👍 5): raisin that GDP baby

> **@RealRatchet** (👍 0): ​@@spaceowl5957that's not the best way to raise GDP, best way is to print money and spend it. Government spending is counted towards GDP.

> **@arjavgarg5801** (👍 0): And just take on more debt

> **@mk9430-d8v** (👍 0): "Make money" commonly means to create value and transfer money, not to increase money supply.

### 8. @lazyplayer1 (👍 49)
wait did you finish that cursor shill tower defense game ? w fuckign lua btw

> **@gunarcom** (👍 3): he on that fence like humpty dumpty

> **@keyboard_g** (👍 16): Prime doesn’t finish projects.

> **@Definesleepalt** (👍 10): i think they realized game dev is a bit harder than it seems and stopped. most of the time working on the game after is put under membership view only so we will never know

> **@clray123** (👍 3): @@keyboard_g The guy earns his money from blabber, not from code.

### 9. @gsgregory2022 (👍 36)
At the 16:50ish mark. I think you missed the point. Yes an llm will just output an answer, however the point is that cursor a tool built on top of ai, doesn't do much more than implement the answer from the llm.

### 10. @Ratstail91 (👍 71)
I'm seriously considering switching to vim full time  maybe neovim  never looked into it.

I'm so sick of AI.

> **@monsterhunter445** (👍 5): You don't need ai and yeah just stick with classics. Heck even vscode with AI is fine..but neovim is good depending on what you do I am a c++ dev so I use neovim and nvchad and install clang and you got a lsp for c and c++.

> **@_anlim309** (👍 0): Try the neovim for vscode extension, it's a really good gateway into vim motion, it mostly only cover text or in-file navigations but once you get used to navigating code in him you'll never looking back ever again, I have to use jetbrain IDEs on some remote deployment stuff because their deployment tools are just godsent and everytime I have to write codes on them it's just pure pain. Like let me ci" Instead of having to touch my mouse and select those long texts 😂

> **@mr.builder1225** (👍 0): @@monsterhunter445 I tried nvim for couple months, but i switched to vscode because it easily connects to GDB and its really easy to debug, using clangd as LSP in vscode solved most of the performance issues for me.

> **@cz7259** (👍 10): For me it's all about fun (motivation to work). Nvim give me so much of the fun, and cursor is 100% net negative in that regard. It's not about efficiency (although it is what nvim users argue for), and it's about actually spending the time.

> **@andreilucasgoncalves1416** (👍 1): I think you should just use the IDE normally and when you think AI will be good for the task you use it, it is a tool like any other

### 11. @kavajawa (👍 18)
I wonder how many people voting for the skill issue wrote a single program more advanced than Fiz-Buz…

> **@kaiser2261** (👍 0): if youre using python LLMs are extremely good. Rust is one of the worst performing languages

### 12. @pchasco (👍 35)
The biggest takeaway is that if vibe coders take over, we are all fucked. When you have to very explicitly spell out the requirements down to the smallest detail in order to expect a correct result, vibe coders have no chance in hell of creating anything more than throwaway AI slop.

> **@landlubbber** (👍 8): Sounds like a great business opportunity for people who know how to program properly

> **@cataliniancu5318** (👍 6): All I can see it as is that true skill grows in value.

> **@pchasco** (👍 7): @@cataliniancu5318Hope so. If so, it’s going to take several catastrophic mistakes to prove to the C[ITEF]O class that maybe they can’t replace their engineers with AI.

> **@MoonShadeStuff** (👍 7): AI is just a tool, can’t replace a programmer with an IDE, can’t replace him with AI, but programmers who can use AI may have an advantage in the future.

> **@Eldarlll** (👍 6): If only we had a strict language to describe very precisely what we want computer to do...

### 13. @DePhoegonIsle (👍 47)
Sorry, that's a curser issue.   Other IDEs will actively point out code that is either 'unreachable' or conditions that will always be true/false, given their location.  IntelliJ does this, and I have to admit has caught several times where I'd had invalid/unnessary checks, that got there by accidental re-organizing and the logic wasn't entirely thought through.

It is a partial  LLM issue, sure.. but the IDE should know to spot the invalid/impossible/redundant/useless code/statements.  

Seriously.    THe problem is that people blindly trust the code without thinking, and if your IDE isn't flagging useless states, impossible states, or flawed states..... it's a bad IDE.

> **@codeheretic** (👍 23): It's not even an IDE feature, most LSPs will do this. They should get this for free simply by being a VSCode fork.

> **@TheOrionMusicNetwork** (👍 2): Who says that Cursor doesn't do this? Cursor does check for linting issues and will actively iterate on the code to fix them, as do most half decent agents nowadays. That isn't an LLM issue, that's a product design issue of simply not passing in relevant context to an LLM (which I don't believe is the case anyway as this may have been true in the very early days, but since around 2025 xmas + most of them have been capable of checking for linting errors, and quite a bit more than that e.g. running tests etc...)

> **@thenonsequitur** (👍 0): Cursor has this ability. It just wasn't showcased in the ad.

> **@Sokrates9500** (👍 0): I don't think notepad does this

> **@evotech** (👍 0): Cursor can use any extension vscode has, you can use problem finders, linters, and everything else which cursor can then feed its inference models with

### 14. @KevinCoddington (👍 5)
A lot of time is spent dogging on LLMs for the "AI slop" containing logic and security flaws that will have downstream effects. It's kind of baffling to me that we all think even SENIOR level programmers don't do this already. We expect the LLM to spit out perfect code on the first try with ambiguous prompts, don't provide rules/guardrails, and don't allow it to iterate over what it already generated (like a real programmer would do). Ya know, like all of us SENIOR coders are able to nail on the first try.

> **@TheNewton** (👍 0): Because skill issues exist we should embrace more and new types of skill issues.
Is that supposed to be reasonable

### 15. @Dom-zy1qy (👍 6)
Net negative productivity happens when you use "Agent" mode and Sonnet's logits (the voices in its head) tell it to refactor the entire codebase, implement random design patterns, rename classes, methods, and update comments when you ask it to make a minor change to one file.

> **@Alex-bx3st** (👍 0): This is why I use gemini 2.5 pro. It doesnt refactor other things as much unless I ask it to

> **@clray123** (👍 2): @@Alex-bx3st Ah but it does. Stripping comments from existing code willy-nilly is the most obvious.

### 16. @benjaminkemper5876 (👍 4)
I found this channel right when it went from a channel about programming and stuff to a channel dedicated to AI.

### 17. @frankfrei6848 (👍 1)
11:35 yes, you're wrong. It *is* bad code because of all the magic numbers. Define them as constants with sensible names. This looks like rookie-high-school-I-wrote-my-first-program code.

### 18. @AbcDino843 (👍 10)
I have grown to distrust the AI response in web search engines because of how inaccurate they are, and I am supposed to trust the code they create!?

> **@artificialbeingz** (👍 0): which Ai are you using?

> **@elorrambasdo5233** (👍 1): ​@@artificialbeingz🤪

### 19. @gardnmi (👍 24)
ai is great for starting a project and terrible for maintaining a project

> **@randomstuff_video** (👍 0): For MVPS

> **@mikeyim9985** (👍 3): It is literally the opposite… high level architectural design should be done by you and all the dumb, repetitive, and tedious parts of implementation should be done by the ai agents that are effectively just cracked out intern. It does better with established best practices vs shooting from nothing and letting it establish those patterns for you. It works better on mature codebase (as long as that code base is not a mess of a thing lol)

### 20. @mattymerr701 (👍 4)
LLM issues _are_ Cursor issues. That is the entire point of cursor, to use LLMs and if it cant do that well then it is a bad tool, even if the issue is on a system in the backend.

