# I Backdoored Cursor AI

**チャンネル:** John Hammond
**公開日:** 2025-04-08
**URL:** https://www.youtube.com/watch?v=FYok3diZY78

## 説明

https://jh.live/plextrac-408 || Save time and effort on pentest reports with PlexTrac's premiere reporting & collaborative platform: https://jh.live/plextrac-408 😎

https://github.com/boku7/Loki
https://www.ibm.com/think/x-force/bypassing-windows-defender-application-control-loki-c2

Learn Cybersecurity and more with Just Hacking Training: https://jh.live/training
See what else I'm up to with: https://jh.live/newsletter
🏆Attend ContinuumCon, the practical online cybersecurity conference that never ends! Livestream begins June 20th, 2025: https://jh.live/continuumcon

ℹ️ Affiliates:
Learn how to code with CodeCrafters: https://jh.live/codecrafters
Host your own VPN with OpenVPN: https://jh.live/openvpn
Get Blue Team Training and SOC Analyst Certifications with CyberDefenders: https://jh.live/cyberdefense
Master Binary Files and Protocols with Gynvael Coldwind: https://jh.live/hackarcana (code MBF-JH-10 gives 10% off!)

## 字幕

[00:00 - 00:04]
AI コード エディター カーソルは、

[00:02 - 00:08]
electron ベースのアプリです。 つまり、

[00:04 - 00:11]
Node.js を使用して JavaScript を実行し

[00:08 - 00:13]
、通常は

[00:11 - 00:16]
Web ベースのコンテンツをレンダリングするための Web ベースのコードを実行しますが、

[00:13 - 00:18]
Electron はデスクトップ コンピューター上でローカルに実行されます

[00:16 - 00:20]
。 現在、

[00:18 - 00:23]
さまざまな Electron アプリケーションが数多く存在します。

[00:20 - 00:26]
もちろん、Cursor と VS Code ですが、

[00:23 - 00:29]
Discord、Slack、Zoom、Microsoft

[00:26 - 00:31]
Teams、Notion、Obsidian、Signal

[00:29 - 00:34]
、GitHub Desktop も考えてみてください。  Electron を使用してデスクトップで

[00:34 - 00:39]
実行される最新のソフトウェア スタック向けのソフトウェア ソリューションは数多く存在し、

[00:39 - 00:44]
おそらくこれらは毎日使用していることでしょう。

[00:41 - 00:46]
そうですね、つい最近、友人の Bobby Cook が

[00:46 - 00:50]
侵入テスト、レッドチーム、

[00:48 - 00:54]
攻撃的なサイバー セキュリティ作業用の非常に優れたツールを作成し、

[00:54 - 00:59]
Electron アプリケーションにバックドアを設置する NodeJS ベースのコマンド アンド コントロール フレームワークを構築しました

[00:56 - 01:02]
。 彼はそれをLoki C2と呼んでいます。 そこで、

[00:59 - 01:05]
このビデオでは、

[01:05 - 01:09]
脆弱な Electron アプリケーションにバックドアを仕掛けるための NodeJS コマンド アンド コントロール フレームワークである Loki をセットアップしてデモを行いたいと思います

[01:07 - 01:12]
。 今ならこれをオンラインで見つけることができます

[01:09 - 01:12]
。 これは GitHub にあります。

[01:13 - 01:17]
github.com/bokku7/lokkey.

[01:15 - 01:19]
下にスクロールして、

[01:17 - 01:21]
ここでの説明の背景にある概念をいくつか紹介します。  Loki は、

[01:21 - 01:26]
Electron アプリケーションにバックドアを仕掛けて

[01:23 - 01:28]
アプリケーション制御を回避するためのステージ 1 のコマンド アンド コントロールです。 そして実際、

[01:26 - 01:30]
それがこのことの核心ですよね？

[01:28 - 01:33]
おそらく、Microsoft Teams、

[01:30 - 01:35]
VS Code、または Cursor を使用しているためです。 だからこそ、

[01:33 - 01:37]
このデモではカーソルをターゲットにしたかったのです。

[01:35 - 01:39]
カーソルは、AI の最新

[01:37 - 01:41]
機能や、すでに誰もが使用している

[01:39 - 01:43]
バイブレーション コードなどに重点を置いているからです。

[01:41 - 01:45]
カーソルがインストールされている場合、

[01:43 - 01:47]
これを使用してシステムにバックドアを設置できる可能性があります。 この

[01:45 - 01:50]
手法は、署名された脆弱な Electron アプリケーションの信頼を悪用して、

[01:50 - 01:54]
ターゲット システム上で実行を取得します。  UI と

[01:52 - 01:55]
インターフェースのようなグラフィックは

[01:54 - 01:58]
かなりクールです。 しかし、この説明を見てください

[01:55 - 02:00]
。 実行時に、Electron

[01:58 - 02:02]
アプリケーションは JavaScript ファイルを読み取り、

[02:00 - 02:04]
そのコードを解釈し、

[02:02 - 02:06]
Electron プロセス内で実行します。

[02:06 - 02:11]
Electron アプリである Microsoft Teams が

[02:09 - 02:14]
実行時に JavaScript ファイルを読み取り、

[02:11 - 02:16]
その後 NodeJS 子プロセス モジュールを使用して単純な who am I.exe

[02:14 - 02:19]
などの他のプログラムを実行する方法を示した、かわいらしいアニメーションがあります。

[02:16 - 02:21]
Electron

[02:19 - 02:23]
アプリケーションは実行時に JavaScript を実行するため

[02:21 - 02:25]
、これらの JavaScript ファイルを変更すると、

[02:23 - 02:28]
攻撃者が

[02:25 - 02:30]
任意の Node.js コードを Electron

[02:28 - 02:33]
プロセスに挿入できるようになります。  Node および Chromium API を活用することで

[02:30 - 02:35]
、JavaScript コードはローカル オペレーティング システムと対話できるようになります

[02:33 - 02:38]
。 独自の Electron アプリ プログラム

[02:38 - 02:42]
内で実行することを意図したものだけでなく、任意のコードをコンピューター上で実行できます

[02:40 - 02:44]
。  Loki は、

[02:44 - 02:48]
アプリケーションの JavaScript

[02:46 - 02:50]
ファイルを Loki C2 JavaScript ファイルに置き換えることで、Electron アプリにバックドアを仕掛けるように設計されています。

[02:48 - 02:52]
彼は素晴らしいブログ記事でさらに詳しい情報を公開しており、

[02:50 - 02:54]
私も

[02:52 - 02:56]
それを参照したいと思っていますが、これは舞台裏で非常に興味深い内容であることは承知しています。また

[02:59 - 03:03]
別の動画で詳しく説明する価値のある素晴らしい情報の中には、バック

[03:01 - 03:05]
グラウンド コンテキストのトリックや、

[03:03 - 03:06]
Electron アプリで実行できる機能など、さまざまなものがあります。

[03:05 - 03:08]
ええと、

[03:06 - 03:10]
皆さんがそれを見たり、見たりできるように、ビデオの説明にリンクを貼りたいと思います

[03:08 - 03:11]
。 しかし、

[03:10 - 03:13]
このビデオだけで私たちをウサギの穴に引きずり込むつもりはありません

[03:11 - 03:16]
。

[03:13 - 03:18]
Loki C2 の使用デモを見てみましょう。 これには少し設定が必要です

[03:16 - 03:20]
が、それは

[03:18 - 03:22]
素晴らしい機能がすべて揃っているからです。 これは、

[03:20 - 03:24]
コマンドと制御チャネルに Azure ストレージ BLOB を使用します

[03:22 - 03:26]
。 すべてのメッセージは

[03:24 - 03:28]
暗号化されています。 ストレージ アカウントを保護するためにトークンを使用します

[03:26 - 03:29]
。

[03:28 - 03:31]
プロキシ対応エージェントを使用するので、必要なものをすべて通過させることができます

[03:29 - 03:33]
。

[03:31 - 03:35]
チームサーバーがないので、かなり便利です。

[03:33 - 03:37]
guey クライアントとエージェントは両方とも、

[03:35 - 03:39]
コマンドと出力について同じデータ ストアをチェックします。

[03:37 - 03:41]
そして、隠しウィンドウ、堅牢な

[03:39 - 03:43]
例外などなど。 ご存知のとおり、

[03:41 - 03:45]
クールな C2 サーバーです。  Loki が

[03:43 - 03:47]
実行できるコマンドは予想どおりですが、

[03:45 - 03:49]
非常に便利です。 すべてのエージェント コマンドは

[03:47 - 03:51]
ネイティブ Node.js で記述されており、

[03:49 - 03:53]
追加の依存関係や

[03:51 - 03:55]
ライブラリ ロード イベントは必要ありません。 確かに、

[03:53 - 03:58]
シェル コードとアセンブリを実行するためのいくつかの機能があり、

[03:55 - 04:00]
kear.node と

[03:58 - 04:01]
assemble.node、node にライブラリがロードされますが、

[04:01 - 04:06]
子プロセスの生成、リスト、ドライブ、スリープ、ロード、アセンブリ、アップロード、ダウンロードなどの間で実行できる可能性のあるすべての機能を確認できます

[04:06 - 04:10]
。

[04:07 - 04:13]
これについては readme で詳しく説明しますが、

[04:10 - 04:14]
私はパーティーに飛び込みたいと思っています。 この

[04:13 - 04:16]
デモでは、 3 つの

[04:14 - 04:18]
異なる仮想マシンを使用します。 最初は

[04:16 - 04:19]
被害者です。 現時点では、これは単なる Windows 11

[04:18 - 04:21]
ホストです。

[04:19 - 04:23]
ライトモードで設定したので、明らかです。 それが

[04:21 - 04:25]
目標です。 攻撃者側では、

[04:23 - 04:27]
Kali Linux を使用して敵として行動します

[04:25 - 04:30]
。 また、

[04:27 - 04:32]
攻撃者と Windows マシンも使用します。 これは

[04:30 - 04:34]
ダーク モードで設定されるため、

[04:32 - 04:37]
攻撃者は明らかですが、ライト モードは

[04:34 - 04:39]
被害者です。 さて、実際にカーソルをインストールしてみましょう

[04:37 - 04:41]
。 最新バージョンの Cursor を入手します

[04:39 - 04:44]
。  Windows用にダウンロードできます。

[04:41 - 04:46]
素敵で簡単です。

[04:44 - 04:48]
録音時点では 0.48.7 でした。

[04:46 - 04:50]
そのフォルダを開いてこの

[04:48 - 04:52]
プログラムをインストールできます。 ダブルクリックカーソルの設定。

[04:50 - 04:54]
これをすぐに説明させてください

[04:52 - 04:56]
。 そして実際、

[04:54 - 05:00]
これがインストールされている間に、非常に

[04:56 - 05:02]
興味深いパス、スラッシュ アプリ データ

[05:00 - 05:04]
スラッシュ プログラムが表示されることがあります。 インストール中に見たことがあるかもしれませんが

[05:02 - 05:06]
、これは

[05:04 - 05:09]
通常、カーソル自体がインストールされる場所であり、

[05:09 - 05:15]
node.js または electronic ファイルはすべて残されるか、少なくとも配置されます。 それは

[05:13 - 05:17]
私たちがすぐに検討する適切な道です

[05:15 - 05:19]
。 はい、カーソルが完成しました。  「

[05:17 - 05:22]
完了」をクリックします。 それでは、

[05:19 - 05:24]
カーソルを起動して

[05:22 - 05:26]
ログインし、実際にアプリケーションが実行できるようにしてみましょう。

[05:26 - 05:32]
エンド ユーザーの実際の被害者ターゲットとして、

[05:33 - 05:37]
プログラムにバックドアを仕掛けているという概念を理解してもらいたいからです。 ログインしましょう。

[05:36 - 05:40]
いいですね。 すべて準備完了です。 ログインしました。

[05:37 - 05:42]
さあ、調理を始めましょう。

[05:40 - 05:44]
はい、カーソルは実行中です。

[05:42 - 05:46]
ただし、これをさらに進める前に、まず、

[05:46 - 05:51]
選択した対象の Electron アプリケーションが、読み込まれる

[05:56 - 06:00]
JavaScript および Electron ファイルに対してセキュリティ整合性チェックまたは ASR セキュリティ整合性チェックを実行しないという点で、これに脆弱であることを確認する必要があります

[05:58 - 06:02]
。このための文書化されたプロセスがあり、

[06:00 - 06:04]
Bobby が、

[06:02 - 06:06]
脆弱な Electron アプリを検出するためのガイド、

[06:04 - 06:08]
または

[06:06 - 06:10]
このテクニックがどのようなアプリケーションに対しても機能することを確認するためのガイドを提供しています

[06:08 - 06:12]
。 ああ、ちょっと待って。

[06:10 - 06:13]
先に進む前に、

[06:13 - 06:18]
今日のビデオのスポンサーである Plex

[06:16 - 06:21]
Track について少しだけお話しさせてください。 ペンテストのレポート作成がいかに面倒な作業であるかはご存じでしょう

[06:18 - 06:23]
。 コピーと

[06:21 - 06:26]
貼り付け、複数のソースからのデータの整理

[06:23 - 06:29]
、結果のフォーマットに何時間もかかります。

[06:26 - 06:31]
疲れますよ。 そして最悪なのは、

[06:29 - 06:34]
レポートに費やす 1 分間は、ハッキングに費やさない 1 分間だということです

[06:31 - 06:37]
。 もっと良い方法があります

[06:34 - 06:39]
。  Plex Track をご紹介します。  Plex Track を使用すると、

[06:37 - 06:42]
攻撃対象領域を分析できます。

[06:39 - 06:45]
すべてのペンテストおよび脆弱性

[06:42 - 06:47]
スキャン データを 1 か所に集約します。 コンテキストベースのスコアリングを使用して

[06:45 - 06:49]
リスクの優先順位を決定します。 人工知能を活用して

[06:49 - 06:54]
レポート作成時間を大幅に短縮します。 品質保証レビューを

[06:52 - 06:56]
迅速化するために、Google ドキュメントのような共同作業機能を活用します

[06:54 - 06:58]
。 また、Jira などのチケット システムとのすぐに使用できる統合を使用して、

[07:01 - 07:06]
修復のために影響の大きい発見を送信します。 それで、

[07:03 - 07:08]
これはあなたにとって何を意味するのでしょうか? つまり、

[07:06 - 07:11]
ペンテストのレポート時間を

[07:08 - 07:13]
75% 削減できるのです。 チームや

[07:11 - 07:16]
関係者とシームレスに連携し、発見事項が

[07:13 - 07:18]
実際に迅速に対処され、

[07:16 - 07:22]
測定可能なリスク軽減を示すことができます。

[07:18 - 07:24]
CI のサイバー セキュリティ担当ディレクターの Charles Snder 氏は、

[07:22 - 07:27]
Plexra は当社の

[07:24 - 07:29]
継続的なセキュリティとリスク管理の基盤であると述べています。

[07:27 - 07:31]
Plexra は単なるツールではありません。 それは、

[07:29 - 07:34]
レポートに溺れること

[07:31 - 07:36]
と、実際にハッキングする時間があることの違いです。

[07:34 - 07:39]
詳細を確認し、

[07:36 - 07:41]
自分専用のデモを予約するには、以下のリンクを使用してください。 レポートに費やす時間を減らし

[07:39 - 07:43]
、ハッキングに時間をかけましょう。

[07:41 - 07:45]
このビデオをスポンサーしていただいた Plex Track に深く感謝いたします

[07:43 - 07:48]
。 それでは、これを見てみましょう

[07:45 - 07:50]
。  Electron アプリをダウンロードします。 この

[07:48 - 07:52]
例では、Teams を使用します。

[07:50 - 07:54]
これを Cursor に対して試してみましょう。

[07:52 - 07:56]
アプリのルート フォルダーを見つけます。

[07:54 - 07:58]
次のようになります。 現在、それらは

[07:56 - 08:01]
Microsoft チーム用のローカル Microsoft アプリ データに存在しています

[07:58 - 08:03]
。 ただし、カーソルの

[08:01 - 08:06]
インストールはアプリ データのローカル プログラム内で行われたことを思い出してください

[08:03 - 08:08]
。 それでは、ターゲットの被害者のマシンでこれを試してみましょう

[08:06 - 08:10]
。

[08:08 - 08:13]
もちろん、これをテストするために事前に行うことは、自分

[08:10 - 08:14]
のラボ内の攻撃者ベースのマシンで実行できます

[08:14 - 08:18]
。

[08:18 - 08:22]
ここでは、ターゲットおよび被害者のマシンでこれを実行しているのは、

[08:20 - 08:24]
ちょうど先ほどカーソルをインストールした場所だからです。 それでは、

[08:22 - 08:26]
Windows エクスプローラーとファイル エクスプローラーを開いてみましょう

[08:24 - 08:29]
。 ロケーションバーのアプリデータにアクセスしてみましょう

[08:26 - 08:31]
。

[08:29 - 08:33]
2 つのパーセント記号を環境

[08:31 - 08:35]
変数として使用しています。 実際、ローカル アプリ データを使用すると、

[08:33 - 08:37]
少し早く到達できます。 ここで、

[08:37 - 08:42]
以前見たようにプログラムを検索したいと思います。 そしてその中にカーソルが表示されます

[08:40 - 08:45]
。 ここで、Chrome パックやこのようなファイルなど、Microsoft Teams フォルダーで見たものの簡単な説明のように、非常によく提案された他のファイルのいくつかを見ることができます

[08:53 - 08:58]
。 これはガイドが示唆するすべてと一致しており、

[08:58 - 09:03]
ルート アプリ ディレクトリを追跡できたと表示されます

[09:00 - 09:05]
。 この場合、

[09:03 - 09:07]
電流はありますが、私たちの場合はカーソルだけです

[09:05 - 09:10]
。 デスクトップのどこかにコピーが作成され

[09:07 - 09:13]
、リソース フォルダーの内容が実際に削除されます

[09:10 - 09:14]
。

[09:13 - 09:16]
それは非常に重要になります。 それは

[09:14 - 09:18]
後で作業することになります。 しかし、彼らは

[09:16 - 09:21]
procmon または CIS 内部のプロセス モニターを使用して、

[09:21 - 09:25]
プログラムがロードされて起動しようとするときに実際に何が行われるかを確認しようとします

[09:23 - 09:29]
。

[09:25 - 09:31]
app.asr または packages.json にアクセスしますか?

[09:31 - 09:36]
ローカルディレクトリからそれらを見つけられなかったら、それで問題ありません。 つまり、

[09:34 - 09:39]
これを

[09:36 - 09:41]
Loki C2 テクニックまたはトリックで上書きしても問題なく機能します

[09:39 - 09:43]
。 そこで、

[09:41 - 09:46]
親ディレクトリに戻って

[09:43 - 09:48]
カーソル フォルダ全体をコピーし、

[09:46 - 09:50]
提案どおりにデスクトップにドロップすることにします

[09:48 - 09:52]
。 これを

[09:50 - 09:55]
Ctrl+Vで貼り付けます。 ああ、

[09:52 - 09:57]
カーソルは使用中のプログラムやファイルがあるため、実行されていないと役立ちます

[09:55 - 09:59]
。 では、もう一度試してみましょう

[09:57 - 10:01]
。 それを貼り付けてください。これで完了です。

[09:59 - 10:03]
コピーするのに永遠に時間がかかりました。 わかった。 ここで、

[10:01 - 10:06]
デスクトップ上の複製コピーの

[10:03 - 10:08]
resources フォルダにある

[10:06 - 10:10]
すべてのものを削除します。

[10:08 - 10:12]
キーボードのDeleteキーを押します。 そして、

[10:10 - 10:14]
CIS 内部と

[10:12 - 10:15]
procod を接続します。

[10:14 - 10:17]
この仮想マシンには proc mod と cis 内部が準備されています。

[10:15 - 10:19]
では、始めましょう。

[10:17 - 10:21]
キャプチャを停止するには、Ctrl + E を押します。  Crl X を押すと

[10:19 - 10:23]
すべてがクリアされます。 フィルターを追加するには、Ctrl + L を押します

[10:21 - 10:27]
。 そして、そのフォルダーで確認した

[10:23 - 10:29]
ように、プロセス名が cursor.exe であるかどうかを確認します

[10:27 - 10:32]
。 そして、

[10:29 - 10:34]
パスを調べて、

[10:32 - 10:37]
そこにリソースが含まれているかどうかを確認します

[10:34 - 10:39]
。 そして、それらを含めます。   「

[10:37 - 10:41]
適用」をクリックして、「OK」をクリックします。

[10:39 - 10:44]
そして、再びキャプチャを開始できます。

[10:41 - 10:47]
それでは、実際に

[10:44 - 10:49]
この場所からカーソルを開いてみます。 デスクトップに

[10:47 - 10:52]
あるこのフォルダをダブルクリックしてみましょう

[10:49 - 10:54]
。 しかし、ここで

[10:52 - 10:56]
CIS の内部と procmon の

[10:54 - 10:59]
応答を見てみましょう。

[10:56 - 11:02]
リソース アプリの package.json を検索してみます。

[11:02 - 11:09]
名前が見つからないが現在の場所に相対的なファイルと項目すべてを JSON で示します

[11:05 - 11:11]
。 したがって、これは

[11:11 - 11:17]
セキュリティ整合性チェックを行わず、

[11:13 - 11:18]
Loki C2 ファイルを挿入できるという点で脆弱です。 そうすれば、

[11:18 - 11:23]
cursor.exe とこの Electron アプリをバックドアすることができます。

[11:21 - 11:25]
他の電子アプリケーションでも同様に試してみる価値があります

[11:23 - 11:27]
。 そしてこれが

[11:25 - 11:29]
そのテクニックです。 はっきりさせておきます。

[11:27 - 11:31]
procmon キャプチャイベントがある場合、

[11:29 - 11:34]
electron アプリが最初に app.asr を検索しようとしていることがわかります

[11:31 - 11:36]
。 失敗した場合は、

[11:37 - 11:41]
packages.json で解凍されたアプリケーションを検索します。 そのようなことが起こる場合、

[11:39 - 11:43]
Electron アプリは

[11:41 - 11:46]
スクリプトジャックに対して脆弱である可能性が高くなります。 甘い。 続けることができます

[11:43 - 11:48]
。 まず、

[11:46 - 11:50]
Azure ストレージ BLOB アカウントを作成し、

[11:48 - 11:52]
SAS トークンを取得する必要があります。

[11:50 - 11:53]
ここにはドキュメントがリンクされているので、クリックして参照できます

[11:52 - 11:55]
。 実に、これは非常に

[11:53 - 11:58]
簡単です。

[11:55 - 11:59]
Azure アカウントでストレージ アカウントを起動するための手順に従うだけです

[11:58 - 12:01]
。 すぐにやらせてください

[11:59 - 12:03]
。  portal.asure.com にログインしているので

[12:01 - 12:05]
、

[12:03 - 12:07]
ここでストレージ アカウントをクリックします。  「

[12:05 - 12:09]
作成」をクリックします。 すでに持っているリソース グループを使用して、従量

[12:07 - 12:11]
課金制のサブスクリプションで設定を済ませておきます

[12:11 - 12:14]
。 ストレージ アカウント名は、

[12:12 - 12:16]
任意の名前にすることができます。

[12:14 - 12:18]
ここではランダムな数字をいくつか使用します。

[12:16 - 12:20]
リージョンとはパフォーマンスと

[12:18 - 12:22]
冗長性です。 説明では、

[12:20 - 12:24]
ローカル冗長ストレージ LRS を使用することが示唆されていると思います

[12:22 - 12:26]
。 そこで「OK」をクリックし、

[12:24 - 12:27]
確認して作成します。

[12:26 - 12:29]
これを確認して問題がなければ

[12:27 - 12:31]
、「作成」をクリックします。

[12:31 - 12:34]
これが起動するまで少し時間がかかります。 しかし

[12:32 - 12:36]
、これで

[12:34 - 12:38]
SAS トークンを作成できるようになるはずです。 これで、

[12:36 - 12:40]
展開が完了しました。 これで、

[12:38 - 12:43]
リソースに進むことができます。

[12:40 - 12:44]
ここで少しだけズームアウトします。セキュリティとネットワークの部分を

[12:43 - 12:46]
最終的に検索するか、少なくとも確認したいからです

[12:46 - 12:51]
。  Shared Access Signature タブが必要なのは、

[12:49 - 12:54]
これを使用して SAS トークンを作成できるためです

[12:51 - 12:56]
。 共有アクセス署名 (

[12:54 - 12:58]
SAS) は、Azure ストレージ リソースへの制限付きアクセス権を付与する URI です

[12:58 - 13:02]
。 これについて何か疑問がある場合は

[13:00 - 13:03]
、すべて

[13:02 - 13:04]
ドキュメントに記載されています。 これらには、使用できる

[13:03 - 13:06]
可能性のある権限

[13:04 - 13:08]
、サービス、タイプが含まれており、

[13:06 - 13:11]
これを使用して作成できます。

[13:08 - 13:13]
blob Q とテーブルを使用します。 したがって、ファイル

[13:11 - 13:15]
リソース タイプ、サービス コンテナー、および

[13:13 - 13:16]
オブジェクトは必要ありません。 許可された権限はそのままにしておくことができます

[13:15 - 13:18]
。 有効期限を設定したい場合は

[13:16 - 13:20]
、

[13:18 - 13:23]
今から約 8 か月後が提案されました。 では、

[13:20 - 13:25]
それを何に変えましょうか?  7月。 はい、

[13:23 - 13:28]
許可されるプロトコルは HTTPS のみです。

[13:25 - 13:30]
これで、SAS と

[13:28 - 13:33]
接続文字列を生成できます。 これで

[13:30 - 13:35]
作成されたので、これを Loki で使用できるようになりました。

[13:33 - 13:37]
ご参考までに、この SAS トークンはすでに生成されています

[13:35 - 13:39]
が、このトークンは

[13:37 - 13:42]
すぐにクライアントとエージェントの構成ファイルに追加されます

[13:39 - 13:44]
。 ただし、

[13:42 - 13:45]
ストレージ アカウントへのフル アクセスが提供されます。 したがって、

[13:44 - 13:47]
ペイロードが逆さまになっている場合、AS キーも持っているという条件で、

[13:45 - 13:49]
その SAS トークンを使用して C2 チャネルを読み取ることができますが、

[13:49 - 13:52]
これは

[13:51 - 13:54]
おそらく秘密にしておく必要があるものです。

[13:52 - 13:56]
Azure のセットアップが完了したら、

[13:54 - 13:58]
難読化された Loki ペイロードを作成する必要があります。

[13:56 - 14:00]
このリポジトリのクローンを作成し、ディレクトリを変更して

[13:58 - 14:02]
、Node をインストールし、

[14:00 - 14:05]
JavaScript 難読化ツールをインストールし、この

[14:02 - 14:06]
ツールを実行してエージェントを起動し、

[14:06 - 14:10]
先ほど受け取ったすべての Azure アカウント情報を入力します。

[14:08 - 14:12]
一番上までスクロールして、

[14:10 - 14:15]
このリポジトリのクローンを作成しましょう。

[14:12 - 14:17]
そのURLをコピーして貼り付けます。 次に、

[14:15 - 14:19]
Kali Linux 側で

[14:17 - 14:21]
ターミナルを開きます。 キーボードでCtrl+Alt+Tを押します

[14:19 - 14:23]
。  F11 で全画面表示になります。 そして、私は

[14:23 - 14:27]
他の多くの

[14:25 - 14:30]
課外ツールを保存したい op ディレクトリに移動します。 クローンのロキを入手しましょう

[14:27 - 14:31]
。 これをプルダウンすると、

[14:30 - 14:33]
Kali Linux なので、

[14:31 - 14:36]
Node と Node.js がすでにインストールされているはずです。

[14:33 - 14:38]
npm があるかどうかはよくわかりません。 ああ、そう思うよ。

[14:36 - 14:41]
素晴らしい。 それでは、ロキに移りましょう。 そして、

[14:43 - 14:47]
エージェントを難読化するために JavaScript 難読化ツールを使用することを提案しています。 それでは、すぐにインストールしてみましょう

[14:45 - 14:50]
。 はい、素晴らしいです。 ここで

[14:47 - 14:52]
必要なのは、難読化エージェント

[14:50 - 14:54]
スクリプト (現在のディレクトリ内の thejs JavaScript ファイル) を実行することだけです

[14:52 - 14:57]
。 ここで、先ほど設定した

[14:54 - 14:59]
Azure アカウント情報が求められます

[14:57 - 15:02]
。 ストレージ アカウントの最初のプロンプトは、

[15:02 - 15:06]
そのストレージ

[15:04 - 15:08]
アカウントの URL (blo.core.windows.net) です。 では、

[15:06 - 15:10]
それをコピーして貼り付けてみましょう。 入力したら Enter キーを押します

[15:08 - 15:12]
。 ここで、SAS トークンが要求されます

[15:10 - 15:14]
。

[15:12 - 15:16]
ここでは 2 番目のエントリである SAS トークンを要求しています。 そして、

[15:14 - 15:18]
右端をクリックして

[15:16 - 15:20]
クリップボードにコピーします。

[15:18 - 15:23]
その情報を貼り付けておきます。  Enterキーを押します。

[15:20 - 15:26]
そして、難読化された

[15:23 - 15:28]
ペイロードが /app ディレクトリに吐き出されます。

[15:26 - 15:30]
これまでは見えなかったかもしれませんが、現在では、

[15:35 - 15:40]
対象となる Electron アプリケーションを置き換えたり上書きしたりする必要があるすべてのファイルが実際に含まれているアプリ フォルダーがあります。 この

[15:38 - 15:42]
場合はカーソルです。 ここで 3

[15:40 - 15:44]
台目の仮想マシンを使用している理由は

[15:42 - 15:46]
、別の Windows マシンがあることはわかっています

[15:44 - 15:48]
が、今回はダーク モードの背景を持つ攻撃者のマシンです。これは、

[15:48 - 15:52]
少なくともこれ

[15:50 - 15:55]
までのところ、Loki クライアントには Windows 用のリリース ビルドしかないと思われるためです

[15:52 - 15:56]
。 リポジトリに戻ると

[15:55 - 15:58]
、

[15:56 - 16:00]
明らかにこれを Linux

[15:58 - 16:02]
用にコンパイルして操作できると思います。 ただし、

[16:02 - 16:04]
開発作業を行っていない限り、これはあまりお勧めできません。 だから、

[16:04 - 16:07]
邪魔になるものがあるかどうかは分かりません。 ボビーがそれを制作中だと思います

[16:06 - 16:10]
。 ブランチを見たと思ったのですが

[16:07 - 16:11]
、Windows 用の Loki guy クライアントには

[16:11 - 16:15]
ダウンロード可能なリリースがあります。 便宜上、

[16:13 - 16:18]
これをここに貼り付けて抽出

[16:15 - 16:20]
し、

[16:18 - 16:23]
Windows 攻撃者のホス​​トと、私が知っている

[16:20 - 16:25]
Cali の攻撃ホストで操作します。 しかし、これで

[16:23 - 16:28]
ダブルクリックして

[16:25 - 16:31]
Loki C2 クライアントを開くことができるはずです。 見た目もかなり

[16:28 - 16:34]
豪華ですね。 かなりかっこよさそうですね。  Loki

[16:31 - 16:36]
ダッシュボード。 ああ。 さて、

[16:34 - 16:39]
ここで実際に重要なことを行う必要があります。Loki

[16:36 - 16:41]
C2 クライアントを、

[16:39 - 16:42]
Azure ストレージ アカウントと

[16:41 - 16:45]
SAS トークン、および

[16:42 - 16:48]
難読化エージェント スクリプトによって提供されたメタ コンテナーで動作するように構成する必要があるためです。 そこで、

[16:48 - 16:52]
この出力を確認するために、Kali Linux に戻ることにしました。

[16:52 - 16:57]
取得した値をすべてコピーして貼り付けます。

[16:55 - 16:59]
私たちが知っているストレージ アカウント BLOB と、

[16:57 - 17:02]
Azure から知っている SAS トークンがあります。 これらを貼り付けます

[16:59 - 17:04]
。ただし、メタ コンテナーは、

[17:02 - 17:06]
obuskate agent.js

[17:04 - 17:08]
スクリプトによって提供された新しい情報です。 したがって、

[17:06 - 17:10]
この値もコピーして貼り付ける必要があります。 そこに入力してください

[17:08 - 17:12]
。 保存しましょう。 これで

[17:10 - 17:14]
構成が更新されます。 わかった。

[17:12 - 17:17]
この時点で、

[17:14 - 17:19]
LokiC2 を使用してコールバックする準備がほぼ整いました。 しかし、

[17:19 - 17:24]
これらすべてのファイル、つまり Loki コードを

[17:22 - 17:26]
ターゲットに配置する必要があることは言うまでもありません。 これを明確にしておきたいと思います

[17:24 - 17:28]
。 これはコマンドと制御のためです。

[17:26 - 17:30]
初期アクセス権が必要です。 あなたは

[17:28 - 17:32]
すでにこの

[17:30 - 17:34]
被害者、このターゲットを侵害しており、

[17:32 - 17:36]
このコードを挿入して

[17:34 - 17:38]
感染させる能力を持っているでしょう。 そして今、あなたはこの裏口を手に入れました

[17:36 - 17:41]
。 それでは、

[17:38 - 17:44]
アプリ フォルダーの内容すべてを

[17:44 - 17:48]
被害者とターゲットのその場所にコピーしてみましょう。 これらの変更は

[17:46 - 17:51]
実際のアプリにも適用されるべきですよね？   テスト用

[17:51 - 17:57]
にデスクトップに置いた小さな複製コピーではありません。 しかし、

[17:54 - 18:00]
そのリソース フォルダー内のアプリ データ ローカル プログラム カーソル上で

[17:57 - 18:01]
、すべてを削除することを提案しました

[18:00 - 18:03]
。 これをもう少し

[18:01 - 18:04]
試してみたいので、実際にやることは、

[18:04 - 18:08]
名前を変更することだけです。 これを

[18:07 - 18:11]
original-app と呼びます。 そうすれば、Electron が通常使用する

[18:08 - 18:12]
ハードコードされたパスは使用されなくなります

[18:11 - 18:15]
。 ただし、

[18:15 - 18:21]
Loki の難読化されたエージェントの出力から取得したアプリ フォルダーを貼り付けましょう。 これで、

[18:19 - 18:24]
Loki C2 が

[18:21 - 18:26]
私たちのために用意していたものがすべて揃いました。 そして、この

[18:24 - 18:29]
Windows 11 マシン上のライト モードのカーソル。

[18:26 - 18:31]
犠牲者とターゲットはカーソルでバックアップされます

[18:29 - 18:32]
。 それで、これらを並べて

[18:31 - 18:34]
、折り返し電話がかかってくるかどうか見てみましょう。

[18:32 - 18:37]
左側には、

[18:34 - 18:39]
攻撃者のマシンの Loki ダッシュボードがあります。

[18:37 - 18:41]
右側に被害者がいます。

[18:39 - 18:44]
ここでスタートボタンを押して、

[18:41 - 18:46]
通常どおりカーソル アプリを開きます

[18:44 - 18:49]
。 カーソルをダブルクリックして、

[18:46 - 18:51]
しばらく待ちます。 幸運にも、

[18:49 - 18:53]
エージェントが左側で通信できるようになるでしょう

[18:51 - 18:55]
。 幸運を

[18:53 - 18:57]
祈ります。 はい、そこにあります。 素晴らしい。

[18:55 - 19:00]
素晴らしい。 素晴らしい。 さて、

[18:57 - 19:01]
カーソルが右側にポップアップしていないことに気づいたかもしれません

[19:00 - 19:03]
。

[19:01 - 19:05]
それについては後ほどお話ししますが、

[19:05 - 19:09]
Loki のすばらしい機能をすべてお見せしたいと思います。 エージェントが作成されたので、

[19:08 - 19:11]
エージェント ID、コンテナ、ホスト名が表示されます

[19:09 - 19:13]
。

[19:11 - 19:15]
これをダブルクリックしてエージェント ターミナルを開きます。 これにより、

[19:13 - 19:18]
ユーザー名、

[19:15 - 19:20]
実行中のプロセス、プロセス ID、IP アドレス、

[19:18 - 19:22]
アーキテクチャ、オペレーティング システムなどがわかります

[19:20 - 19:24]
。  「help」と入力すると、非常に

[19:22 - 19:25]
簡単に全画面表示されます。

[19:24 - 19:27]
ごめん。 明らかに、ヘルプ コマンドが表示されます

[19:25 - 19:30]
。 作業ディレクトリ、リスト

[19:27 - 19:33]
ファイル、およびその内容を印刷します。

[19:30 - 19:35]
ここで実際にターゲットになっているかどうかを確認してみましょう。 これにより、

[19:35 - 19:39]
現在のディレクトリ内のすべてのファイルが取得されます。 そしてもちろん、pwd は

[19:38 - 19:42]
私たちがどのディレクトリにいるのかを教えてくれます

[19:39 - 19:44]
。そしてそれはまさに私たちが期待した通りです。

[19:42 - 19:46]
ただし、

[19:46 - 19:51]
しばらくスリープする、ドライブを一覧表示する、プロセスを生成する、

[19:48 - 19:52]
ファイルを移動またはコピーする、シェル コードを実行する、

[19:51 - 19:54]
アセンブリをネットする、アップロード、ダウンロードするなど、その他の操作もすべて実行できることを覚えておい

[19:52 - 19:57]
てください。 それはコマンドとコントロールです。 そして、

[19:54 - 19:59]
これらすべては cursor.exe から実行されています

[19:57 - 20:02]
。 でも、あなたが何を

[19:59 - 20:05]
考えているかは分かります。 ちょっとまって。 カーソルを表示したかったのです

[20:02 - 20:07]
。 つまり、被害者、ユーザー、

[20:05 - 20:09]
ターゲットは、

[20:07 - 20:12]
自分のアプリが

[20:09 - 20:14]
侵害されたという事実にまったく気づかないのです。 私もあなたと同じ気持ちです。

[20:12 - 20:15]
タスクマネージャーを開きます。

[20:15 - 20:20]
ここで詳細を見ると、明らかにカーソルが

[20:18 - 20:24]
実行されていることがわかりますが、プロセスは、

[20:24 - 20:31]
通常のカーソルや Discord、

[20:27 - 20:32]
Slack、Teams などではなく、Loki の処理のみを実行するように簡素化されています。 それが欲しいです。

[20:31 - 20:34]
それでは、少し背景をお話ししましょう。

[20:32 - 20:35]
ボビーと私は仲の良い友達です。 私たちはもう

[20:34 - 20:38]
何年もチャットを続けており、

[20:35 - 20:40]
私は連絡を取りました。 彼は

[20:40 - 20:44]
これを最終的にリリースする少し前に、Loki C2 の作業について私に話していましたが、

[20:42 - 20:46]
今それが動作しているのを見るのは非常にクールです。

[20:44 - 20:47]
彼は2月に私にその機器へのアクセス権を与えてくれたの

[20:46 - 20:49]
ですが、4月になるまで実際にそれを操作するチャンスがありませんでした

[20:49 - 20:52]
。 そして私は彼にこうメッセージを送りました。「やあ、

[20:51 - 20:54]
やっと Loki をいじってみて

[20:52 - 20:56]
、すごく興奮してきた。カーソル付きで動くのも見たし、

[20:54 - 20:59]
すごくクールなデモになりそうだ。でも、

[20:59 - 21:04]
普通のアプリは動かないようになっているのかな？ もし動いたら

[21:02 - 21:06]
クールだと思うよ。」 そして彼はこう言いました。「そうです。Lokiコードは

[21:04 - 21:07]
アプリを空洞化し、Sign

[21:06 - 21:10]
Node.jsインタープリター（おそらく

[21:07 - 21:12]
この場合はcursor.exe）を使ってC2コードを実行します

[21:10 - 21:13]
。もちろん、

[21:12 - 21:15]
元のアプリをそのまま実行することも可能ですが、元のアプリの

[21:15 - 21:19]
コードを書き換えてLokiコードと融合させるには、かなりの作業が必要になります

[21:17 - 21:21]
。」 そして、私たちは、

[21:19 - 21:24]
ちょっと工夫してみようかと考え始めました

[21:21 - 21:26]
。 考えてみようと思うのですが、まだ

[21:24 - 21:28]
できますか？ リソース フォルダーから使用しているファイルでまだ理解できますか

[21:28 - 21:32]
? アプリを削除しなかったことは承知しています

[21:30 - 21:34]
。

[21:32 - 21:37]
それを複製するために、元のアプリのコピーを作成しました。

[21:34 - 21:40]
彼は、うーん、

[21:37 - 21:42]
実際のカーソル アプリはそのままにして、

[21:40 - 21:45]
カーソル リソースの新しいフォルダー内に別のフォルダーを作成するのがよいかもしれないと言います

[21:42 - 21:48]
。 そのカーソル

[21:45 - 21:51]
フォルダー全体をそのフォルダーにコピーし、

[21:48 - 21:53]
実際の main.js または

[21:51 - 21:55]
package.json ファイルが実際に呼び出すものを変更します。

[21:53 - 21:57]
結局のところ、これがすべてです

[21:55 - 22:00]
よね? これが実行するキックスタートのメイン スクリプトとは何ですか。

[22:00 - 22:04]
週末にこれを試してみます。本当に

[22:01 - 22:06]
クールです。 彼のアイデアは理にかなっていると思いますが、

[22:04 - 22:09]
それによって

[22:06 - 22:10]
アプリのサイズが 2 倍になるということも認識しています。 それで

[22:09 - 22:12]
私たち二人ともそれをいじり始めました。 ここで

[22:10 - 22:13]
少し話が逸れてしまいます

[22:12 - 22:15]
が、私の言いたいことを説明させてください

[22:13 - 22:18]
。 なぜなら、ここでターゲットと被害者

[22:15 - 22:20]
に対して以前行ったのと同じように、ローカル アプリ データを開くと、

[22:20 - 22:26]
プログラム フォルダー内、カーソル内、リソースと

[22:23 - 22:30]
アプリのディレクトリ内が調べられ、

[22:26 - 22:32]
独自の package.json と

[22:30 - 22:34]
これらすべてのファイルが提供されるからです。

[22:32 - 22:36]
ここで元のアプリを見てみると、実際には

[22:34 - 22:39]
他のファイルがすべて含まれているわけではありません。

[22:36 - 22:41]
ここには、確認できる package.json JSON があります

[22:39 - 22:42]
。 これを開けさせてください。   カーソルを使用すると

[22:42 - 22:45]
コールバックが作成されるため、カーソルを使用してこれを行うつもりはありません。

[22:44 - 22:49]
Sublime Textはありますか? いいえ、

[22:45 - 22:51]
メモ帳を使います。 ラメ。 しかし、ここでの主な呼び出しは

[22:52 - 22:55]
totout/main.js です。 つまり、このディレクトリには

[22:55 - 23:00]
すべての情報が

[22:58 - 23:04]
含まれているため、作業が実際に簡単になるのです。 ここで、

[23:04 - 23:10]
Lok C2 アプリの実際のカーソル main.js が起動されます。

[23:07 - 23:14]
カーソルではなくメモ帳で開いて操作する package.json JSON

[23:10 - 23:18]
。 これにより、main.js が呼び出されます。

[23:14 - 23:20]
これで main.js が難読化されました。

[23:18 - 23:23]
難読化された agent.js ファイルを実行したため、ジャンクのように見えます

[23:20 - 23:24]
。 そうする必要はないですよね？

[23:23 - 23:27]
ここで純粋なコードを使って

[23:24 - 23:30]
これを操作したい場合。 しかし、

[23:30 - 23:34]
これら 2 つのファイルと

[23:32 - 23:38]
これら 2 つのフォルダーの違いをトリガーしたり、切り替えたり、操作したりして、基本的に

[23:34 - 23:40]
カーソルを guey 内の純粋な元のカーソル ウィンドウとして定期的に実行し続け、

[23:40 - 23:45]
Loki コールバックを取得することはできますか。 それで、これを少しいじって、

[23:45 - 23:50]
Kali Linux に戻ってこれをお見せできるようになりました

[23:46 - 23:53]
。 ええ、ご覧のとおり、アプリの main.js JS は

[23:50 - 23:55]
難読化されたものになっています。 しかし、

[23:53 - 23:58]
元の

[23:55 - 24:01]
エージェント main.js に戻ってみると、

[23:58 - 24:04]
これが

[24:01 - 24:06]
Loki が起動するときの実際の開始点である元のスタートアップ キックスタートであることがわかります。

[24:04 - 24:10]
これは、

[24:06 - 24:12]
カーソルの通常の呼び出しと並行して維持したいものです。 それで

[24:10 - 24:15]
私もこれで遊んでみましたが、ボビーもそうしました

[24:12 - 24:17]
。 それで、何かが機能していることがわかりましたが、

[24:15 - 24:19]
それは良くありません。 これらすべてを示し、

[24:17 - 24:22]
構文を JavaScript に設定します

[24:19 - 24:24]
。 ほら、私は環境やプロセスの環境変数などで、馬鹿げた奇妙なことを何でもやって、

[24:25 - 24:31]
これが実際に

[24:28 - 24:33]
キックスタートしている Loki なのか、本当の

[24:31 - 24:36]
cursor.exe が何なのかを判断できるようにしています。そして、それは別の

[24:33 - 24:37]
プロセスの cursor.exe である必要があります。なぜなら、それは

[24:36 - 24:40]
Electron であり、Electron がすでに

[24:37 - 24:42]
Loki のことを実行している場合、同じランタイムでカーソルのことを行うことはできません。

[24:40 - 24:44]
すべてが

[24:42 - 24:47]
最終的にどのように動作するかということです。 そこで、

[24:44 - 24:50]
カーソルの独自のコピーを生成して、

[24:47 - 24:52]
通常の起動を実行するかどうかを確認します。 ええと、私は実際の cursor.exe を含む

[24:50 - 24:55]
カーソルのオリジナル ディレクトリ内でこれを実行します

[24:55 - 25:00]
が、

[24:58 - 25:02]
これは通常のショートカットで通常クリックするものではなく、2 番目のバージョンです

[25:00 - 25:04]
。 お見せします

[25:02 - 25:06]
が、この設定は非常に不安定です。

[25:04 - 25:08]
アプリに戻ってみると、

[25:06 - 25:11]
元のアプリがまだバックアップされていました。 では、

[25:08 - 25:14]
修正した Loki を削除しましょう。

[25:11 - 25:16]
元の場所に戻します。 これは恐ろしいことのように聞こえるかもしれません

[25:14 - 25:18]
が、実際には

[25:16 - 25:20]
カーソル ディレクトリからすべてを

[25:18 - 25:22]
独自にコピーしたいのです。 それで、

[25:20 - 25:24]
これをコピーします。

[25:22 - 25:27]
cursor.exe はまだ実行されていますか? 私はします。 うん。 わかった。

[25:24 - 25:30]
えっと、それをすぐに殺しましょう。 タスクを

[25:27 - 25:33]
強制終了して、イメージ名 cursor.exe を強制実行します

[25:30 - 25:35]
。 死んでください。 わかった。 そこで、

[25:33 - 25:36]
カーソルのコピーを作成し、

[25:35 - 25:39]
デスクトップに戻します

[25:36 - 25:42]
。 それをデスクトップに置いたのは、それ

[25:39 - 25:44]
自体をコピーしたり、

[25:42 - 25:45]
奇妙な再帰ツリー

[25:44 - 25:48]
ブランチ ファイル システム ロジックのようなものを実行したりしないようにするためです。 ご覧のとおり、

[25:45 - 25:51]
これを cursor- に名前変更します

[25:48 - 25:54]
。 そして、

[25:51 - 25:57]
ローカル アプリ データ プログラムに戻り、

[25:54 - 26:01]
実際のアプリでカーソル リソースをプログラムします。 実際には、

[25:57 - 26:03]
カーソル アプリの完全なコピーを

[26:01 - 26:07]
このフォルダー内に配置したいと考えています。 つまり、通常私たちが実行する cursor.exe

[26:03 - 26:11]
の中に、重複した cursor.exe exe が存在します

[26:07 - 26:13]
。

[26:11 - 26:14]
それは奇妙だとわかっていますし、

[26:13 - 26:17]
このアプリケーションのサイズが文字通り 2 倍になっていることもわかっています

[26:14 - 26:20]
が、

[26:17 - 26:23]
ここで Loki エージェントのものをすべてコピーし、

[26:20 - 26:25]
main.js を変更して

[26:23 - 26:28]
2 つ目のものを生成すると、機能します。

[26:25 - 26:31]
アプリケーションのサイズが 2 倍になる

[26:28 - 26:33]
ので見栄えは良くありませんが、機能します。 これは

[26:31 - 26:36]
ボビーと私が最初に考えたアイデアです

[26:33 - 26:39]
。 次に、実際のカーソルのアプリで、

[26:36 - 26:41]
Loki が使用するすべてのものを貼り付けます。

[26:41 - 26:46]
ここで実際に変更されるのは package.json だけですよね?

[26:45 - 26:50]
結局、私たちが叩き壊してしまうのは、これだけです。

[26:46 - 26:52]
しかし、もし今 main.js を変更するなら、難読化されたものではなく、先ほど

[26:50 - 26:53]
共有したものを使用しましょう

[26:53 - 26:58]
。 見た目は

[26:56 - 26:59]
良くありませんが、

[26:58 - 27:02]
概念実証としては優れているので、このコードをすべて取得します。

[26:59 - 27:06]
これを貼り付けると、

[27:02 - 27:08]
Loki エージェントとカーソルの両方が実行されることが確認できるはずです。

[27:06 - 27:10]
それでは、これらをもう一度並べて、

[27:08 - 27:12]
機能するかどうかを確認してみましょう。 はい、同じ設定です。

[27:10 - 27:14]
古いエージェントは死んで古くなっているので削除します

[27:12 - 27:16]
。 しかし今は、

[27:14 - 27:19]
Loki C2 の攻撃者が左側、被害者が

[27:16 - 27:21]
右側です。

[27:19 - 27:24]
開発者として、ユーザーとして当然のようにカーソルを開くと、

[27:21 - 27:26]
カーソルがポップアップ表示され、

[27:24 - 27:28]
実際に使用して操作することができ、

[27:26 - 27:31]
まったく問題ないと思うようになります。

[27:28 - 27:33]
さて、折り返しの電話がかかってきましたが、

[27:31 - 27:36]
バックドアが仕掛けられていました。 もう一度言いますが、私は

[27:33 - 27:39]
あなたのマシンを完全に制御し、アクセスすることができます。  PWD、

[27:36 - 27:41]
ls、ファイルのコピーなど、やりたいことは何でもできます。

[27:39 - 27:42]
問題なく動作しています。 私はただ、

[27:41 - 27:44]
物事は起こっていて、

[27:42 - 27:47]
それは大丈夫だということを示したいだけです。 わかった。 しかし、被害者

[27:44 - 27:49]
側のユーザーはまったく気づきません。

[27:47 - 27:51]
彼らはバイブコーディングに戻ることができます。

[27:49 - 27:52]
Microsoft Teams でメッセージを送信できます。

[27:51 - 27:54]
Discord、ボイスチャットなどで連絡を取ることができます

[27:52 - 27:57]
。 ただし、免責事項を追加させてください

[27:54 - 28:00]
。 このアプローチにより、

[27:57 - 28:01]
アプリのサイズが 2 倍になりました。 ええと、ボビー

[28:00 - 28:03]
と私は週末にこのことについて取り組んでいました

[28:01 - 28:04]
が、彼は実際に package.json が実際に呼び出すものをホットスワップするだけの、より

[28:03 - 28:07]
優れた、よりスマートなアプローチでこれを動作させました

[28:07 - 28:12]
。 彼は、

[28:12 - 28:18]
init.js でミドルウェアや中間的なものを少しだけ使用しています。 次に、

[28:15 - 28:21]
実際に packages.json を変更して、

[28:18 - 28:23]
Loki とカーソルを前後に切り替えながら生成します

[28:21 - 28:25]
。

[28:23 - 28:27]
当初は、一度だけセットアップするだけで動作しました

[28:25 - 28:30]
が、その後は永続的に動作するようになりました

[28:27 - 28:31]
。

[28:30 - 28:32]
彼が料理をしている本当にクールなビデオがあり、

[28:31 - 28:34]
私は自分の料理がうまくいったことを彼に知らせました

[28:32 - 28:36]
。 ここで彼のビデオを紹介します。

[28:34 - 28:38]
実際のカーソル

[28:36 - 28:41]
リソースとアプリ フォルダー内で、

[28:38 - 28:44]
package.json 内の

[28:41 - 28:46]
dot/outmain.js と init.js を削除していることがわかります。 ここで、彼は

[28:44 - 28:49]
これを含め、カーソルをダブルクリックして、カーソルが

[28:46 - 28:51]
生成されてコールバックされるようにします

[28:49 - 28:53]
。 まだカーソルを実行して、

[28:51 - 28:54]
いくつかの古いエージェントをクリーンアップしますが、その後、

[28:54 - 29:00]
実際に呼び出される他のエージェントをいじって、

[28:57 - 29:02]
まだ損害を与えていることがわかります。 もともとその

[29:00 - 29:03]
手法は 1 回限りの試みでしたが、

[29:02 - 29:05]
その後、

[29:03 - 29:07]
これは本当にすごいから RDM を披露してもいいかと尋ねたところ、彼は「

[29:05 - 29:10]
うん、今では両方のアイデアが機能する。

[29:07 - 29:12]
複製アプリケーションを並行して実行する

[29:10 - 29:14]
か、

[29:12 - 29:16]
packages.json ファイルをホットスワップするかだ」と興奮しました。 さて、私はこう

[29:14 - 29:19]
尋ねています、ねえ、これを展示してもいいですか? これは

[29:16 - 29:20]
本当にすばらしいです。

[29:19 - 29:22]
もう少し作業すれば、これを

[29:20 - 29:24]
永続化できるので、

[29:22 - 29:26]
package.json をホットスワップするたびに、

[29:24 - 29:28]
他の変更を加える必要がなくなります。 そしてボブは

[29:26 - 29:30]
これに興奮しています。 それは動作します。

[29:28 - 29:32]
分かりました。 きれいだよ。 しつこいです。

[29:30 - 29:34]
おい、これはすごい能力だよ。

[29:32 - 29:36]
次回の約束のときにこれを使うと思います

[29:34 - 29:39]
。 そして私は、ああそうだ、と思いました。 今では、

[29:36 - 29:40]
あらゆる Electron アプリが完全にバックドア攻撃される可能性があります

[29:40 - 29:44]
。 さて、私は、package.json トリック

[29:44 - 29:50]
間のこの種のホットスワップやフリップフロップについて、あまりうまく説明できなかったように感じます

[29:47 - 29:51]
。 うーん、でも、私

[29:50 - 29:54]
たちがそのことに取り組めたことを嬉しく思いますし、

[29:57 - 30:01]
週末にこの件について熱心に話し合った間、ボビーが私を「えーっと、ちょっとだけ称賛とクレジットを添えて、ここに追加してくれたこと」に感謝しています。 そのことについてお話しさせてください

[29:59 - 30:03]
。 彼は

[30:01 - 30:05]
ここにこの新しいセクションを追加し、Electron アプリにバックドアを設置して

[30:03 - 30:07]
、実際のアプリケーションを

[30:05 - 30:08]
通常どおり動作させ続けました。

[30:07 - 30:10]
これを行う最も簡単な方法は、

[30:08 - 30:13]
最初にこれを公開し、ファイルに挿入して

[30:10 - 30:15]
、Electron アプリの元の機能をすべて空洞化または破壊することです

[30:15 - 30:19]
。 ロキはただそれを食べるだけです。 しかし、

[30:17 - 30:21]
私が彼と冗談を言い合ったとき、私たちは、

[30:23 - 30:27]
彼が作成した init.js にプロキシ アプリを少し追加できると考えていました。

[30:26 - 30:29]
これは私が計画していたデモ用のものです

[30:27 - 30:32]
。 彼は、

[30:29 - 30:35]
カーソルをダウンロードして、package.json

[30:32 - 30:37]
ファイルをここに貼り付け、init.js js ファイルを使用すると

[30:35 - 30:39]
、これらの変更が自動的に完了すると言います

[30:37 - 30:42]
。 まあ、

[30:39 - 30:44]
まだ自動ではないと思いますが、

[30:42 - 30:46]
この仕組みのセクションでは、

[30:46 - 30:50]
メイン スクリプトの内容と、最終的に

[30:48 - 30:52]
実行される内容、そしてそれを

[30:50 - 30:54]
packages.json ファイルから元の場所に戻す処理の間でどのようにやり取りするかについて説明しています

[30:52 - 30:56]
。 しかし、その方法では、アプリは

[30:54 - 30:59]
永続的にバックドアを仕掛けられ、通常通り動作します

[30:56 - 31:01]
。 カーソル アプリが終了した場合、Loki はバック

[30:59 - 31:02]
グラウンドで実行を継続します。

[31:01 - 31:04]
インプラントはまだ残っています。 あなたはまだ

[31:02 - 31:06]
指揮と制御権を持っています。 そして、すぐに

[31:04 - 31:08]
それは自動化されるでしょう。 それは

[31:06 - 31:10]
かなりいいですね。

[31:08 - 31:11]
奇妙な形で貢献することができてうれしかったです。 えっと、リポジトリ

[31:10 - 31:14]
に私を追加してくれたボビーに感謝します

[31:11 - 31:15]
。 これをエンゲージメントに使用する場合、opsec の推奨事項に関する非常に優れた情報がここにあります

[31:15 - 31:19]
。 ええと、ソース

[31:17 - 31:20]
からコンパイルする場合についてもう少し詳しく説明します

[31:19 - 31:22]
。 ただし、

[31:20 - 31:24]
単に使用するだけの場合はあまりお勧めできません。

[31:22 - 31:25]
検出に関するその他の情報もあります。

[31:24 - 31:27]
あなたがブルーチーム、防御者の一人であれば、

[31:27 - 31:30]
組織の保護とセキュリティ確保に努めて​​いる皆さんです。

[31:30 - 31:34]
ここにはたくさんのマイター攻撃テクニックが詰め込まれていて、本当にすごいです。 ええと、

[31:32 - 31:36]
Electron アプリが

[31:34 - 31:40]
実行されたり、Azure

[31:36 - 31:42]
ストレージ BLOB にビーコンが送信される例などもあります。本当に、本当に

[31:40 - 31:44]
素晴らしいものです。 正直に言うと、これは本当に巧妙だと思いました

[31:42 - 31:45]
。

[31:44 - 31:47]
皆さんはどう思われるか分かりませんが、私は今、

[31:45 - 31:49]
これを Discord で動作させることができるだろうかと考えています。

[31:47 - 31:51]
Slack で動作しますか?

[31:49 - 31:54]
Obsidian や Notion、あるいは

[31:51 - 31:56]
その他多くの Electron アプリでも動作しますか? すごくクール

[31:54 - 31:59]
。 そして、それが

[31:56 - 32:01]
永続的なバックドアのように設定されている場合、

[31:59 - 32:03]
アプリのサイズが 2 倍になったり、アプリケーション全体のコピーが作成さ

[32:01 - 32:04]
れたりするのではなく、そのようなホット

[32:03 - 32:07]
スワップの理解、つまり、package.json 内のどこにあるか、

[32:07 - 32:12]
実行されるメイン スクリプトがどこにあるか、または init.json プロキシがどこにあるかがわかります。

[32:09 - 32:14]
それは本当に素晴らしいですね。 ホットな AI ブームの

[32:12 - 32:17]
OQT 花火デモとしてカーソルを使用してこれを行ったことは知っていますが、

[32:17 - 32:21]
これがどのように使用できるか考えてみてください。 そうは

[32:19 - 32:23]
言っても、称賛、敬意、そして当然認められるべきものはすべて

[32:21 - 32:24]
認めるべきです。 この素晴らしい Loki C2 を組み立ててくれた Bobby Cook に大いに感謝します

[32:24 - 32:28]
。 週末に私をちょっといじら

[32:26 - 32:29]
せてくれて、ちょっといじらせてくれて、さらに

[32:29 - 32:32]
少しだけジャムさせてくれて本当にありがとう。

[32:30 - 32:33]
そして、ご覧いただき本当にありがとうございました。 何かを学べたことを願っています

[32:32 - 32:35]
。

[32:33 - 32:37]
この作品を楽しんでいただけたら幸いです。 これが

[32:35 - 32:38]
クールで派手なデモであったことを願っています。 そして、コメントやチャンネル登録など、

[32:37 - 32:40]
YouTube のアルゴリズムに関することをすべて実行し、

[32:40 - 32:42]
スポンサーへの感謝の気持ちを表明してください。

[32:41 - 32:44]
動画の説明にリンクがあります。

[32:42 - 32:46]
よろしければチェックしてみてください。 それではまた

[32:44 - 32:46]
次回

## コメント

### 1. @mntruell (👍 477)
Hey! One of the devs here. Thanks for this report.

To be clear, if you download Cursor from official sources (e.g. our website, in-app updates), you are completely protected from this attack. Successful exploitation would require tricking a user into downloading an unofficial version of Cursor.

We'll be rolling out an update soon to render this attack impossible even if you download an unofficial build. For more details about our security posture, see our security page and don't hesitate to reach out to the email listed.

> **@aname3576** (👍 20): lol, lmao

> **@TheGuillotineKing** (👍 51): @@aname3576at least he acknowledged it and has a plan for action😂😂😂

> **@ilonachan** (👍 10): I'm curious, how does the official (and soon also the unofficial) build prevent this attack? If someone already has the one-time access to replace a single line in your package.json, what can you do to stop them? Do you just detect if there are ANY unwanted files in the resources, delete them and bail out, or something?

> **@a9503128** (👍 60): Curious, are you vibe coding the fix or are you going use actual developers?

> **@ishrathinaam6723** (👍 29): Seemed like John did download the app from the official website for this demo 😂How do you say that its protected from the official website download then?

### 2. @terraflops (👍 361)
anyone else notice a ring on John's hand? congrats 🎉 John !

> **@johnaloe** (👍 10): lol 😂😂😂😂😂😂😂😂

> **@mainetechy** (👍 103): Oh that’s just his “married to tech” ring, the other one is on his desktop PC :3

> **@Dr.RasheleVShoun** (👍 7): Dude I want a married to tech ring! That is hilarious!!!

> **@armaganaydin8315** (👍 3): You are hacked man, congrats

> **@hichemsavastano4430** (👍 2): Social engineering 😅 skill

### 3. @ZomgLolPants (👍 122)
ai generated code is wild one of my friends in the industry told me they had someone try to commit something that, instead of solving the problem, would call out to an ai and have it keep trying things until it got a result that didn't trip the error handler we are so cooked man

> **@ALilNigerianPrince** (👍 14): you saw that on shorts..

> **@David-qb7fz** (👍 0): Ur so cooked u can't even write a yotube comment because you didn't learn how to use periods or commas

> **@bing_crilling8981** (👍 0): thats fucking insane dawg what

> **@123456crapface** (👍 3): yeah calling bullshit on that bro

> **@jejeirs** (👍 1): yeah no way that code would get committed in the industry

### 4. @LAP-bd7oi (👍 2)
I absolutely love how developers are creating tools... To replace or diminish their value... Absolutely lovely. Its lika having a weapons dealer pushing for the ban of fire arms

### 5. @muumia4 (👍 11)
Have you considered adding some kind of onscreen keystroke displayer? Would be nice to see some of the true poweruser workflows and you wouldn't have to say the keys out loud

### 6. @Kamerzystanasyt (👍 33)
cursor ai literally made a whole payload in batch for deleting all regedits and system files

> **@SuperNyz** (👍 4): if you have access to the victims machine you can jsut run a bash script at that point. So its really kinda useless. 

Cursor also doesnt run as Admin, it runs as the user.

> **@DefaultYoutubeHandle** (👍 0): Uh so lol that’s not complicated at all

> **@Kamerzystanasyt** (👍 0): @@DefaultYoutubeHandle but it should be filtered to not generate it.

> **@mirothedjmusic** (👍 0): @@SuperNyz Claude to over shell the entire time , they replace every windows folder and every cursor folder every fake folder I had 70000 file of fake code if you deleted it would just come right back luckily I Project LASSO that thottle anything over 2% if I step away so witt protections I still lost alot of time over this but also got me seeing ways to implement some decensws and a code

### 7. @cephurs (👍 2)
Nice work, John, Bobby, and Dev Team!

### 8. @BlizzetaNet (👍 103)
"Vibe Coding"..... one of the most horrible things on God's Green Earth

> **@kamelowy** (👍 0): I actually like the "vibe coding" (a horrible name) for making simple personal projects. For production apps, yeah, that's the most horrible thing, since A LOT of things break really quickly, but for a personal use in small, local projects, It's a really nice thing to have in hands. Especially if you are an experienced programmer, you can have a great experience using Cursor or Github Copilot, since you can tell the AI exactly what you want to make, also providing it with well-known libraries and tools. I made a lot of websites and backend projects I haven't had time to make previously for my personal use, and It was mostly a really good experience.

> **@roji556** (👍 6): And yet still better than the offshore contractors that do most code now.

> **@zidenzz** (👍 4): wait till you hear vibe debugging

> **@BlizzetaNet** (👍 0): ​@@zidenzzoh no! ... anyway

> **@ShawnWard-l2n** (👍 2): Vibe coding is basically AI script kiddies. God I hate this so much

### 9. @atenleggedninja (👍 15)
You and I have different definitions of "Backdoored."😂😂

> **@KyeTypesKindaFast** (👍 0): Well who am I to trust, a certified penetration tester or atenleggedninja on YouTube 😅😂

### 10. @SiliconSquire (👍 5)
Thats why we never use electron, instead just webview2 and message bridge between frontend and the backend

> **@v1nigra3** (👍 1): Amen

### 11. @HexOptimal (👍 2)
I remember seeing loki pop up on X and thought it was pretty dope. Fun watching you play with it!

### 12. @Sci-Fun-tist (👍 0)
Thats pretty cool and as a nodejs dev i can dig more into it to find more vulnerablities this approach opens 

And yeah social engineering is must if we want to backdoor someone

### 13. @SapioiT (👍 2)
When I heard you say Bobby Cook, I immediately thought of little Bobby Tables (popularized by XKCD).

### 14. @DefaultYoutubeHandle (👍 2)
Shoutout to boku7 bokuloader. Respect dawg ✊

### 15. @nicodemosmusic_1 (👍 2)
ah i love trying to cut & paste things as they are in use. thats the best time to try to do that!

### 16. @Genielamp25 (👍 5)
I can totally see this being attached to some modded or out-of-date discord client that some poor sap downloads to avoid the less than savoury ui changes discord went through, only to have their account stolen by some e-gangster skiddie and used to spam links in servers.

### 17. @kainoa82858 (👍 75)
To be honest, this is kind of useless -- if you already have control of a victim's machine, there's so many better ways to do C&C. Would've been way more interesting if this showcased an actual entrypoint rather than "replacing files with malicious ones does malicious things."

> **@rainy5883** (👍 4): You'd be surprised how many clueless people will replace some files with malicious ones just to get a 'cool new feature!'

> **@bobcooke90** (👍 19): The method John is demoing in this video is viable for lateral movement and persistence when you have remote access to a box with an existing electron app -- yes this scenario is very likely when red teaming in corporate environments.
 
I've used loki in many ops where it is used for initial access via phishing. It's very successful and bypasses all security controls i've tested it against. When using for initial access you have to take a different approach than shown here. I mention a method i've successfully used in an op in the DM's John shows.

> **@jaynagrecha3792** (👍 1): It’s for persistence, genius. For the attacker to connect back to the victim’s machine AFTER he disconnects himself from his machine and plans to connect back a week later.

> **@kainoa82858** (👍 4): @jaynagrecha3792  read: "there's so many better ways to do C&C".

> **@jaynagrecha3792** (👍 0): @  That, I agree to. Since here our main discussion is revolving around this method of making persistence…. I think, what you say could be show cased when he talks about Initial Access.

### 18. @Wodawic (👍 4)
OUTSTANDING AND CURRENT AS USUAL JOHN.  THANKS.

### 19. @ilikeben (👍 4)
For the fact CHAT GPT ms store app is also electron based.

### 20. @MrMaxiePL (👍 1)
Another reason why Tauri or custom embedding is better than Electron

