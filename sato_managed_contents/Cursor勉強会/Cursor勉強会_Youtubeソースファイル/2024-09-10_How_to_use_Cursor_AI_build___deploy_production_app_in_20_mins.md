# How to use Cursor AI build & deploy production app in 20 mins

**チャンネル:** AI Jason
**公開日:** 2024-09-10
**URL:** https://www.youtube.com/watch?v=bAAbrhb3QoM

## 説明

Tutorial: How to use Cursor build & deploy your dream app
Download Free Python Introduction Ebook: https://clickhubspot.com/ur1x

🔗 Links
- Get full code breakdown & Join AI builder club: https://2ly.link/1zq87
- Follow me on twitter: https://twitter.com/jasonzhou1993
- Join my AI email list: https://www.ai-jason.com/
- My discord: https://discord.gg/eZXprSaCDE

⏱️ Timestamps
0:00 Intro to Cursor
1:19 P1 - Setup
7:02 P2 - Build Frontend
19:39 P3 - Build Auth
23:17 P4 - Build Backend
39:00 P5 - Deploy


👋🏻 About Me
My name is Jason Zhou, a product designer who shares interesting AI experiments & products. Email me if you need help building AI apps! ask@ai-jason.com

#cursor #webscraping  #generativeai #gpt5 #autogen #gpt4 #autogpt #ai #artificialintelligence #tutorial #stepbystep #openai #llm #chatgpt  #largelanguagemodels #largelanguagemodel #bestaiagent #chatgpt #agentgpt #agent #babyagi

## 字幕

[00:03 - 00:07]
今日は、カーソルを使って、

[00:04 - 00:10]
デモだけでなく、プログラミングの知識がなくても、すぐに

[00:07 - 00:12]
使えるフルスタックアプリケーションを構築する方法を紹介します。id8の

[00:12 - 00:17]
セットアップから

[00:14 - 00:18]
フロントエンド、バックエンドの構築、そして

[00:17 - 00:21]
オンラインでのデプロイまでを紹介します。カーソルがわからない方のために、これは

[00:21 - 00:26]
誰もが習得しているAIコードエディタです。

[00:24 - 00:28]
このAIネイティブコードエディタを使えば、ほぼ

[00:26 - 00:30]
誰でも好きなアプリケーションを構築できます。

[00:28 - 00:32]
1年経った今でも、

[00:30 - 00:35]
わずか45分で完全なWebアプリケーションを構築できます。

[00:32 - 00:37]
私たちはすでに、

[00:37 - 00:41]
ビデオエディタの

[00:39 - 00:43]
Chrome拡張機能や暗号通貨取引所など、非常に高品質な製品レベルのアプリケーションを構築した人々を見てきました。

[00:43 - 00:46]
カーソルに関するビデオは数多くありますが、そのほとんどは、

[00:46 - 00:50]
実際の製品対応アプリケーションではなく、簡単なデモの構築方法を紹介しているだけです。

[00:49 - 00:52]
そのため、

[00:50 - 00:53]
このビデオでは、エンド

[00:52 - 00:55]
ツーエンドでアプリケーションの潜在能力をすべてお見せしたいと思います。

[00:55 - 01:00]
この絵文字ジェネレータモデルのような興味深いAIモデルを

[00:57 - 01:01]
Webアプリケーションに変換する方法をお見せします。

[01:00 - 01:04]
ユーザーはあらゆる種類のプロンプトを入力するだけで、

[01:01 - 01:06]
それに基づいて絵文字を生成でき、

[01:04 - 01:07]
誰もが他の人の絵文字を見て、

[01:06 - 01:09]
いいねやダウンロードができ、

[01:07 - 01:12]
完全な認証フロー

[01:09 - 01:13]
も構築できます。 ここでは機能が制限されており、

[01:12 - 01:15]
これにより、

[01:15 - 01:19]
生成されたすべての絵文字とすべての

[01:18 - 01:22]
ユーザーを追跡できるバックハンドセットアップ全体が用意されます。まず最初に

[01:19 - 01:24]
プロジェクトをセットアップします。curs を使用

[01:22 - 01:26]
して Web

[01:24 - 01:28]
アプリ全体をゼロから作成する代わりに、nextjs や react などのライブラリを利用できます。これにより、

[01:28 - 01:33]
開発がはるかに簡単になります。また、

[01:30 - 01:35]
sh C in などの UI コンポーネント ライブラリも利用します。これらのライブラリには、すぐに

[01:37 - 01:42]
使用できる美しい UI コンポーネントが豊富に用意されています。さらに、twin という

[01:39 - 01:44]
CSS またはスタイル ライブラリも用意されており、

[01:42 - 01:48]
コードが読みやすくなります。

[01:44 - 01:50]
そのためには、chn SEL nextjs に移動します。chn

[01:50 - 01:56]
と tellin を使用して nextjs プロジェクトをセットアップするために使用できるコマンド L が 1 つあります。

[01:53 - 01:59]
カーソルに戻り、

[01:56 - 02:01]
ターミナルを開いて MPX CH を少なくとも最初に実行します。続行するか

[01:59 - 02:03]
どうかを尋ねられるので、

[02:01 - 02:05]
y と入力して Enter キーを押します。

[02:03 - 02:07]
次に、

[02:05 - 02:10]
新しい nextjs プロジェクトをセットアップするか

[02:10 - 02:14]
どうかを尋ねられるので、

[02:12 - 02:16]
y と入力します。  「

[02:14 - 02:18]
New York」を選択すると、より凝縮されたビューになり、

[02:16 - 02:19]
配色は好きなように選択できます。

[02:18 - 02:22]
私は「

[02:19 - 02:24]
Neutral」と「CSS variable」を選択して「

[02:22 - 02:26]
Yes」をクリックします。

[02:24 - 02:28]
左側に、さまざまなファイルを含むフォルダーが作成されていることがわかります。

[02:32 - 02:35]
さまざまな用語を紹介するので混乱するかもしれませんが、

[02:34 - 02:37]
ここまで説明してきた

[02:35 - 02:40]
JavaScriptやTypeScriptは

[02:37 - 02:41]
Pythonのようなプログラミング言語です。TypeScriptはJavaScriptの

[02:40 - 02:44]
アップグレード版のようなもので、実行前にコード

[02:44 - 02:47]
の間違いをキャッチする追加の安全機能があり、誤っ

[02:47 - 02:51]
て何かを壊してしまうことがありません。React

[02:49 - 02:54]
とNextJSは、Web

[02:51 - 02:56]
アプリケーションフレームワークで、Webアプリケーションを

[02:54 - 02:58]
より速く構築するのに役立ちます。

[02:56 - 03:00]
複雑なWebアプリケーションを

[02:58 - 03:02]
さまざまなコンポーネントに分割できます。NextJSは

[03:02 - 03:07]
ReactJSをベースに構築されたバリエーションで、Web

[03:04 - 03:09]
アプリケーションの速度に最適化されています。Chassi

[03:07 - 03:12]
inやTellwinなどは、UI

[03:09 - 03:14]
コンポーネントまたはスタイルライブラリで、

[03:16 - 03:20]
最初から構築する代わりに、すぐに使用できる多数のビルド済みUIコンポーネント

[03:18 - 03:22]
とCSSスタイルが用意されています。 これは事前に

[03:20 - 03:24]
定義されており、最終的に mpm

[03:22 - 03:26]
または MPX を使用すると、それらのパッケージをダウンロードできるようにするパッケージ管理

[03:24 - 03:28]
コマンド ライン コードだけになります。

[03:28 - 03:31]
プロジェクト フォルダーを開くと、大量

[03:30 - 03:33]
のさまざまなファイルが

[03:31 - 03:36]
すでに作成されていることがわかります。これは非常に混乱し

[03:33 - 03:38]
、圧倒されるかもしれませんが、これは

[03:36 - 03:40]
Nextjs プロジェクトの一般的な構造のよう

[03:38 - 03:42]
なものです。そのため、通常、アプリ フォルダーは、アプリケーション ページ

[03:40 - 03:45]
のすべてのページを定義する場所です

[03:42 - 03:48]
。  TSXは

[03:45 - 03:50]
index.htmlやホームページのようなものと考えてください。

[03:48 - 03:52]
ライブラリフォルダには、

[03:50 - 03:54]
何らかのユーティリティ関数を保存できます。

[03:52 - 03:57]
また、コンポーネントフォルダも作成され、

[03:57 - 04:00]
さまざまなページで再利用されるあらゆる種類のUIコンポーネントと、

[03:58 - 04:02]
その他のファイルを保存できます。

[04:00 - 04:03]
これらについては、今は気にする必要はありません。これで

[04:02 - 04:05]
実行できます。まず

[04:03 - 04:08]
最初に、

[04:08 - 04:11]
ルートフォルダではなく、NextJSプロジェクトフォルダを開きます。そうしないと、

[04:09 - 04:13]
カーソルが特定のファイルを作成する場所について常に混乱する可能性があります。これを

[04:13 - 04:17]
行うには、このウィンドウを閉じて

[04:14 - 04:19]
特定のサブフォルダを開くか、

[04:17 - 04:22]
上部のバーをクリックして、

[04:19 - 04:24]
カーソルコマンドをインストールします。これが最初のコマンドです。

[04:22 - 04:26]
これをクリックして[OK]をクリックし、パスワードを入力します。

[04:24 - 04:30]
次に、

[04:26 - 04:32]
カーソル絵文字メーカーを実行します。これは

[04:30 - 04:34]
ここにあるフォルダ名です。Enterキーを押すと、

[04:32 - 04:36]
実際のプロジェクトフォルダが開かれます。mpm

[04:36 - 04:43]
run defを実行できます。このコマンドは

[04:40 - 04:44]
package.json内に定義されており、次のSTがあります。

[04:43 - 04:47]
これは基本的に、

[04:44 - 04:48]
開発者サーバーを起動して、ローカルマシン

[04:47 - 04:51]
上のWebロケーションを実行しようとすることを意味します。

[04:48 - 04:53]
Enterをクリックすると、

[04:51 - 04:55]
NextJSプロジェクトが適切に設定されていることがわかります。

[04:53 - 04:57]
ただし、shで知っておくべきことの1つは、

[04:55 - 05:00]
デフォルトではすべての

[04:57 - 05:02]
コンポーネントがプロジェクトに追加されないということです。RLでは、

[05:00 - 05:03]
実際に使用するコンポーネントを選択して追加する必要があります。

[05:02 - 05:06]
そのため、

[05:03 - 05:09]
MPXを実行して

[05:06 - 05:12]
コンポーネント名とoutlayを追加するか、

[05:09 - 05:15]
ターミナルに移動して新しいターミナルを開き、MPX

[05:12 - 05:16]
chass inを実行してEnterをクリックすると、

[05:16 - 05:20]
追加できるすべてのコンポーネントのリストが表示されるので、

[05:20 - 05:25]
使用したいコンポーネントに移動してスペースキーを使用して選択します。

[05:25 - 05:32]
ボタンカードと入力を追加して

[05:29 - 05:34]
Enterをクリックすると、

[05:32 - 05:36]
コンポーネントフォルダーが自動的に

[05:34 - 05:39]
作成され、コンポーネントフォルダー内にUIフォルダーが作成され、

[05:39 - 05:43]
使用するすべてのコンポーネントがインポートされます。これで

[05:40 - 05:45]
プロジェクトが設定されました。

[05:43 - 05:47]
最後に、カーソルを使用して要件に基づいてWebアプリケーションの構築を開始します。

[05:47 - 05:51]
ただし、これに入る前に、

[05:51 - 05:56]
プログラミングとAI開発の

[05:54 - 05:58]
旅を始めたばかりの方や、

[05:56 - 06:00]
ロードマップが実際にどのように見えるかを理解しようとしている方が多いことを私は知っています。そのため、

[05:58 - 06:02]
紹介したいと思います。 この無料電子書籍は

[06:00 - 06:04]
JavaScript入門として最適です。JavaScriptは

[06:04 - 06:08]
Web

[06:07 - 06:09]
アプリケーションを構築するために習得すべき主要言語であり、配布が最も

[06:08 - 06:12]
容易なアプリケーションです。

[06:09 - 06:14]
この電子書籍は、

[06:12 - 06:16]
このビデオのスポンサーであるhopspotによって紹介されています。

[06:14 - 06:18]
この電子書籍では、

[06:16 - 06:20]
JavaScriptと

[06:18 - 06:23]
オブジェクト指向プログラミング全般の基礎、

[06:20 - 06:25]
基本的な構文と概念、

[06:23 - 06:28]
クラスメソッドの定義方法、

[06:25 - 06:30]
アプリケーションへの複雑なロジックの組み込み方法、

[06:28 - 06:31]
さらに高度なヒント（

[06:30 - 06:34]
さまざまな種類のスコープの管理方法、

[06:31 - 06:36]
重要

[06:34 - 06:38]
で人気のあるフレームワークの比較など）を網羅しています。また、コピー＆ペーストで使用できる実用的なコードスニップを含む、

[06:36 - 06:40]
優れたコードとBコードの例も紹介されています。Web開発を

[06:43 - 06:47]
始めたばかりで、カーソルなどのツールを最大限に活用して

[06:45 - 06:49]
夢のアプリを構築したい場合は、

[06:47 - 06:51]
ぜひこの電子書籍を読んで

[06:49 - 06:53]
Web開発の基礎を学んでください。

[06:51 - 06:54]
これは始めるのに最適な場所です。

[06:54 - 06:58]
以下の説明にあるリンクをクリックして、

[06:56 - 07:00]
この電子書籍を無料でダウンロードできます。それでは、

[06:58 - 07:02]
Curカーソルを使用して

[07:00 - 07:04]
このWebアプリケーション全体を構築する方法に戻りましょう。

[07:02 - 07:06]
そのためには、カーソル

[07:04 - 07:07]
コンポーザーを使用します。 これはプロジェクトフォルダと直接やり取りできる非常に強力な

[07:06 - 07:10]
機能で、

[07:10 - 07:14]
プロジェクトファイル全体のコンテキストも保持します。「このアプリケーションの構築を手伝ってください」といった

[07:12 - 07:16]
単純な指示を直接与えるのではなく、

[07:14 - 07:18]
私が

[07:16 - 07:20]
よく行うのは、

[07:18 - 07:23]
カーソルが構築に必要な主要機能の

[07:20 - 07:25]
参照として使用できる製品要件ドキュメントを作成することです。

[07:25 - 07:28]
要件フォルダを作成し、

[07:26 - 07:30]
その中に「

[07:30 - 07:34]
front」というマークダウンファイルと「instructions」を作成します。

[07:32 - 07:36]
カーソルはアプリケーションの一部を

[07:34 - 07:38]
段階的に構築しようとします。instruction

[07:36 - 07:40]
フォルダ内の構造は

[07:38 - 07:42]
通常、

[07:40 - 07:43]
このプロジェクトの概要を示し、

[07:42 - 07:45]
何を

[07:43 - 07:47]
達成しようとしているのかというコンテキストを示します。次に、非常に

[07:45 - 07:49]
詳細な機能要件を記述します。最後に、

[07:51 - 07:54]
呼び出すAPIエンドポイントや

[07:53 - 07:56]
使用する新しいライブラリに関する関連ドキュメントも含めます。これは、

[07:54 - 07:58]
モデルが使用するさまざまなライブラリの最新のドキュメントにアクセスできないことがよくあるためです。

[08:00 - 08:03]
最後に、

[08:01 - 08:05]
現在のファイル

[08:03 - 08:07]
構造がどのようなものかモデルに伝え、

[08:05 - 08:09]
適切な場所にファイルを作成できるようにします。

[08:07 - 08:11]
この部分については後ほど詳しく説明します。

[08:09 - 08:14]
このプロジェクトでは、sdxl emoi

[08:11 - 08:16]
というレプリケート上のモデルホストを使用します。

[08:14 - 08:18]
このモデルは

[08:16 - 08:20]
プロンプトを受け取り、絵文字

[08:18 - 08:23]
スタイルファイルを生成できます。

[08:20 - 08:25]
プロジェクトファイルに戻り、プロジェクトの概要について説明します。

[08:23 - 08:27]
このガイドを使用して、

[08:25 - 08:29]
ユーザーがテキストプロンプトを入力して

[08:27 - 08:31]
絵文字を生成できるWebアプリケーションを構築します。レプリケートでmodo postを使用します。

[08:29 - 08:33]
機能要件については、

[08:33 - 08:39]
next.js chassen Lucidを使用します。これは

[08:37 - 08:40]
使用するアイコンライブラリです。super baseは

[08:40 - 08:44]
バックアンドを構築するために使用します。clar clarは

[08:44 - 08:49]
ユーザー認証を構築するために使用するライブラリです。次に、

[08:46 - 08:51]
ユーザーがプロンプトを入力できるフォームを作成します。

[08:49 - 08:53]
ボタンをクリックすると、

[08:51 - 08:55]
レプリケートモデルが絵文字を生成します。

[08:53 - 08:57]
絵文字が

[08:55 - 09:00]
空白または生成されている場合は、

[08:57 - 09:02]
Graでこれまでに生成されたすべての画像が表示されます。

[09:00 - 09:05]
各絵文字画像にホバーすると、ダウンロード用のアイコンボタンと

[09:02 - 09:07]
いいね！用のアイコンボタンが

[09:05 - 09:09]
表示されます。

[09:07 - 09:11]
基本的に、どのライブラリを使用するかについて説明し

[09:09 - 09:14]
、詳細を説明します。

[09:14 - 09:18]
ユーザーがどのような機能インタラクションを行うかという要件です。

[09:16 - 09:20]
通常は、

[09:18 - 09:22]
できるだけ具体的に記述する必要があります。その後、

[09:20 - 09:25]
関連ドキュメントを参照します。このモデルを使用しているので、「

[09:22 - 09:27]
API」タブに移動し、「

[09:25 - 09:29]
Jaz」ノードのコンテンツをコピーして、「

[09:27 - 09:31]
Replicate Emoji Generator Model」の使用方法に関するサブセクションを作成します。

[09:31 - 09:35]
ドキュメントを貼り付けることで、モデルは

[09:33 - 09:37]
エンドポイントの呼び出し方法と必要なすべての入力を認識できます。

[09:37 - 09:40]
この「現在のファイル

[09:38 - 09:42]
構造」セクションは実は非常に

[09:40 - 09:45]
重要だと感じています。カーソルは一般的に

[09:45 - 09:48]
ファイル構造を理解するのがあまり得意ではなく、

[09:46 - 09:50]
間違った場所にファイルを作成したり、

[09:50 - 09:54]
私が従っているファイル構造に従わなかったりすることがよくあるようです。左側の

[09:52 - 09:57]
ファイル構造のスクリーンショットを撮り、

[09:57 - 10:01]
右側のチャットを開いてスクリーンショットの後に

[09:59 - 10:04]
ファイル構造の生成を手伝ってもらいます。コマンド+

[10:01 - 10:06]
Enterでコード

[10:04 - 10:07]
ベース全体を評価します。

[10:06 - 10:09]
すると、ファイル構造全体が生成されているのがわかります。これは

[10:09 - 10:13]
非常に便利です。コピー＆ペーストするだけで済みます。

[10:12 - 10:15]
最後に、

[10:13 - 10:17]
すべての新しいコンポーネントに適用する特定のルールを入力します。

[10:15 - 10:19]
/components フォルダーに移動して

[10:17 - 10:21]
特定の形式で名前を付けると、

[10:19 - 10:24]
すべてのページが

[10:21 - 10:26]
アプリ フォルダーに移動し、このコンテキスト カーソルで

[10:26 - 10:31]
適切な場所にファイルを作成できるようになります。これで、

[10:28 - 10:33]
カーソルを使用してプロジェクト全体を構築できるようになります。

[10:31 - 10:35]
これを実行している間、

[10:33 - 10:38]
カーソルが

[10:35 - 10:41]
入力として画像も取得できることに気付くでしょう。つまり、

[10:38 - 10:43]
実際に figma mup をこの

[10:41 - 10:45]
プロジェクトに参照として追加できるということです。これで

[10:45 - 10:50]
必要なものはすべて揃いました。最後のステップでは、

[10:47 - 10:52]
プロジェクト フォルダーに env という新しいファイルを作成します

[10:50 - 10:54]
。 ここで、

[10:54 - 10:58]
レプリケートの API キーなどのすべての資格情報を保存します。アカウントを

[10:56 - 11:00]
作成した後、レプリケート API キーを取得できます。

[10:58 - 11:02]
レプリケートをまだインストールしていない場合は、

[11:00 - 11:05]
mpm install replicat を実行する必要があります。

[11:02 - 11:09]
ターミナルを開いて貼り付けると、

[11:05 - 11:11]
カーソルを使用して

[11:09 - 11:15]
プロジェクトのセットアップを開始できます。コマンド I を使用し

[11:11 - 11:19]
、ページも選択します。  TSX は、

[11:19 - 11:25]
指示に基づいて Emoji メーカー アプリ全体を構築するのを手伝ってくれるように言います。そのため、

[11:25 - 11:31]
前に参照として作成した指示の macdown ファイルを追加できます。UI は

[11:27 - 11:34]
mup に似ている必要があるため、

[11:31 - 11:37]
画像ファイルも参照できます。その後、

[11:34 - 11:39]
Enter をクリックすると、

[11:37 - 11:42]
2 つの新しいコンポーネントが作成されます。1 つは Emoji generator と呼ばれ、

[11:42 - 11:46]
プロンプトでポイントして

[11:44 - 11:48]
複製モデルを呼び出すことができるフォームと、これまでに作成された

[11:46 - 11:51]
すべての絵文字を表示する Emoji grid があります。また、その

[11:51 - 11:56]
中に、ルートを含む generate Emoji フォルダーと呼ばれる API フォルダーも作成されます

[11:54 - 11:58]
。  TS は、

[11:56 - 12:01]
複製モデルを呼び出し、最後に、

[11:58 - 12:02]
次に実行する必要があると思われるアクションも表示します。たとえば、

[12:02 - 12:08]
絵文字を取得して保存するためのバックエンドを作成します。

[12:06 - 12:11]
ダウンロード機能を実装し、より多くの

[12:08 - 12:12]
スタイルを設定します。これを使用して、

[12:11 - 12:14]
モデルにさらに多くの機能を構築するように要求し続けることができます

[12:12 - 12:16]
が、まずは

[12:14 - 12:19]
すべてを受け入れましょう。矢印はこのように見えます。

[12:19 - 12:24]
絵文字ジェネレーターにクライアントの使用を入れていないようです。これをデバッグするには、

[12:24 - 12:29]
ここに矢印メッセージを入力して Enter キーを押すか、またはクリックします。ただし、

[12:29 - 12:33]
カーソルが

[12:31 - 12:35]
自動的にファイルの作成を開始し、チャットと比較して

[12:33 - 12:37]
混乱することがあるため、チャット UI を実際に使用する方がよいことがよく

[12:35 - 12:39]
あります。チャットでは、実際に

[12:37 - 12:41]
少し適切に制御できるため、ここでは

[12:39 - 12:44]
矢印の部分が絵文字

[12:41 - 12:47]
ジェネレーターであることがわかります。または、コンポーネントの絵文字ジェネレーターに移動します

[12:44 - 12:49]
。  TSXで矢印ファイルを

[12:47 - 12:52]
ここに配置してプロンプトを表示します。この

[12:49 - 12:55]
矢印を呼び出します。ルールコスト同期は

[12:52 - 12:57]
段階的に実行され、コマンドを入力すると、

[12:57 - 13:03]
何が起こっているのか、どのような問題があるのか​​について非常に具体的な説明が表示され、

[13:00 - 13:04]
最終的には

[13:03 - 13:07]
解決策が示されます。

[13:04 - 13:10]
基本的に、絵文字ジェネレーターに移動して

[13:07 - 13:13]
上部にuse clientを追加します。use clientは

[13:10 - 13:14]
基本的にTXセットの一種で、

[13:13 - 13:17]
このファイルにサーバー側ではなくクライアント側

[13:14 - 13:19]
で間違っている必要がある機能があることをnextjsに示します。これにより、

[13:19 - 13:23]
次のJはこの

[13:21 - 13:25]
アプリケーションをレンダリングして速度を最適化する方法がわかります。

[13:23 - 13:27]
これを保存すると、新しい

[13:25 - 13:29]
矢印が作成されますが、同じ問題のように見えます。

[13:27 - 13:32]
絵文字Gに移動して

[13:29 - 13:36]
use clientを実行するだけです。これで、

[13:32 - 13:38]
このアプリのUIが希望どおりに近づきました。プロンプトを

[13:36 - 13:40]
配置できる場所があり、

[13:40 - 13:44]
クリックして絵文字を生成できるボタンがあります。これは、

[13:42 - 13:45]
複製モデルと呼ばれるものと想定しています。絵文字を表示するため

[13:44 - 13:48]
に使用される画像グレードがあり、

[13:45 - 13:50]
それらの上にマウスを移動すると

[13:48 - 13:52]
ダウンロードボタンが表示されます。

[13:50 - 13:55]
絵文字は表示されませんが、これは素晴らしいことです。

[13:55 - 13:58]
現時点ではプレースホルダー画像をいくつか配置しているだけだと思う​​ので、

[13:56 - 14:01]
試してみましょう。Doc に

[13:58 - 14:03]
配置して Enter キーをクリックすると、

[14:01 - 14:05]
このような読み込み状態になります。

[14:03 - 14:07]
この矢印が表示されます。

[14:05 - 14:10]
同じことをして、

[14:07 - 14:14]
すべてをコピーして、最後に矢印に貼り付けます。replicate を

[14:14 - 14:22]
呼び出して Emoji を生成した後、この矢印が表示されます。

[14:18 - 14:25]
ルート コストは何かと考えられます。

[14:22 - 14:28]
ステップ バイ ステップで同期してみましょう。

[14:25 - 14:31]
このような一連の操作は、

[14:28 - 14:33]
解決の精度を高める上で確実に役立つことがわかったので、

[14:33 - 14:39]
すぐに解決するのではなく、これを追加することを好みます。もう一度コマンド

[14:36 - 14:41]
Enter キーを押すと、ルート CA の分析が開始されます。

[14:39 - 14:44]
この矢印が

[14:41 - 14:46]
表示される主な理由は、next.js

[14:44 - 14:49]
の特別な種類の画像コンポーネントを使用しているためです。

[14:46 - 14:52]
ただし、デフォルトではセキュリティ上の

[14:49 - 14:55]
理由から、nextjs は信頼できるソースからの画像のみを提供するため、これを

[14:52 - 14:59]
解決するには、

[14:55 - 15:02]
実際に次に進む必要があります。  config

[14:59 - 15:05]
MJS ファイルを編集し、信頼できるソースの 1 つとして複製を追加します。

[15:05 - 15:12]
これをコピーして、複製実行

[15:08 - 15:14]
配信を信頼ドメインとして貼り付け、保存します。

[15:12 - 15:17]
これで、ローカル ホスト

[15:14 - 15:17]
リフレッシャー ページに戻って、これをもう一度実行できます。

[15:22 - 15:26]
画像が生成され、

[15:24 - 15:30]
ここに表示されていることがわかります。ただし、画像が

[15:26 - 15:32]
絵文字のようには見えないので、なぜ

[15:30 - 15:35]
だろうと思います。プロンプト内には

[15:32 - 15:37]
通常、何かの画像を取得するというプレフィックスが付いているので、

[15:35 - 15:40]
おそらくこれが

[15:37 - 15:42]
欠落しているものです。カーソルに戻ると、

[15:40 - 15:45]
その部分は一般的な絵文字 ru の下にあると思います

[15:42 - 15:48]
。  TSなので、実際の外部

[15:45 - 15:51]
API呼び出しはすべてこのAPIフォルダの下にあります。

[15:48 - 15:53]
現在はpromptという名前になっています。

[15:51 - 15:56]
これを変更して、このプレフィックスと

[15:53 - 15:58]
トークンEmojiを追加し、これをもう一度保存して

[15:56 - 16:00]
ページを更新し、猫を配置して

[15:58 - 16:02]
再度生成します。これで

[16:00 - 16:04]
実際の絵文字スタイルが生成されていますが、

[16:02 - 16:06]
新しく

[16:04 - 16:08]
生成された画像が実際には画像グレードに追加されないという問題が見つかりました。

[16:06 - 16:10]
カーソルに移動して

[16:08 - 16:12]
追加するように要求できますが、その前に

[16:10 - 16:17]
GitHubに移動して、submit

[16:12 - 16:20]
basic layoutとreplicate modelを追加し、コミットしてプッシュします。

[16:17 - 16:23]
次に、

[16:20 - 16:28]
カーソルに移動してcomposerを開き、

[16:28 - 16:30]
絵文字生成機能が

[16:30 - 16:38]
動作していることを伝えます。ただし、新しく生成されたものは

[16:35 - 16:43]
画像グレードに追加される必要があります。

[16:38 - 16:47]
手順は次のとおりです。

[16:43 - 16:49]
この機能を実現するための手順は次のとおりです。ステップごとに同期してみましょう。

[16:47 - 16:53]
まず、

[16:49 - 16:56]
共有状態を作成し、Emoji

[16:53 - 16:59]
generate componentsを更新して状態を更新し、

[16:56 - 17:01]
Emoji Gadeコンポーネントを更新して

[16:59 - 17:03]
状態に基づいて画像を表示します。

[17:01 - 17:07]
ここではzustandという状態管理ライブラリを使用しています。指示された

[17:03 - 17:10]
とおりに

[17:07 - 17:13]
npmを実行します。  Zスタンドをインストールします。完了しました。

[17:13 - 17:21]
すべてを受け入れます。この矢印が再び表示されます。

[17:17 - 17:22]
矢印をコピーして貼り付けます。

[17:22 - 17:30]
次のconfit MJSファイルを再度更新するか、

[17:27 - 17:32]
コピーして保存する必要があるようです。

[17:30 - 17:36]
また、プロジェクトを再構築してみます。control

[17:32 - 17:39]
cとmpm run defを実行します。

[17:36 - 17:43]
別の矢印が表示されます。実際には、

[17:39 - 17:48]
この矢印メッセージ全体をここにコピーして貼り付けることができます。mpm

[17:48 - 17:54]
run defを実行した後、この矢印が表示されます。解決に役立つため、

[17:51 - 17:58]
ここに貼り付けます。基本的には、

[17:54 - 18:01]
requirをプロセスfalseに変更して

[17:58 - 18:05]
再度保存し、mpm wrong depを実行します。

[18:01 - 18:09]
では、docを試してみましょう。

[18:05 - 18:11]
新しい画像がここに表示され、

[18:09 - 18:13]
画像Gadeにも追加されます。

[18:11 - 18:16]
もう1つ追加すると、すべての

[18:13 - 18:18]
画像が自動的に画像グレードに追加されることがわかります。

[18:16 - 18:20]
次に、

[18:18 - 18:23]
最後の2つの機能を実装するだけです。1つは

[18:20 - 18:25]
画像のダウンロードと画像のいいねですが、

[18:23 - 18:30]
これも同じことです。GitHubに移動してコミットを

[18:25 - 18:32]
追加します。画像グレードpo playを表示します。

[18:30 - 18:34]
カーソルコンポーザーに戻って

[18:32 - 18:36]
プロンプトをスキップします。では、機能を実装しましょう

[18:34 - 18:38]
画像のダウンロードと「いいね！」については、

[18:36 - 18:40]
ダウンロードアイコンボタンをクリックすると、

[18:38 - 18:42]
画像がローカルコンピュータにダウンロードされ、「

[18:40 - 18:45]
いいね！」アイコンボタンをクリックすると、

[18:42 - 18:47]
ボタンが自動的にフィールドスタイルに切り替わり、

[18:47 - 18:53]
このユーザーが既に画像に「いいね！」したことを示すとともに、

[18:53 - 18:58]
下部に表示される「いいね！」の数が増加します。「

[18:55 - 19:01]
入力」をクリックして絵文字ストアファイルを更新し、「

[19:01 - 19:05]
いいね！」の数を増やし、絵文字の中でグレード付けを行います。

[19:03 - 19:07]
ダウンロードと「いいね！」の機能を実装し、「

[19:05 - 19:10]
承認」をクリックして

[19:07 - 19:13]
ローカルホストに戻り、

[19:10 - 19:16]
もう一度実行してみます。画像が生成されたら、「

[19:13 - 19:19]
ダウンロード」ボタンをクリックすると

[19:16 - 19:21]
ダウンロードが開きます。「保存」をクリックすると、画像が

[19:19 - 19:23]
ダウンロードされました。「いいね！」を

[19:21 - 19:25]
クリックすると、「いいね！

[19:23 - 19:29]
」が更新されたことがわかります。「いいね！」しないと「いいね！」

[19:25 - 19:31]
の数が減ります。

[19:31 - 19:37]
これでコア機能はすべて作成されました。

[19:34 - 19:39]
実装された「いいね！」と

[19:37 - 19:41]
ダウンロードをプッシュします。次に、

[19:39 - 19:43]
ユーザー

[19:41 - 19:45]
認証を設定します。つまり、

[19:43 - 19:48]
アプリケーションを使用するにはサインアップする必要があります。

[19:45 - 19:50]
また、ユーザーに課金するためのクレジットシステムや支払いシステムを構築することもできます。ユーザーの

[19:51 - 19:56]
サインインとオフフローを構築する方法はいくつかあります。  Super Base

[19:54 - 19:57]
もデフォルトの統合機能を提供していますが、

[19:56 - 19:59]
それでも多くの UI を

[19:57 - 20:01]
自分で構築する必要があります。そこで、私は Clark を使用します。

[20:02 - 20:06]
これは、システムに簡単に統合できる送信ボックス ユーザー管理プラットフォームで、

[20:04 - 20:08]
さまざまな方法をサポートしています。この

[20:06 - 20:10]
プロセスは、

[20:08 - 20:12]
さまざまな Web アプリケーション間でかなり標準化される予定です。

[20:13 - 20:18]
ここでは、その方法を説明します。Clark にアクセスしてアカウントを作成すると、

[20:15 - 20:20]
アプリケーションの作成を求められます。Emoji maker という名前を付けます。Boxx

[20:20 - 20:24]
ではさまざまなサイン オプションも提供され

[20:35 - 20:40]
ています。次に、アプリケーションの作成をクリックし、ここの指示に従います。まず、Clark パッケージをインストールする必要があるため、カーソルに戻って mpm install Clark SL nextjs を実行し、資格情報をコピーして env に配置します

[20:37 - 20:42]
。 最後に、

[20:40 - 20:44]
middleware dotsというファイルを作成します。middleware

[20:42 - 20:46]
は、

[20:46 - 20:49]
何らかの

[20:48 - 20:51]
関数が呼び出されるたびに存在するコードと考えることができます。

[20:49 - 20:53]
通常、ここで認証を実装します。

[20:51 - 20:54]
そうでない場合は、すべてのコードに

[20:53 - 20:57]
認証と

[20:54 - 20:59]
機能ゲーティングを実装する必要があります。

[20:57 - 21:01]
ここで提供されるデフォルトの設定は

[20:59 - 21:04]
非常に基本的なものなので、これをコピーして

[21:01 - 21:08]
ルートフォルダのcursorに戻り、

[21:04 - 21:10]
middleware dotsファイルを作成し

[21:19 - 21:23]
ます。繰り返しますが、ドキュメント全体をコピーしてマークダウンファイルに貼り付け、cursorにそのように実行させることもできますが、認証はさまざまな種類のWebアプリケーションで標準的な方法であるため、その

[21:21 - 21:25]
方法を説明します。これを貼り付けます。

[21:23 - 21:27]
これは標準的な方法です。

[21:25 - 21:29]
特定の部分のコードがわからない場合は、この

[21:27 - 21:30]
コードをハイライトして

[21:29 - 21:33]
チャットを追加すると、コードの説明が表示されます。

[21:30 - 21:35]
大まかに言うと、URLが

[21:33 - 21:36]
これらのパターンの近くにある場合は、この

[21:35 - 21:38]
middlewareコードがRになりますが、現時点では

[21:36 - 21:40]
実際には何もゲーティングしていません。

[21:38 - 21:42]
ここでコードを少し更新します。

[21:40 - 21:44]
まず、matを作成します。

[21:42 - 21:46]
サインアップ ユーザーのみに制限するページを作成し、

[21:44 - 21:48]
デフォルトを追加して

[21:46 - 21:49]
すべてのページをポイントしますが、

[21:48 - 21:51]
特定のページのみを取得するように変更することもできます。

[21:49 - 21:53]
次に、ユーザー

[21:51 - 21:55]
ID が存在せず、

[21:53 - 21:57]
それらのタイプの否定的なページにアクセスしようとしている場合は、サイン

[21:55 - 22:00]
インにリダイレクトし、

[21:57 - 22:02]
サインインが成功した後はホームページに戻るというロジックを記述します。

[22:02 - 22:07]
一方、ユーザー ID が存在する場合は、

[22:04 - 22:09]
次のアクションに進みます。次に、サイン

[22:10 - 22:14]
インしていない場合はサインイン ボタンが表示され、既にサインインしている場合はプロファイル コンポーネントが表示されるコンポーネントも作成します。その

[22:12 - 22:16]
ため、

[22:14 - 22:19]
components フォルダーに移動して、headers ttsx という新しいファイルを作成します。このファイルは

[22:19 - 22:23]
次のようになります。

[22:21 - 22:26]
このコードを強調表示し、チャットを追加してカーソルを取得し、

[22:23 - 22:29]
コードについて説明します。最後に、

[22:26 - 22:31]
レイアウトに移動します。  TSX は 2 つのものをインポートします。Clark

[22:29 - 22:33]
プロバイダーです。これは、

[22:31 - 22:35]
Clark を有効にできるものです。また、

[22:33 - 22:37]
先ほど定義したヘッダー コンポーネントです。Clark を

[22:35 - 22:40]
有効にするのは実はとても簡単です。

[22:37 - 22:42]
この HTML を Clock プロバイダーの下にラップするだけです。これで

[22:40 - 22:43]
ほぼ完了です。Clock は

[22:43 - 22:47]
他のすべてを自動的に処理します。最後に、

[22:45 - 22:50]
ここにヘッダー コンポーネントを挿入して

[22:47 - 22:52]
保存します。これで、

[22:50 - 22:54]
デフォルトで Local Host に再度アクセスしようとすると、

[22:52 - 22:56]
自動的にサインイン ページに

[22:54 - 22:58]
移動し、Emoji Maker にサインインします。Google またはメール アドレスでサインインできます。

[22:56 - 23:01]
ログインすると、

[22:58 - 23:03]
実際のアプリに移動し、

[23:01 - 23:05]
右上隅にプロフィール

[23:03 - 23:07]
アイコンがあります。ここでアカウントを管理したり、サインアウト

[23:05 - 23:09]
したりできます。認証も機能します。

[23:07 - 23:11]
最後に、

[23:09 - 23:13]
データベースとストレージを Super Base に接続して、

[23:11 - 23:15]
各ユーザーの

[23:13 - 23:17]
クレジット数、

[23:15 - 23:18]
作成した絵文字の種類、各絵文字に

[23:17 - 23:20]
追加されたいいねの数を追跡できるようにします。

[23:18 - 23:23]
バックハンドには Super Base を使用します。Super

[23:20 - 23:25]
Base は、モバイル アプリケーションと Web アプリケーションの両方に完全なバックエンドを提供します。

[23:23 - 23:28]
これは、

[23:25 - 23:30]
2019 年にオープンソースの FireB として作成されました。 よく

[23:30 - 23:35]
使われる2つの主要なものはFirebase

[23:33 - 23:37]
とAWS Amplifyです。どちらも機能しますが、

[23:35 - 23:39]
問題は、どちらも

[23:39 - 23:44]
Google CloudまたはAWSの特定のベンダーに縛られてしまうことです。そこで

[23:41 - 23:45]
Superbaseが開発され、急速に人気を博しました。Superbaseは、

[23:45 - 23:50]
データベース

[23:47 - 23:52]
認証、ファイルストレージ、

[23:50 - 23:54]
ベクター埋め込みまでをカバーする4つのスタックバックエンドを提供しています。データベースは、

[23:54 - 23:58]
最も先進的なオープンソースリレーショナル

[23:56 - 24:00]
データベースの1つであるPostcatをベースに構築されています。また、さまざまなWebおよびモバイルアプリケーションフレームワークで、

[23:58 - 24:02]
すべてのバックエンドサービスに簡単に接続するためのフロントエンドSDKも提供しています。バックエンドや

[24:04 - 24:09]
データベースをこれまで構築したことがない場合は、これは

[24:06 - 24:11]
難しいように思えるかもしれませんが、

[24:09 - 24:12]
実際には始めるのはかなり簡単です。

[24:11 - 24:14]
通常、

[24:12 - 24:16]
どのようなデータテーブルを

[24:14 - 24:18]
作成する必要があるかを考えます。

[24:20 - 24:25]
アプリケーションの実行に必要なすべてのデータを格納するためのExcelファイルシートがあると仮定します。私たちの絵文字メーカーでは、

[24:23 - 24:27]
基本的に2つのテーブルが必要です。ほとんどの場合、

[24:29 - 24:31]
各ユーザーに関するすべての情報を格納するためのユーザーまたはプロファイルテーブルが必要です。各ユーザーについて、ユーザーID、価格帯、ユーザー数など、

[24:30 - 24:33]
どのような

[24:31 - 24:36]
データ列が必要かを検討する必要があります。

[24:36 - 24:40]
クレジットは残っています。また、

[24:39 - 24:42]
ストライプの顧客 ID またはストライプの

[24:40 - 24:44]
サブスクリプション ID があり、私たちが持っているすべての絵文字に関する支払いを実装したい場合は、

[24:44 - 24:48]
ID、

[24:46 - 24:50]
画像の URL、

[24:48 - 24:52]
絵文字を生成するために使用されたプロンプト、

[24:50 - 24:55]
いいねの数、作成者のユーザー ID を保存する必要があります。

[24:52 - 24:57]
画像 J については、

[24:55 - 24:59]
すべての画像ファイルの保存に superbase ストレージを使用します。

[24:57 - 25:01]
バックエンドのセットアップを開始するには、

[24:59 - 25:02]
最初に super base としてアカウントを作成し、

[25:01 - 25:05]
その後、新しい

[25:02 - 25:08]
プロジェクトを作成して Emoji maker という名前を付け、

[25:05 - 25:09]
パスワードを入力して [作成] をクリックします。

[25:08 - 25:12]
作成したら、comeet ボタンをクリックして

[25:09 - 25:16]
アプリ フレームワークに移動し、

[25:12 - 25:18]
この資格情報を env にコピーします。  Lo

[25:16 - 25:20]
ファイルなので、この絵文字メーカーで実行する手順は、

[25:18 - 25:22]
まず

[25:20 - 25:24]
関連するスーパーベースのテーブルとバケットを作成し、

[25:22 - 25:26]
次にバックエンド

[25:24 - 25:29]
機能を1つずつ実装することです。1つは接続用で、

[25:29 - 25:33]
ClarkのプロフィールテーブルPoを作成します。2つ目は、

[25:31 - 25:35]
ストレージバケットに画像をアップロードして、

[25:35 - 25:39]
アクセスできる画像URLを取得します。次に、

[25:37 - 25:41]
ユーザーが新しい絵文字を生成したり、

[25:39 - 25:43]
いいねボタンを更新したりするたびに絵文字テーブルを更新するように設定します。

[25:41 - 25:45]
まず、ユーザーテーブルを設定します。これには

[25:43 - 25:47]
2つの方法があります。1つは

[25:45 - 25:50]
テーブルエディターに移動して

[25:47 - 25:53]
新しいテーブルをクリックすることです。プロファイルなどの名前を付けるための便利なUIが提供されます。

[25:53 - 25:59]
次に、

[25:54 - 26:01]
ユーザーIDティアなど、必要なすべての列を定義します。ティアはティアにすることができます。

[25:59 - 26:03]
各列のデータ型を定義できます。

[26:01 - 26:06]
ティアには

[26:03 - 26:08]
テキストを選択します。デフォルト値を定義することもできます。

[26:06 - 26:11]
デフォルトでは

[26:08 - 26:13]
無料です。特定の設定には、

[26:11 - 26:15]
このフィールドがオプションであるかどうかを示すnorbleがあります。私

[26:13 - 26:18]
の場合、このフィールドは

[26:15 - 26:21]
オプションではないので、クレジットと同様にチェックを外します。

[26:18 - 26:24]
各ユーザーが

[26:21 - 26:26]
例えば3つの

[26:24 - 26:27]
クレジットを設定できるとします。このようにクレジットを設定できます。

[26:26 - 26:29]
また、これは正常ではないはずです。

[26:30 - 26:35]
このようにUIを使用してテーブルを作成できますが、私がお勧めするのは

[26:32 - 26:37]
SQLエディタに移動してテーブルを設定することです。

[26:35 - 26:39]
ここにこのSQLコードを貼り付けます。

[26:37 - 26:41]
これにより、profilesというテーブルが作成されます。このテーブルには、

[26:39 - 26:44]
主キーであるユーザーID、

[26:41 - 26:46]
デフォルトのクレジットは3つ、ティアの

[26:44 - 26:49]
デフォルトは無料です。これは

[26:46 - 26:51]
無料とProの両方にすることができます。Stripeの顧客ID

[26:49 - 26:52]
とStripeのサブスクリプションID（後で

[26:51 - 26:55]
支払いを設定する場合）、日付が含まれます。

[26:52 - 26:56]
作成して更新すると、

[26:55 - 26:59]
クリックすると成功メッセージが返されます。Road

[26:56 - 27:01]
post returnです。テーブル

[26:59 - 27:03]
エディタに移動すると、

[27:01 - 27:06]
ユーザーID、

[27:03 - 27:08]
クレジット、ティア、サブスクリプション、Stripe ID、

[27:06 - 27:10]
日付を含むテーブルが作成されていることがわかります。新しい列を追加したい場合は、

[27:08 - 27:12]
ここにも新しい列を追加できます。

[27:10 - 27:14]
次に、絵文字テーブルも作成します。

[27:12 - 27:16]
新しい絵文字を追加します。IDは

[27:14 - 27:18]
主キーであり、IDは

[27:16 - 27:21]
自動的に生成されます。画像のURL、

[27:18 - 27:23]
プロンプト、いいね！の数、作成者の

[27:21 - 27:26]
ユーザーID、日付を作成します。  「

[27:23 - 27:29]
OK」をクリックすると成功です。Emoji

[27:26 - 27:30]
テーブルが作成されているのが確認できます。

[27:29 - 27:33]
最後に、

[27:30 - 27:35]
ストレージも設定します。

[27:33 - 27:37]
ストレージは、すべての画像OSをアップロードする場所です。

[27:35 - 27:40]
スタートメニューで「

[27:37 - 27:42]
新しいバケット」をクリックし、テーブルを作成して「

[27:40 - 27:43]
emojis」という名前を付けます。

[27:42 - 27:45]
アプリケーションでは、画像を

[27:43 - 27:47]
誰でもアクセスできるように公開します。これで

[27:45 - 27:50]
設定はほぼ完了です。次に、カーソルにバックエンド機能を

[27:47 - 27:51]
設定するように指示します。

[27:51 - 27:55]
要件フォルダ内に、使用するTXスタックの概要を

[27:53 - 27:57]
示す新しいバックハンドインストラクションを作成します。

[27:57 - 28:01]
また、

[27:59 - 28:03]
既に作成済みの「テーブルとバケット」セクションも追加します。

[28:01 - 28:05]
カーソルがスキーマの

[28:03 - 28:07]
外観を把握できるようにします。ここでは、

[28:07 - 28:10]
Super Baseで使用するSQLクエリを直接コピーして貼り付けることができます。

[28:09 - 28:12]
要件セクションには、同期できる

[28:10 - 28:14]
すべてのバックエンド機能をリストします。

[28:14 - 28:18]
いくつかの機能があります。1つは、

[28:16 - 28:20]
ユーザーテーブルにユーザーを作成する機能です。ユーザーが

[28:18 - 28:21]
Clarkにサインインした後、

[28:20 - 28:24]
ClarkからユーザーIDを取得し、プロファイルテーブルにユーザーが既に存在するかどうかを確認します。存在しない場合は、

[28:21 - 28:27]
プロファイルテーブルにユーザーが既に存在するかどうかを確認します。

[28:24 - 28:29]
存在する場合は、プロファイル テーブルにユーザーを作成し、

[28:27 - 28:31]
ユーザーがすでに存在する場合は、

[28:29 - 28:33]
続行して、

[28:31 - 28:36]
絵文字を生成するなどの関数にユーザー ID を渡します。次に、生成さ

[28:33 - 28:39]
れた絵文字をスター

[28:36 - 28:41]
バケットにアップロードし、絵文字テーブルに行を追加します。

[28:41 - 28:46]
画像グレード内のすべての画像も表示し

[28:43 - 28:47]
、同様のインタラクションも実装します。

[28:46 - 28:49]
最後に、ドキュメントも追加できます

[28:47 - 28:50]
が、スーパー ベースは

[28:49 - 28:52]
非常に人気があるため、

[28:50 - 28:55]
あまり多くのものを追加する必要はありませんでした。例としてこれを追加しただけで、[

[28:52 - 28:58]
保存] をクリックして、

[28:55 - 29:00]
レイアウトに戻ります。  TSX を実行してから

[28:58 - 29:02]
コマンド I を実行します。MD

[29:02 - 29:06]
に基づいて Emoji メーカー Web アプリケーション フロント エンドを構築する手順を説明します。次に、

[29:06 - 29:11]
バックエンドの手順に基づいてバックエンド機能を構築します。まず、

[29:09 - 29:12]
ユーザー テーブル同期を作成して、

[29:11 - 29:15]
これを実装する手順を説明します。

[29:12 - 29:17]
手順ごとに同期してから、[

[29:15 - 29:19]
Enter] をクリックします。ここで、

[29:17 - 29:21]
ユーザー プロファイルの

[29:19 - 29:23]
作成と検証を処理する新しい API ルートを作成し、ユーザー プロファイル初期化子と

[29:21 - 29:25]
呼ばれるコンポーネントも作成します。このコンポーネントは、

[29:23 - 29:28]
Clark をチェックして

[29:25 - 29:31]
ユーザーがすでにサインインしているかどうかを確認し、サインインしている場合は

[29:28 - 29:35]
ユーザーの検証を続行して、

[29:31 - 29:38]
このコンポーネントをレイアウトに追加します。

[29:35 - 29:41]
TSXですが、ここに使用されているクライアントを追加し忘れたと思われる矢印があります。

[29:41 - 29:46]
このような問題が発生した場合は、

[29:43 - 29:47]
チャットで質問するか、

[29:47 - 29:51]
ユーザープロファイル

[29:49 - 29:54]
初期化ツールに移動して「use client」を追加するだけです。これは

[29:51 - 29:56]
モデルが見つからないことを示す別の矢印です。

[29:54 - 29:59]
この矢印を解決するには、

[29:56 - 30:01]
矢印をコピーしてチャットに貼り付け、AIに

[29:59 - 30:02]
解決方法を教えてくれます。

[30:01 - 30:04]
これは非常に

[30:02 - 30:06]
簡単なはずです。スーパーベースをインストールするだけです。

[30:04 - 30:09]
新しいターミナルをクリックして

[30:06 - 30:11]
パッケージをインストールします。

[30:09 - 30:14]
今回はアプリが

[30:11 - 30:16]
正常に実行され、ユーザーがログインしていることがわかります。

[30:14 - 30:19]
確認してみましょう。ただし、

[30:16 - 30:21]
プロファイルテーブルには実際にはユーザーが作成されていません。その

[30:19 - 30:24]
理由を理解したいので、これを行うか、

[30:21 - 30:26]
ターミナルに戻るとこの

[30:24 - 30:28]
矢印が表示されます。これは24時間体制のようです。

[30:28 - 30:32]
このファイルをコピーして

[30:30 - 30:37]
矢印を配置します。この矢印を取得しました。同期を手伝って

[30:32 - 30:41]
ください。ルール

[30:37 - 30:45]
コストはいくらですか？どうすれば解決できますか？インポートが

[30:41 - 30:47]
間違っているようです。

[30:45 - 30:50]
コピーしてPAを追加します。これで

[30:47 - 30:53]
ページを更新すると、

[30:50 - 30:55]
このユーザーが正常に作成されたことがわかります。

[30:53 - 30:57]
ログアウトして

[30:55 - 30:59]
別のメールアドレスで再度ログインすると、

[30:57 - 31:01]
今度は新しいユーザーが

[30:59 - 31:03]
サインインしていることがわかります。テーブルに移動すると、新しいユーザーが作成されているので、

[31:01 - 31:05]
ユーザー

[31:03 - 31:08]
認証部分が機能しています。

[31:05 - 31:11]
コミットを実行してClarkをスーパーベースのユーザーテーブルに接続します。

[31:08 - 31:13]
次に

[31:11 - 31:17]
実装したい機能は、絵文字を

[31:13 - 31:22]
Emojiスーパーベースのストレージバケットにアップロードすることです。これで完了です。

[31:17 - 31:25]
次に、バックエンドの指示に基づいて2番目の要件を実装します。ステップバイステップで

[31:25 - 31:31]
同期してみましょう。

[31:28 - 31:34]
ルートファイルを追加して入力します。

[31:31 - 31:36]
いくつかの処理が実行されました。最初に、

[31:36 - 31:40]
画像をダウンロードしてサブベースにアップロードする機能を持つGeneral Emojiの新しいルートを作成し、

[31:38 - 31:43]
パブリックURLを取得します。次に、

[31:40 - 31:46]
スーパーベースの絵文字テーブルに新しい行を追加し

[31:43 - 31:48]
、絵文字で生成されたTSX

[31:46 - 31:51]
コンポーネントをこの最新のコードで更新します。[

[31:48 - 31:53]
承認]をクリックします。唯一気付いたのは、

[31:53 - 31:59]
以前追加したプレフィックスが削除されていることです。

[31:56 - 32:02]
プロンプトの絵文字にプレフィックスを戻して[保存]をクリックします。

[31:59 - 32:06]
新しいものを追加して生成すると、

[32:02 - 32:08]
矢印がいくつか表示されます。

[32:06 - 32:10]
ターミナルに移動して

[32:08 - 32:13]
サーバー側の矢印をコピーしてチャットに貼り付けますが、

[32:10 - 32:14]
矢印は前回と同じです。

[32:13 - 32:17]
実際には、ここにあるスーパーベースのサービス行キーを使用する必要があります。

[32:17 - 32:22]
このキーは

[32:20 - 32:24]
すべての行レベルのセキュリティをバイパスできます。

[32:22 - 32:27]
このサービス行キーをここに追加します。

[32:24 - 32:29]
ページを更新して

[32:27 - 32:32]
新しい絵文字を生成しようとすると、ここには何も表示されませんが、

[32:29 - 32:35]
スーパースペースに移動すると、このファイルURLで

[32:32 - 32:37]
1つの絵文字ファイルが作成されていることがわかります。ストレージ絵文字に

[32:35 - 32:40]
移動すると、

[32:37 - 32:42]
正確な絵文字

[32:40 - 32:44]
ファイルがここにアップロードされていることがわかります。

[32:42 - 32:48]
この部分は機能しています。

[32:44 - 32:50]
別のコミットを実行して絵文字ファイルをスーパーベースにアップロードします。

[32:48 - 32:52]
これで、絵文字グレード

[32:50 - 32:54]
のすべての画像を表示して

[32:52 - 32:56]
、いいねインタラクションを表示する機能が2つ残ります。

[32:54 - 32:59]
ほぼ同じことを行います。EM

[32:59 - 33:06]
絵文字グレードのすべての画像を表示するための挿入要件を実装するのに役立ちます。

[33:03 - 33:10]
ステップごとに同期しましょう。まず、

[33:10 - 33:15]
スーパーベースからすべての絵文字データを取得するためのルートを作成し、次に絵文字

[33:12 - 33:18]
グレードのコンポーネントを更新し、

[33:15 - 33:20]
絵文字ジェネレーターとメインページを更新します。

[33:18 - 33:22]
受け入れてください。これで、

[33:22 - 33:30]
チャットにコピーして貼り付けることができる矢印が表示されます。ページを読み込んだ後にこの矢印が表示されます。

[33:26 - 33:33]
ルールのコストとその解決方法を見つけるのに役立ちます。

[33:30 - 33:36]
これは、

[33:33 - 33:39]
通常、安全上の目的で nextjs が

[33:36 - 33:42]
信頼できる URL からのみ画像を読み込む矢印です。そのため、

[33:39 - 33:47]
基本的に次の手順に進む必要があります

[33:42 - 33:50]
。  MJS を設定してこの部分を変更します。

[33:47 - 33:53]
もう一度試してみます。

[33:50 - 33:55]
テーブルに作成した画像が

[33:53 - 33:58]
実際にはここに表示されないようです。Composer

[33:55 - 34:03]
に戻って

[33:58 - 34:08]
Super Base Emojis テーブルで確認する必要があります。Emoji

[34:03 - 34:12]
エンティティが 1 つあることがわかります

[34:08 - 34:16]
が、UI には何も表示されません。

[34:12 - 34:19]
ルールのコストとは何か、

[34:16 - 34:21]
どうすれば解決できるのかを段階的に考えてみましょう。今回は

[34:21 - 34:27]
デバッグ用にコンソール ログをもう少し追加するだけです。今のところはそのまま受け入れて

[34:24 - 34:29]
更新します。今回は実際に

[34:27 - 34:31]
表示されるので問題ありません。もう一度生成してみます。

[34:29 - 34:33]
新しい画像が

[34:31 - 34:35]
作成され、ここに表示されます。Super

[34:33 - 34:37]
Base にアクセスすると新しい画像も

[34:35 - 34:40]
ここに表示されます。これは問題ありませんが、

[34:37 - 34:42]
いいねやダウンロード機能が何らかの理由で削除されていることに気付きました。これは

[34:40 - 34:44]
煩わしいです。

[34:42 - 34:46]
また、いいねの数も表示されず、

[34:46 - 34:52]
上部に奇妙なカウン​​ターがあります。Composer に移動して

[34:48 - 34:56]
確認すると、

[34:52 - 34:59]
動作しているように見えますが、いくつかの機能と UI が

[34:56 - 35:02]
調整されています。以下の点を修正するのを手伝ってください。

[34:59 - 35:06]
画像カードにマウスを移動すると、

[35:02 - 35:09]
2 つのアイコン ボタンが表示されます。

[35:06 - 35:12]
画像 1 をダウンロードして、画像の下部に「いいね！」用の

[35:09 - 35:16]
プロンプトを表示します。プロンプトは

[35:12 - 35:19]
左揃えで、絵文字テーブルから返された「いいね！」の数は

[35:16 - 35:21]
右揃えです。

[35:19 - 35:25]
合計数を削除します。

[35:21 - 35:28]
また、バックエンドとフロント エンドの

[35:25 - 35:31]
指示ファイルをここに追加して、

[35:28 - 35:33]
追加のコンテキストを設定し、すべてを受け入れます。これで

[35:31 - 35:36]
アプリがプロンプトと「いいね！」の数で更新され、マウスを

[35:36 - 35:39]
ホバーすると 2 つのボタンが

[35:37 - 35:43]
表示されます。これもコミットします。スーパー ベース

[35:39 - 35:45]
のすべての絵文字を表示する機能を追加します。

[35:43 - 35:47]
最後に、「いいね！」の

[35:45 - 35:52]
インタラクションを実装したかったので、

[35:47 - 35:54]
素晴らしいと思いました。最後のバックエンド関数「いいね！」インタラクションを実装するのを手伝ってください。

[35:54 - 35:58]
このバックエンド指示に基づいて、いい

[36:08 - 36:13]
ね！インタラクションの新しいルートを作成し、このエンドポイントを使用するように絵文字グレード コンポーネントを更新します。受け入れてページを更新します。Enter をクリックすると、ここで数値が増加しているのがわかります。

[36:10 - 36:15]
サブベースに移動すると、ここでも「いいね！」の

[36:13 - 36:17]
数が増えているのがわかります。唯一の

[36:15 - 36:20]
問題は、ユーザーが

[36:17 - 36:22]
同じ画像を複数回「いいね！」できることです。これは

[36:20 - 36:25]
望ましくないため、絵文字の後に

[36:22 - 36:29]
1 人のユーザーが 1 つの絵文字にしか「いいね！」できないというフィードバックを提供します。  「いいね！」

[36:29 - 36:37]
ボタンが

[36:33 - 36:42]
アクティブに切り替わるはずです。アクティブな「いいね！」ボタンをクリックすると、「

[36:37 - 36:43]
いいね！」の数が減ります。そのため、

[36:42 - 36:45]
実際には「

[36:43 - 36:47]
Emoji likes」という新しいテーブルを作成する必要があることがわかります。これは当然のことです。

[36:45 - 36:50]
次に、サブベースに移動して

[36:47 - 36:52]
新しい quy を作成して実行します。

[36:50 - 36:53]
ここで新しいテーブルが作成されます。

[36:52 - 36:57]
また、新しいサブベース関数を作成するように求められます。

[36:53 - 37:00]
これをコピーして、

[36:57 - 37:03]
この周りを囲みます。次に、「

[37:00 - 37:06]
すべて受け入れる」をクリックして Web アプリケーションに戻ります。「いいね！」を

[37:03 - 37:09]
クリックすると、

[37:06 - 37:12]
状態が追加されたことがわかります。「

[37:09 - 37:15]
Emoji likes」テーブルに移動すると、

[37:12 - 37:18]
ここでも更新されます。これらの

[37:15 - 37:19]
絵文字の 2 つが「いいね！」されると、ここに両方の​​レコードが追加されます。

[37:18 - 37:22]
ただし、「

[37:19 - 37:24]
いいね！」の数が正しく表示されないため、さらにフィードバックを提供する必要があります。

[37:24 - 37:29]
スーパー ベース フェイスでは絵文字の「いいね！」が正しく更新されていることがわかりますが、

[37:27 - 37:32]
絵文字のグレードでは「いいね！」の

[37:29 - 37:33]
数が正しく表示されません。「いいね！」を

[37:32 - 37:37]
クリックした後、数が消えてしまいました。

[37:33 - 37:40]
この問題を解決するには、段階的に同期しましょう。

[37:37 - 37:42]
問題は「いいね！」の処理にあるようです。「

[37:40 - 37:45]
いいね！」の処理に移動して、

[37:42 - 37:48]
この最新のコードをコピーして貼り付け、

[37:45 - 37:50]
古い これを保存してページを更新すると、

[37:50 - 37:56]
ここで数字が公開されていることがわかります。チェックを外すと、

[37:53 - 37:58]
何もありませんでした。もう一度チェックすると、

[37:56 - 38:00]
今度はより

[37:58 - 38:02]
具体的な動作に戻ります。より

[38:00 - 38:05]
具体的であるほど良いというわけではありません。問題は、

[38:02 - 38:07]
ページを読み込むといいねの数が

[38:05 - 38:09]
正しく表示されることですが、「いいね！」

[38:07 - 38:12]
ボタンをクリックすると、いいねの数が

[38:09 - 38:14]
消えてしまいます。これを修正するのを手伝ってください。

[38:12 - 38:17]
ステップバイステップで同期しましょう。これでもう少し情報が表示されますが、

[38:14 - 38:20]
ご覧のとおり、

[38:17 - 38:22]
通常は

[38:20 - 38:24]
Composer ではなくチャット UI でデバッグを行うことを好みます。Composer を

[38:22 - 38:27]
使用すると、

[38:24 - 38:29]
Composer のチャット履歴に

[38:27 - 38:31]
すべてのデバッグ情報が書き込まれます。

[38:35 - 38:40]
一方、チャットでは、変更をコピーして貼り付けると簡単にクリーンアップできます。

[38:37 - 38:42]
適切に表示されていることがわかります。各ユーザーはいい

[38:44 - 38:48]
ね！のみを実行でき、右下隅に数が表示されます。これで完璧です。最後に

[38:46 - 38:50]
追加する必要があるのは、何らかのタイムアウト

[38:48 - 38:53]
設定です。Verel 環境では、

[38:50 - 38:54]
デフォルトではタイムアウトが非常に短いため、

[38:54 - 38:59]
実際に

[38:56 - 39:00]
画像を作成するので、

[39:00 - 39:05]
絵文字を生成するなど、取得に時間のかかるエンドポイントの一部にこれを追加します。

[39:03 - 39:08]
これでアプリ全体が実行され、

[39:05 - 39:10]
実装された機能を追加できます。最後の

[39:08 - 39:13]
ステップでは、このアプリを公開します。Nextjs

[39:13 - 39:17]
アプリをデプロイする最も簡単な方法は verel を使用することです。Verel

[39:15 - 39:19]
でアカウントを作成し、GitHub にログインして

[39:17 - 39:21]
新しいプロジェクトを作成し、

[39:19 - 39:23]
最新のコードを GitHub にアップロードします。

[39:21 - 39:26]
この絵文字生成カーソルを選択します。rot

[39:26 - 39:30]
ディレクトリを絵文字メーカー

[39:28 - 39:32]
プロジェクト フォルダーに変更し、

[39:32 - 39:37]
env に保存するすべての環境変数も入力する必要があります。  Loco を

[39:35 - 39:38]
クリックして、デプロイをクリックします。これには少し

[39:37 - 39:40]
時間がかかります。通常は

[39:38 - 39:42]
何らかの矢印が表示されますが、これもカーソルを使って

[39:40 - 39:44]
デバッグします。

[39:42 - 39:46]
この矢印が表示されました。奇妙ですね。

[39:44 - 39:49]
レプリケーションをインストールしていないようです。そのため、

[39:46 - 39:51]
インストールしてパッケージに追加し、

[39:49 - 39:54]
もう一度プッシュします。これでさらにいくつかの

[39:51 - 39:57]
矢印が表示されます。最も簡単な方法は、すべてをコピーして貼り付け、

[39:59 - 40:03]
コードベース全体のコンテキストがあるカーソルチャットに貼り付けるだけです。宣言されているが使用されたことのないこの変数を次のように削除する必要があります。

[40:05 - 40:12]
次に、ユーザーのいいね！で、この行も削除して、リクエストが

[40:12 - 40:17]
実際には使用されなかったため、次のようになります。

[40:15 - 40:19]
次に、絵文字ジェネレーターで、

[40:17 - 40:21]
使用されたことのないこのインポートを削除します。

[40:21 - 40:29]
指示に基づいてすべてを更新し、新しいコミットを追加して

[40:24 - 40:31]
修正を追加し、使用されたインポートを削除します。

[40:29 - 40:34]
カーソルを使用すると、

[40:31 - 40:35]
メインブランチに新しいコミットを公開するたびに

[40:34 - 40:37]
自動的に再デプロイされるため、確認する

[40:37 - 40:39]
必要があるさまざまな矢印がますます増えるでしょう。ローカルホストで実行して

[40:39 - 40:43]
いるときはアプリケーションが動作するのにもかかわらず、デプロイすると

[40:41 - 40:45]
新しい矢印がたくさんあるのはなぜだろうと不思議に思うかもしれません。

[40:43 - 40:47]
これは主に

[40:45 - 40:49]
ローカル環境と本番環境の違いによるものです。Verでは

[40:49 - 40:53]
異なるNode.jsバージョンやファイル

[40:51 - 40:55]
アシスタンスが使用される可能性があります。良い点は、デバッグのプロセスが

[40:53 - 40:57]
ほぼ同じであることです。いつでも

[40:55 - 40:59]
戻って

[40:57 - 41:01]
Arrowコードをチャットに追加して

[40:59 - 41:03]
カーソルを表示できるので、コピー＆ペーストするか、「適用」をクリックして

[41:03 - 41:06]
すべてを受け入れ、「保存」をクリックしてコミットできます。

[41:05 - 41:08]
このプロセスを

[41:06 - 41:11]
数回繰り返します。よくある例としては、

[41:08 - 41:14]
矢印を入力する場合などがあります。Verselでは、任意のタイプで

[41:11 - 41:16]
はなく、非常に具体的なタイプを定義することが推奨されています。

[41:14 - 41:18]
これで部門が

[41:16 - 41:20]
成功しました。Vitをクリックすると、

[41:18 - 41:23]
このアプリに移動します。最初は

[41:20 - 41:25]
誰もログインしていないので、最初にログインします。すると、

[41:25 - 41:30]
先ほど作成したこのアプリに移動します。このアプリは4つの機能を持ち、

[41:28 - 41:32]
ユーザーは新しい絵文字を生成したり、いいね！

[41:30 - 41:33]
嫌い！画像をダウンロードしたりできます。これは、

[41:36 - 41:39]
フロントエンド、バックエンド、

[41:37 - 41:41]
認証、展開、カーソルを備えた実際の本番環境アプリケーションを構築する方法のエンドツーエンドのプロセスです。

[41:39 - 41:44]
ご覧のとおり、私はフロントエンド開発者ではありませんが、

[41:44 - 41:47]
わずか1時間足らずでこのようなアプリケーションを構築できました。

[41:47 - 41:51]
カーソルを使用する機会が増えるにつれて、共有したいヒントがたくさんあります。

[41:51 - 41:55]
今日お話しした内容をもっと深く知りたい方は、私の AI

[41:53 - 41:57]
Builder Club コミュニティに参加できます。このコミュニティでは、このビデオで紹介したすべての例について、

[41:55 - 41:59]
ステップバイステップの詳細なコード分析と

[41:57 - 42:01]
プロンプトを用意しています。

[42:01 - 42:05]
コードを直接コピーして貼り付け、

[42:03 - 42:07]
質問や課題を、現在発生している問題をすでに経験している可能性のある

[42:05 - 42:09]
他のすべての AI Builder のコミュニティで共有できます。

[42:11 - 42:14]
下の説明にあるリンクをクリックして、

[42:12 - 42:16]
今すぐコミュニティに参加できます。

[42:16 - 42:20]
このプロセスをさらに高速化できる他の種類のカーソル ヒントがある場合は、

[42:18 - 42:21]
以下にコメントしてお知らせください。夢のアプリの製品版アプリケーションを構築する

[42:21 - 42:25]
方法に関する新しい興味深い curs ヒントを引き続き共有していきます

[42:25 - 42:29]
ので、最新情報を入手したい場合は「いいね」と「購読」をお願いします。

[42:27 - 42:32]
ありがとうございます。また

[42:29 - 42:32]
次回お会いしましょう。

## コメント

### 1. @AIJasonZ (👍 8)
Join my community club for more cursor tips!: https://2ly.link/1z94G :)

> **@75M** (👍 2): @@AIJasonZ Cool! Do we need any paid plan to follow this project step by step?

> **@scrapycholo2659** (👍 0): So where's ya million dollar funding 😂😂😂

> **@amandamate9117** (👍 0): now its time to utilize the new o1-mini or o1-preview and make some crazy projects.

> **@Akira71** (👍 0): Hmm, the link seems to be down for me. Any chance to check this out? Love to see what the community is about.

### 2. @seregamozetmnoga1700 (👍 67)
“Without any programming knowledge” - that’s the only phrase in the entire video I understood.

> **@isko4173** (👍 1): 😂😂

> **@chusanchusi7518** (👍 0): 😆

### 3. @MK-jn9uu (👍 67)
Seriously, one of few people online that knows wtf they’re talking about ❤ thank you

> **@amotriuc** (👍 1): on average a developer writes 100 lines per day. Much more time is spent on thinking and figuring what to do and how than writing the code. So not sure how AI can replace that yet...

> **@BenStuu** (👍 0): @@amotriuc Even in this video, AI is doing the vast majority of the thinking for him.

> **@amotriuc** (👍 1): @ The most thinking that you have to do in dev job is not even present in this example.

### 4. @lkd982 (👍 8)
You are doing a wonderful service for the community who like me are self-taught, self-doubting, proficient but not very good even after many years of effort, adhd, and wandering focus, who just need all the MISSING BITS that you provide, respeck!!! When it comes to the Supabase schema you make it seem as though a person actually needs to think fo themself, but you could just ask cursor for the appropriate schema!

> **@nikolaiownz** (👍 1): fellow ADHD'er here - ive been doing some minor programming in the late 90s (mIRC scripting haha) and ive been a machinist and i owned a machine shop where i always wanted to make some programs to help us out - AI programming with cursor is an insane good tool - it gets me a long way and i can make stuff myself. its not easy and the problem solving is still there but thats what i like about it. i am deep into this "look a squirrel hole"

### 5. @ruiqiliu1966 (👍 3)
谢谢，系统性地帮助新人入门。举例来说，其他youtuber是没有讲NPX是什么的，那就成为了学习过程中的噪音。同样还有“我们只需要关注app的子页面”等。这种视角的讲解方式对不懂编程的人太重要了，是目前看到最好的讲解视频。

### 6. @nimblename (👍 14)
This is the best tutorial I’ve watched on cursor based development! Thank you sir. Lots of helpful tips along the way (ie when to use composer vs chat, using product requirements documentation for the AI etc). I got a little lost during the database setup so I’ll need to watch some more to get up to speed. 

Would love a beginner setup tutorial for GitHub! And process for commit/rolling back etc

### 7. @powerofashish215 (👍 5)
Your content is always so insightful, thorough, and professional. Been watching your videos for a while and just want to say thank you for your insights to those wanting to learn!!!

### 8. @szihai (👍 128)
I started to use Cursor a couple weeks ago. I can say if you know what you are doing, yes you can get what you want fairly quickly. But if you soly rely on Cursor and Claude to design, implement and debug your code, it's gonna take way longer.

> **@AIJasonZ** (👍 31): Yea I think you need basic understanding of web dev for sure, to know how to prompt it effectively;

That’s why want to cover the workflow and how to do certain parts like auth & backend :)

> **@PubgSpeed-wl8yo** (👍 19): @@AIJasonZ I've been creating websites using website builders for 12 years. What he showed me was a very dense forest in which you don’t know where to go. And for a simple user this is equivalent to higher mathematics. So this is a crutch that can only be used by those who do serious programming.

> **@softwear4u-twt** (👍 6): @@szihai I'd say this is the case for any AI

> **@spforward918** (👍 2): okay sherlock

> **@camilovilla8434** (👍 0): For debugging nowadays using the latest model from OpenAI o1 is incredible. It will save you so much time

### 9. @sammykins7778 (👍 19)
reaaly wanted this to work as a non developer. Tried making my own app (three times!)  but Cursor AI gave different answers the more questions it was given and couldn't fix my issues. So developer jobs are safe.  lolz!

### 10. @harryzachariou1 (👍 28)
Great video! I'm a full stack javascript developer and I created my first macOS swift app using Cursor AI and Sonnet, what a fantastic IDE it is!

> **@The-Sentinel** (👍 0): did you still need a Mac device to compile the package? is there a way around this?

> **@harryzachariou1** (👍 0): @@The-Sentinel still have to use a Mac

> **@aduhaneh1057** (👍 0): @@The-Sentinel yes, but if you don't have mac you could try and use a different stack instead of swift

> **@The-Sentinel** (👍 0): What stacks out there don’t require a Mac to compile and deploy?

> **@JO-cw7ju** (👍 0): @@The-Sentinel Do you use premium Sonnet ??

### 11. @bigacres (👍 5)
This is the quickstart into this new stuff I needed. Thank you Jason your videos are always good and cutting edge.

### 12. @nsdalton (👍 12)
You can also put your frontend instructions into a .cursorrules file at the root of the project. Make sure cursor is using the file by going to cursor settings and checking in the general tab.

> **@fractalarbitrage** (👍 1): Front and back mixed or seperate like video?

### 13. @lu3bw (👍 1)
Jason, this is actually the best explanation for tech but non coding specimens like myself. THANK YOU!

### 14. @InternetStranger10101 (👍 1)
Thanks! Huge help

### 15. @UmutUcler (👍 0)
Wow, just wow! Incredible to see a real example from idea to production. Fantastic video my good sir

### 16. @unclesam007 (👍 4)
30:58 you thought we didnt notice but we did 😂 great vid btw

### 17. @thePocketWatch45 (👍 0)
this video just changed my life...keep them comin

### 18. @WilliamFordington (👍 22)
Imagine thinking that someone with no coding experience could understand this 💀💀

### 19. @martinsherry (👍 0)
i am six minutes in and ive learned more in six minutes here than the six hours i have spent watching other yt’ers on the very same topic. great video.

### 20. @phillonc (👍 0)
This is on point, I've been searching for a video that breaks things down logically.  Thank you

