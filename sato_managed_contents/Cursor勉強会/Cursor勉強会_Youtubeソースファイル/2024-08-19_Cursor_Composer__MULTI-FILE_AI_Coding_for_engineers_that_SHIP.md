# Cursor Composer: MULTI-FILE AI Coding for engineers that SHIP

**チャンネル:** IndyDevDan
**公開日:** 2024-08-19
**URL:** https://www.youtube.com/watch?v=V9_RzjqCXP8

## 説明

Cursor Composer gives you INCREDIBLE Multi-File AI Coding Abilities

AI Coding Devlog
https://youtu.be/1IK69XZZegU

Cursor Copilot++ (Cursor Tab)
https://youtu.be/Smklr44N8QU

Start AI Coding
https://www.cursor.com/

Discover how Cursor's groundbreaking Composer feature is revolutionizing AI coding and software development. In this video, we dive deep into the power of multi-file editing and show you how to leverage this game-changing tool to boost your productivity.

🚀 Witness the future of coding as we build a simple prompt editing tool using Cursor's Composer, demonstrating its incredible capabilities across multiple files and components.

🔥 Key highlights:
- Multi-file editing with AI assistance
- Real-time code generation and refactoring
- Seamless integration with existing codebases
- Comparison with other AI coding tools like Aider
- Comparison between the new chatgpt-4o-latest model to claude-3.5-sonnet

🛠️ We'll walk you through:
- Enabling and using the Composer feature
- Creating and modifying Vue.js/Nuxt components
- Implementing styling changes across multiple files
- Resolving errors and debugging with AI assistance

💡 Learn why Cursor's Composer and Aider are leading the pack in AI coding tools, and how they can help you write code faster and more efficiently than ever before.

Whether you're a seasoned developer or just getting started with AI-assisted coding, this video will show you how to harness the power of Cursor's Composer to take your productivity to the next level.

📖 Chapters
00:00 Cursor Composer
00:50 Enable and Setup Cursor Composer
03:05 Multi-file editing
10:05 Move up the stack - focus on what not how
19:55 Big Takeaways for AI Coding Tools

#aicoding #programming #aiprogramming

## 字幕

[00:00 - 00:06]
AIコーディングはソフトウェアの

[00:03 - 00:10]
作成方法を変えており、その先頭に立っているのが1つのチームとたった1人の

[00:06 - 00:14]
20xエンジニアです。

[00:10 - 00:17]
私とカーソルは、

[00:14 - 00:19]
AIコーディングで大きな進歩を遂げたチームです。

[00:17 - 00:23]
しかし、彼らが

[00:19 - 00:25]
開発した

[00:23 - 00:28]
他のすべてをはるかに上回る機能が1つあります。PSと比較して、この

[00:25 - 00:30]
ビデオでは、この機能が何であるか、

[00:28 - 00:31]
そしてなぜそれが重要であるかを紹介します。

[00:30 - 00:34]
この機能は非常に新しいため、

[00:31 - 00:36]
まだ正式なドキュメントはありませんが、

[00:34 - 00:38]
変更ログにアクセスすれば、

[00:36 - 00:41]
この機能が何であるかを正確に確認できます。これは、

[00:38 - 00:44]
カーソルの真新しい

[00:41 - 00:47]
コンポーザー機能に他なりません。ここでの重要なポイントは、

[00:44 - 00:51]
これが新しい実験的なマルチ

[00:47 - 00:51]
ファイル編集機能であるということです。詳しく見ていきましょう。

[00:55 - 01:00]
カーソルコンポーザー機能を有効にするには、

[00:58 - 01:02]
設定に移動して

[01:00 - 01:04]
ベータフラグに移動し、コンポーザーが有効になっていることを確認します。

[01:04 - 01:09]
そのコマンドを実行したら、小さな

[01:06 - 01:12]
コンポーザーウィンドウをポップアップ表示し、コマンドShiftキーを押しながら

[01:09 - 01:14]
全画面バージョンをポップアップ表示します。さあ、

[01:12 - 01:16]
変更を記述して、

[01:14 - 01:17]
この入力変数とこの出力変数を変換してみましょう。

[01:16 - 01:21]
このコンポーネントで確認できます。

[01:17 - 01:23]
これに

[01:21 - 01:26]
実際の入力フィールドと実際の出力フィールドを追加してみましょう。

[01:23 - 01:28]
カーソル コンポーザーを開いて、

[01:26 - 01:33]
新しいチャット GPT

[01:28 - 01:37]
4 の最新モデルを試してみましょう。プロンプトを入力して、入力を

[01:33 - 01:41]
実際の入力フィールドに変換し、入力を

[01:37 - 01:44]
濃い青と白のテキストにします。Enter キーを押すと

[01:41 - 01:46]
、一度に 1 つのファイルにフォーカスが当てられているのがわかります。

[01:44 - 01:50]
現在は Liquid Prompt しかありません

[01:46 - 01:53]
。 コンテキストのviewを

[01:50 - 01:55]
見ると、変更が書き込まれているのが分かります。

[01:53 - 01:58]
これらの変更を受け入れてみましょう。

[01:55 - 02:00]
ここに入力ping how are you があります。

[01:58 - 02:02]
これが入力フィールドに更新され、

[02:00 - 02:04]
ラベルができました。

[02:02 - 02:07]
出力フィールドにも同様の更新を加えてみましょう。

[02:04 - 02:08]
違いは、

[02:07 - 02:11]
この出力フィールドを、

[02:11 - 02:15]
別のコンポーネントで使用しているマークダウンコンポーネントに変換することです。H

[02:13 - 02:18]
コマンド

[02:15 - 02:21]
で新しいチャットを開始し、コンテキストに別のファイルを追加します。

[02:18 - 02:24]
探している変更も

[02:21 - 02:26]
このプロンプトエディターにあります。

[02:24 - 02:31]
参照して、

[02:26 - 02:36]
出力をDCコンポーネントに変換し、

[02:31 - 02:36]
レンダリングします。プロンプト出力が

[02:40 - 02:44]
ここにあります。これでこのコンポーネントが取得されました。「

[02:44 - 02:48]
すべて受け入れる」をクリックして、

[02:45 - 02:51]
これらの変更を確認します。これで、

[02:48 - 02:52]
このMDCコンポーネントにレンダリングされます。素晴らしいですね。これで、

[02:52 - 02:56]
この機能が提供するマルチファイル編集機能のいくつかをテストしてみましょう。これが

[02:56 - 02:59]
ポイントです。これは既にカーソルを使用して実行できます。

[02:59 - 03:03]
これらの変更はすべて、 エンドライン

[03:01 - 03:06]
選択プロンプト

[03:03 - 03:10]
この新しいコンポーザーエディターの利点と価値は、

[03:06 - 03:10]
複数の

[03:10 - 03:16]
ファイルを書き込めることです。ここでは、

[03:14 - 03:21]
入力

[03:16 - 03:23]
フィールドを独自のLiquid Inputに移動し、

[03:21 - 03:29]
ディレクトリ

[03:23 - 03:30]
とコンポーネントを指定します。出力フィールドも同様です。

[03:30 - 03:33]
ここで実際に

[03:32 - 03:36]
コンポーネントを生成します。Liquid

[03:33 - 03:39]
InputとLiquid Outputがあり、これらの

[03:36 - 03:40]
ファイルが作成され、

[03:39 - 03:42]
参照されるようになりました。

[03:40 - 03:44]
すべて受け入れてください。

[03:42 - 03:45]
ここでエラーが発生していますが、手動では何もしません。

[03:45 - 03:49]
これをハイライト表示します。コンポーザーに戻り、

[03:47 - 03:52]
これを貼り付けて

[03:49 - 03:53]
エラーを解決します。次に、

[03:52 - 03:56]
新しいファイルを追加します。

[03:53 - 03:58]
入力と出力を追加して、実行します。

[03:58 - 04:02]
チャットGP 40の機能をまだテスト中です。私の

[04:00 - 04:05]
見るところ、非常に優れたモデルのように見えますが、

[04:05 - 04:10]
Sonic 3.5のようなモデルほど一貫性がなく、堅牢ではありません。

[04:07 - 04:13]
そのため、このモデルを

[04:10 - 04:15]
値と入力の両方に分割します。 これを

[04:15 - 04:19]
受け入れて、更新してみましょう。

[04:17 - 04:21]
素晴らしいですね。レンダリングが

[04:19 - 04:23]
復元され、そこに書き込まれているようです。これは

[04:21 - 04:25]
カーソルコンポーザー機能を使用して

[04:23 - 04:27]
複数のコンポーネントを同時に書き込む例です。

[04:25 - 04:29]
これは非常にクールです。

[04:29 - 04:33]
さらに進めて、

[04:31 - 04:35]
これらのコンポーネントの両方のスタイルを改善したいと思います。

[04:33 - 04:37]
カーソルコンポーザーのオーバーレイ機能を使用します。

[04:37 - 04:41]
ここではコマンド+シフト+Iを使用します。

[04:39 - 04:42]
新しいコンポーザーボタンがあります。

[04:41 - 04:44]
これをクリックして、

[04:44 - 04:49]
これらの変更に必要なコンテキストを追加し始めます。Liquid

[04:46 - 04:52]
Promptの入力

[04:49 - 04:54]
と出力を追加します。これでこれらのファイルがコンテキスト

[04:52 - 04:56]
に追加されました。これで、

[04:56 - 05:02]
変更を加えるために必要なプロンプトを表示できます。J GPTを最新のComposerでテストし続けることができます。もう

[05:02 - 05:05]
1つファイルを追加します。これは

[05:05 - 05:08]
以前使用した参照ファイルです。このファイルから

[05:07 - 05:10]
スタイルの一部を取得したいと思います。

[05:08 - 05:12]
では、

[05:10 - 05:14]
プロンプトエディタも追加します。これは

[05:12 - 05:17]
既存のコードベースです。

[05:14 - 05:21]
サイズを確認してみましょう。

[05:17 - 05:23]
ここに来て、regxを検索すると、

[05:21 - 05:25]
以前にも使っていたものがあるので、

[05:23 - 05:29]
合計で約22,000行のコードがあります。Dash

[05:29 - 05:35]
CをGrabすると、

[05:31 - 05:37]
TTSとviewファイルで約151ファイルあることがわかります。

[05:35 - 05:39]
これは

[05:37 - 05:40]
フルスタックのコードベースで、Nu

[05:39 - 05:43]
アプリケーションです。これは本番環境で稼働している

[05:40 - 05:44]
ライブコードで、

[05:43 - 05:48]
AIコーディングツールを使ってマルチファイル編集を行っています。TypeScript

[05:44 - 05:50]
とVJで約151ファイル、

[05:48 - 05:52]
そして約22,000行のコードです。これは

[05:50 - 05:54]
小規模な本番環境のコードベースです。

[05:56 - 06:01]
中堅・シニアレベルの方なら、もっと大きなコードベースを見たことがあると思いますが、

[05:57 - 06:02]
150ファイルというのはかなり大きなサイズです。

[06:01 - 06:04]
もちろん、

[06:02 - 06:06]
製品が成長するにつれてサイズは大きくなりますが、

[06:04 - 06:08]
先に進みましょう。

[06:06 - 06:10]
Composerメニューに戻りましょう。ファイル参照が消えてしまったようです

[06:08 - 06:11]
ので、

[06:10 - 06:14]
これらを追加します。入力、

[06:11 - 06:18]
出力、Prompt Editorがあります。

[06:14 - 06:23]
ここでは

[06:18 - 06:26]
Liquid InputとLiquid Outputのスタイルを

[06:23 - 06:28]
Prompt

[06:26 - 06:30]
Editorのミラーリングに設定します。このままにしておきます。

[06:30 - 06:35]
アシスタントにこれらの4つのファイルを参照するように指示し、

[06:33 - 06:38]
Prompt Editorからこれらのスタイルを取得して

[06:35 - 06:40]
Liquid InputとLiquid Outputに適用します。

[06:38 - 06:42]
これは非常に便利です。

[06:42 - 06:46]
少し開いてみましょう。

[06:44 - 06:48]
右側のパネルでは、変更内容が順に

[06:48 - 06:53]
説明されています。

[06:50 - 06:55]
ファイルをクリックすると、

[06:53 - 06:57]
それぞれのファイルに必要な変更が表示されます。

[06:55 - 06:59]
これは非常にわかりやすく

[06:57 - 07:00]
、

[07:00 - 07:05]
複数のファイルにわたる変更内容が正確に表示されます。「

[07:03 - 07:07]
すべて承認」をクリックすると、いくつかのスタイルが適用されているのがわかります。

[07:05 - 07:09]
最適なスタイルではありませんが、

[07:09 - 07:13]
探していたものとは少し違うかもしれません。 これで

[07:11 - 07:17]
ほぼ完成です。

[07:13 - 07:20]
入力セクションから背景を削除し、

[07:17 - 07:22]
入力コロンとラベルを削除します。

[07:22 - 07:26]
ここでもう少し調整を加えます。まだ

[07:24 - 07:28]
私の希望どおりではないので、

[07:26 - 07:29]
求めている結果を得るために調整を続けます。

[07:28 - 07:31]
ご覧のとおり、この

[07:29 - 07:33]
イテレーションではLiquid Inputのみが更新されています。「

[07:31 - 07:35]
Accept All」をクリックすると、

[07:33 - 07:37]
UIでそれが削除されたことがわかります。

[07:37 - 07:44]
ボタンの背景も削除されたようです。背景を

[07:40 - 07:44]
入力HTML要素に戻します。これで完了です。

[07:47 - 07:50]
背景が

[07:49 - 07:52]
元に戻り、見栄えが良くなりました。次に、

[07:50 - 07:54]
これらの項目を中央揃えにします。少しぎこちないです

[07:52 - 07:56]
ね。

[07:54 - 07:57]
これを閉じるには、Escキーを押します。これで

[07:56 - 08:00]
通常の

[07:57 - 08:02]
IDE編集モードに戻りました。素晴らしいですね。Liquid

[08:00 - 08:04]
Promptに移動できます。次に、

[08:04 - 08:09]
Prompt Editorで参照できるものを追加します。

[08:09 - 08:12]
すべてのコンテキストは必要ないので、ここで新しいチャットを開始します。

[08:11 - 08:15]
Liquidプロンプトに行き

[08:12 - 08:18]
、

[08:15 - 08:21]
垂直方向と水平方向を中央揃えにします。それでは

[08:18 - 08:24]
プロンプトに従って作業を進めましょう。

[08:21 - 08:26]
よさそうです。「

[08:24 - 08:28]
Accept」をクリックします。これで

[08:26 - 08:31]
左から右に移動しているのがわかります。

[08:28 - 08:33]
もちろん、これを修正するには

[08:31 - 08:36]
Flex callを使用します。文字通り「Flex

[08:33 - 08:38]
call」と入力して、前の会話のコンテキストで変更を加えます。「

[08:38 - 08:42]
Accept」をクリックすると、これで正しい結果が得られます。

[08:40 - 08:47]
これは従来のスタイル設定、

[08:42 - 08:51]
従来のCSSライティングと同じです。Liquid入力の幅を

[08:51 - 08:54]
入力

[08:52 - 08:55]
フィールドと同じにします。これはテストとして行っているので、

[08:54 - 08:56]
実際にうまくいくかどうかはわかりません。

[08:55 - 08:59]
ここで期待しているのは、

[08:59 - 09:04]
Liquid入力と出力内のコンテンツが自動的に

[09:02 - 09:05]
コンテキストに追加され、この変更が行われることです。

[09:04 - 09:07]
それでは先に進み、うまくいくかどうか確認してみましょう。

[09:05 - 09:08]
これは実際にはテストなので、うまくいくかどうかは

[09:07 - 09:09]
わかりません。先に進ん

[09:08 - 09:11]
で試してみましょう。はい、これはうまく

[09:09 - 09:14]
いきません。コンテキストにあるファイルだけを参照して、それを変更している

[09:14 - 09:17]
だけです。 トップレベルなので、これで問題ありません。

[09:15 - 09:20]
ここで「

[09:17 - 09:22]
すべて拒否」をクリックして、これらのファイルをコンテキストに追加します。

[09:22 - 09:26]
実行後、

[09:24 - 09:28]
これらを追加して、

[09:26 - 09:30]
前のメッセージを探します。

[09:28 - 09:31]
これをここに挿入します。

[09:30 - 09:32]
このメッセージをもう一度貼り付けて、

[09:32 - 09:38]
ファイルのコンテキストでどのように機能するかを確認します。

[09:35 - 09:40]
入力と出力を編集しているのがわかります。Liquid

[09:40 - 09:44]
Promptも編集しています。これは必要なのかどうかわかりませんが、

[09:43 - 09:47]
先に進めましょう。

[09:44 - 09:49]
入力と出力の幅を見てみ

[09:47 - 09:50]
ましょう。これを最大500ピクセルに設定しています。これで

[09:49 - 09:52]
問題ありません。

[09:50 - 09:56]
このまま受け入れます。これでおおよそ

[09:52 - 09:58]
一致する幅が得られるはずです。これで

[09:56 - 10:01]
問題ありません。

[09:58 - 10:04]
もう1つだけ設定します。Gap、またはGap nineです。

[10:04 - 10:09]
これらのアイテムにギャップを追加するだけです。

[10:07 - 10:09]
受け入れると、完了です。

[10:09 - 10:12]
これで

[10:09 - 10:14]
[Music]が

[10:12 - 10:15]
できました。 いいですね。

[10:14 - 10:18]
いくつか変更を加えています。これは

[10:15 - 10:19]
フロントエンドの小さな変更ですが、

[10:18 - 10:21]
とても便利です。

[10:19 - 10:23]
ここで行っているのは、スタックを上位に移動することです。

[10:23 - 10:27]
もう手動で記述する必要はありません。より

[10:25 - 10:28]
高いレベルで実行したいことを要求し、

[10:27 - 10:31]
LLMに

[10:28 - 10:33]
モデル化させ、AIを搭載したIDEカーソルに任せます。

[10:31 - 10:35]
これらのツール

[10:33 - 10:37]
に大変な作業を任せています。Enter

[10:35 - 10:39]
キーを押したときに、

[10:37 - 10:40]
ここにあるプロンプトが実際に

[10:39 - 10:46]
実行されるようにします。Liquid PromptがEnterキーを押すと、これらのファイルのコンテキストが保持されます。Liquid

[10:46 - 10:54]
Promptが新しいプロンプトを実行し、Liquid

[10:50 - 10:57]
Promptまで実行して、make prompt

[10:54 - 11:00]
関数を実行します。簡単に言うと、

[10:57 - 11:02]
Liquid Promptファイルには、フックから出力されるmake prompt関数があります。

[11:02 - 11:07]
これは

[11:04 - 11:10]
プロンプトを実行し、結果を返して、

[11:11 - 11:16]
入力フィールドでEnterキーを押したときに必要なプロンプト出力に設定します。マウント

[11:13 - 11:18]
されたフックでこれを行う代わりに、

[11:16 - 11:20]
これらのコンポーネントに処理を任せたいのです。

[11:20 - 11:25]
これをもう一度開いて、これを実行してみましょう。gpg

[11:22 - 11:27]
40とcomposerがどのように

[11:25 - 11:30]
これを実行するかを見てみましょう。

[11:27 - 11:31]
入力フィールドを更新する方法がわかっています。

[11:30 - 11:36]
これは素晴らしいです。Enterキー

[11:31 - 11:39]
イベントが設定され、Liquid Prompt

[11:36 - 11:42]
に高レベルのメソッドが書き込まれています。

[11:39 - 11:44]
これで問題なさそうです。「

[11:42 - 11:48]
Accept All」をクリックします。「

[11:44 - 11:49]
Remove Handle Enter from Unmounted」を選択します。つまり、

[11:48 - 11:52]
この

[11:49 - 11:55]
イベントはUnmountedフックで実行しないように指定しています。これは

[11:52 - 11:58]
Mitedイベントから実行します。これで問題なさそうです。「

[11:55 - 12:02]
Accept Close」をクリックします。これで問題なさそうです。「

[12:02 - 12:07]
Ping How are you」と入力します。Enterキーを押します。

[12:04 - 12:09]
これで完了です。

[12:07 - 12:11]
コンテンツが表示されます。

[12:09 - 12:12]
ここでどのモデルを使用しているかはわかりませんが、先に

[12:11 - 12:14]
進んで、

[12:12 - 12:16]
入力フィールドを作成するための簡単なプロンプトを表示します。

[12:16 - 12:22]
ここでは小さなComposerウィンドウでこれを実行します。

[12:22 - 12:29]
コマンド「新規」を押して、

[12:25 - 12:34]
モデルを参照に移動して、

[12:29 - 12:34]
Liquid入力

[12:37 - 12:44]
フィールドの上に表示します。これでOKです。これを受け入れて閉じます。

[12:42 - 12:46]
先に進んで、モデルがどうなっているか見てみましょう。

[12:46 - 12:51]
ここでGB4 Miniが実行されていて、一番上に表示されます。

[12:48 - 12:52]
これで問題ありません。

[12:52 - 12:57]
もう一度、どのように見えるか見てみましょう。よし、

[12:54 - 12:59]
これでよしです。

[12:57 - 13:00]
ここでEnterを押すと結果が表示されます。

[12:59 - 13:04]
別の

[13:00 - 13:08]
プロンプトを入力します。5まで数えます。1、2、3、4、5。

[13:04 - 13:08]
とてもいいですね。10まで数えます。

[13:08 - 13:14]
そして、逆順に、そして

[13:12 - 13:16]
スキップ・イーブンズを入力します。これで、これが

[13:14 - 13:20]
実際のLLMであることがわかります。裏で実行されていますね。

[13:16 - 13:23]
スキップ3、いいですね、スキップ

[13:20 - 13:24]
N、いいですね。これで、これが

[13:23 - 13:26]
裏でモデルが実行中であることがわかります。それでは、

[13:26 - 13:30]
ここでもう少し操作してみましょう。この青色は好きではありません。Liquid

[13:30 - 13:34]
プロンプトエディターの背後にある考え方は、

[13:31 - 13:36]
このプロンプトエディターの表示と非表示を切り替えることです。

[13:34 - 13:38]
どこにいても、もちろんComposerを使います。Liquidの

[13:38 - 13:44]
入力ファイルに切り替えて、

[13:42 - 13:46]
ここで新しいメッセージを開始します。この便利な点は、

[13:44 - 13:48]
どんなファイルを使っていても、Focusが

[13:46 - 13:51]
自動的にそのファイルでコンテキストを開始することです。

[13:51 - 13:55]
背景色があります。もちろん、これを微調整できます。

[13:52 - 13:59]
背景色を更新し、

[13:55 - 14:04]
左の濃い青を右の赤に変えます。いやいや、

[13:59 - 14:06]
いやいや、右上の2つにしましょう。

[14:04 - 14:09]
変更が反映されるのがわかります。

[14:06 - 14:12]
完璧です。グラデーションもあります。さて、

[14:09 - 14:14]
今はこれでOKです。

[14:12 - 14:16]
それからここに戻って、

[14:14 - 14:19]
少し微調整をします。とにかく、とにかく

[14:16 - 14:22]
素早く作業を進めます。

[14:19 - 14:24]
モデルのDIPをPに変換すると、

[14:22 - 14:28]
この1行がハイライト表示されるはずです。素晴らしいですね。これでOKです。これで

[14:28 - 14:34]
フォントができました。素晴らしいです。

[14:31 - 14:36]
次はキーボード

[14:34 - 14:40]
イベントを要求します。ここではVIを使って、

[14:36 - 14:45]
キーストロークにスラッシュを使用します。Liquid

[14:40 - 14:51]
プロンプトエディターのdivの表示と非表示を切り替えるものだと思います。

[14:45 - 14:54]
そして、追加します。 変数の表示と非表示の参照です。

[14:51 - 14:56]
よし、これをそのままにしておきます。

[14:54 - 14:58]
これは単一のファイルの編集です。

[14:56 - 15:01]
先に進んで、これができるかどうか確認してみましょう。必要な

[14:58 - 15:03]
キー バインディングを正確に指定するのを忘れていた

[15:01 - 15:05]
ので、

[15:03 - 15:08]
後続のプロンプトで追加します。

[15:05 - 15:12]
ここで、しっかりとしたインポートが取得できました。

[15:08 - 15:14]
必要な変数と

[15:12 - 15:16]
キーストロークを取得しました。これは問題ありません。

[15:14 - 15:19]
かなり近いので、先に進んでこれを受け入れます。

[15:16 - 15:21]
次に、何が

[15:19 - 15:22]
得られるか確認してみましょう。更新してみましょう。ああ、

[15:21 - 15:26]
ここにバグがあります。

[15:22 - 15:29]
完全なエラーがあります。エラーを修正します。

[15:26 - 15:30]
コメント行が間違っています。よし、先に進んでこれを修正します。すばらしい。すばらしい。

[15:30 - 15:36]
デフォルトでは、プロンプト

[15:33 - 15:41]
エディターが表示されます。キー ストロークで false が設定されます。

[15:36 - 15:45]
コマンド + P で、

[15:41 - 15:47]
その変数の表示と非表示を切り替えることができます。Esc キーも保持しておけば、

[15:47 - 15:52]
ここにある他のファイルには影響しないはずです。よし、

[15:50 - 15:54]
よし。これはリストを受け入れることができると思います。確認してみましょう。先に

[15:52 - 15:57]
進んでこれを受け入れます。

[15:54 - 15:59]
これで、デフォルトで false が表示されます。

[15:57 - 16:01]
Command + P を押すと、もちろん

[15:59 - 16:04]
クラシックな印刷が出てきます。Onkey

[16:01 - 16:06]
stroke の

[16:04 - 16:08]
イベントをここに配置します。イベント

[16:06 - 16:10]
とキーボードイベントがあります。

[16:08 - 16:12]
これは

[16:10 - 16:13]
手動で行う必要があります。カーソル + Tab を使って、

[16:12 - 16:15]
これらの自動補完を実行します。これは

[16:15 - 16:19]
カーソルチームの素晴らしい機能です。

[16:17 - 16:21]
それでは試してみましょう。

[16:19 - 16:23]
これらの

[16:21 - 16:24]
キーの組み合わせは Onkeystroke では機能していないようです。

[16:23 - 16:27]
サポートされていないため、

[16:24 - 16:29]
個々のボタンの押下のみを処理します。問題ありません。

[16:29 - 16:32]
ここで、表示と非表示を追加します。

[16:30 - 16:34]
これは

[16:32 - 16:36]
実際には高速です。これで良いです。これで表示と非表示ができました。

[16:34 - 16:38]
これで、この

[16:36 - 16:40]
小さくて非常にシンプルなプロンプトエディターができました。

[16:38 - 16:42]
理想的には、

[16:40 - 16:44]
部分を独自のコンポーネントに変換して、

[16:42 - 16:47]
好きな場所に配置できます。

[16:44 - 16:50]
このコンテンツ

[16:47 - 16:52]
と関連するスクリプトを独自の

[16:50 - 16:54]
コンポーネントに移動しましょう。Liquid の入出力と同じように、先に

[16:52 - 16:56]
進んで

[16:54 - 16:58]
移動しましょう。 このすべてのコンテンツを

[16:56 - 17:01]
独自のコンポーネントに移動します。

[16:58 - 17:02]
これには大きなエディターを使用して、

[17:01 - 17:05]
新しいコンポーザーを起動し、

[17:05 - 17:11]
Liquid Prompt をロードして、

[17:08 - 17:14]
Liquid Prompt

[17:11 - 17:18]
エディターを何と呼ぶか​​、Liquid Prompt エディター

[17:14 - 17:21]
と関連するすべての状態を独自の

[17:18 - 17:24]
コンポーネントに移動します。これを Liquid

[17:21 - 17:26]
Prompt エディターと呼びます。 ビュー、わかりました。では、

[17:24 - 17:29]
すべてを独自のコンポーネントに移動するように要求します。

[17:31 - 17:37]
必要なインポートがすべて実行され、トップレベルの Liquid Prompt も更新されます。

[17:37 - 17:43]
前と同様に、キーストローク イベントが失われているようですので、キー

[17:46 - 17:53]
ストロークを

[17:49 - 17:53]
コンポーネントに移動することを忘れないでください。それをフォローアップとして送信します。

[17:55 - 18:00]
完璧です。これで、

[17:58 - 18:01]
前のコンポーネントで残っているのは、以前

[18:00 - 18:04]
あったトップレベルの項目、

[18:01 - 18:06]
いくつかの未使用の変数、いくつ

[18:04 - 18:08]
かのフックなどだけです。先に進み、

[18:06 - 18:10]
すべての変更を受け入れます。

[18:08 - 18:12]
ここに最初の変更があります。これは、新しい

[18:10 - 18:14]
Liquid Prompt エディター ファイルです。このファイル全体が作成され、

[18:14 - 18:18]
以前の Liquid Prompt があります。  viwファイルには、

[18:16 - 18:20]
いくつかの

[18:18 - 18:22]
追加コンポーネントとエディター

[18:20 - 18:24]
自体が含まれているので、受け入れます。エラーが発生しているようですが、これは

[18:22 - 18:26]
まったく問題ありません。

[18:24 - 18:29]
これをすべてコピーします。

[18:26 - 18:30]
不明なキーワードがあります。コンポジットを

[18:29 - 18:32]
再度開き、新しいウィンドウを開始します。

[18:30 - 18:36]
ここに新しいファイルを追加して、

[18:32 - 18:36]
この問題を解決します。

[18:39 - 18:44]
不要な変数があります。unsubを

[18:41 - 18:47]
削除します。よし、

[18:44 - 18:49]
liquid promptの変更も問題ないことを確認しましょう。

[18:49 - 18:56]
このコンポーザブルはまったく必要ありません。use

[18:52 - 18:58]
prompt editor

[18:56 - 19:00]
importの次の部分を削除します。いいえ、これは

[18:58 - 19:02]
自動的にインポートされるので、

[19:00 - 19:05]
削除するように要求します。それは

[19:02 - 19:07]
必要ありません。さて、

[19:05 - 19:08]
他のコードを削除しようとしているので、

[19:07 - 19:11]
すべて削除したいと思われています。これはある意味

[19:08 - 19:13]
賢すぎるので、

[19:11 - 19:16]
システムプロンプトで簡単に解決できます。システムプロンプトで、

[19:13 - 19:18]
nを使用しています、ええと、Nでは

[19:16 - 19:21]
すべてのフックと

[19:18 - 19:23]
コンポーネントが自動的にインポートされます、これも

[19:21 - 19:25]
必要ありません 任意のビューのインポートは、カーソル設定

[19:23 - 19:27]
のシステムプロンプトメッセージから行うことができます。

[19:27 - 19:31]
これらの変更を元に戻すように指示します。「元に戻す」は

[19:31 - 19:38]
インポートしないで、ハンドル入力

[19:35 - 19:38]
機能はそのままにします。

[19:43 - 19:46]
これで問題ありません。「

[19:45 - 19:49]
すべて受け入れる」をクリックして、

[19:46 - 19:52]
この変更を元に戻します。それでは先に

[19:49 - 19:54]
進み、

[19:52 - 19:57]
すべてがうまく動作することを確認しましょう。これは

[19:54 - 19:57]
かなりクールですよね。

[19:59 - 20:03]
いくつかの問題とちょっとしたトラブルがあります。

[20:01 - 20:06]
個人的には、Composer

[20:03 - 20:09]
の機能がどこにあるかを正確に把握しようとしていますが、

[20:09 - 20:13]
ここで使用するモデルはすべて動作が

[20:11 - 20:16]
異なります。AER、

[20:13 - 20:18]
Continue、その他のAIコーディング

[20:16 - 20:20]
ツールを使用している場合は、モデルのパフォーマンスを実際に確認して試してみる必要があります。モデルのパフォーマンスは

[20:22 - 20:26]
ツールごとに異なります。

[20:24 - 20:28]
これらのツールを開発しているエンジニアは

[20:26 - 20:30]
プロンプトを作成しており、

[20:30 - 20:35]
プロンプトはモデルごとに異なる影響を与えます。chbt

[20:32 - 20:37]
40は非常に新しく、最先端のツールです。Claw

[20:37 - 20:41]
3.5 Sonetを使い続けることをお勧めします。

[20:39 - 20:42]
これらのモデルを使ったコーディングでは、

[20:41 - 20:44]
ベンチマークを見るだけでは

[20:42 - 20:46]
パフォーマンスを把握できません。

[20:44 - 20:47]
これは

[20:46 - 20:49]
以前から言っていることですが、実際にAIを使ってコードを書いている人なら

[20:47 - 20:52]
ご存知でしょう。Claw

[20:49 - 20:55]
3.5 SonetはAIコーディングの王者であり、

[20:52 - 20:57]
コーディングツールとの統合性も優れています。GPG

[20:55 - 20:59]
40を試してみましたが、

[20:57 - 21:02]
Sonetは

[20:59 - 21:04]
Cat gbt 40が

[21:02 - 21:06]
犯したようなミスを犯さなかったでしょう。これは

[21:04 - 21:08]
CursorチームのComposer機能とは全く関係ありません。

[21:06 - 21:10]
これは本当に素晴らしい機能です。この

[21:08 - 21:12]
新しいComposer機能により、

[21:10 - 21:15]
Cursor IDE内でマルチファイル編集が可能になりました。これにより、

[21:15 - 21:19]
シンプルなプロンプト

[21:17 - 21:22]
編集ツールをかなり迅速に構築できました。驚異的な生産性向上を実現したいなら、

[21:23 - 21:27]
これらの機能を実現する素晴らしいAIコーディングツールを使う必要があります。Cursor

[21:27 - 21:30]
とAERについてお話します。

[21:28 - 21:33]
これらはAIコーディングの分野をリードする2つの

[21:30 - 21:37]
ツールです。コード作成はかつてない

[21:33 - 21:38]
ほど安価で高速になります。私はまだ

[21:37 - 21:40]
使い始めたばかりです。 このコンポーザー

[21:38 - 21:42]
機能は先週発見して、

[21:40 - 21:44]
ずっと使い込んできました。正直言って、

[21:42 - 21:46]
この機能を使う前は

[21:44 - 21:48]
カーソルから離れようとしていました。マルチファイル

[21:46 - 21:51]
編集はAIコーディングにとって非常に重要な機能です。

[21:51 - 21:56]
実際にコードを書くのと同じように、

[21:53 - 21:57]
5、10、時には20個のファイルを同時に記述できます。

[21:56 - 21:59]
これは

[21:57 - 22:01]
特に、

[22:01 - 22:06]
大規模なコードベースに変更を加える中堅シニアレベルのエンジニアにとって非常に強力です。これは

[22:03 - 22:07]
150個のファイルしかない小さなコードベースです

[22:06 - 22:09]
が、

[22:07 - 22:11]
実際の製品コードベースで使用できるツールです。

[22:09 - 22:14]
カーソルの新しいコンポーザー機能は、

[22:11 - 22:16]
マルチファイル編集を本当に実現します。

[22:14 - 22:19]
これは、先ほども述べたように、

[22:19 - 22:25]
製品コードベースでコードを書く上で非常に重要な機能です。大規模なリンガー

[22:22 - 22:28]
モデルが改善され、Claude 3.5

[22:25 - 22:31]
Opus、GPT NEX、Strawberry、

[22:28 - 22:33]
Gemini 1.5 Ultraが登場するにつれて、

[22:31 - 22:35]
これらのマルチファイル

[22:33 - 22:37]
編集機能をますます活用できるようになります。カーソルチームに心から感謝します。

[22:35 - 22:39]
皆さんは素晴らしい仕事をしています。

[22:37 - 22:42]
ええと、冒頭で

[22:39 - 22:45]
孤独な人について言及しましたね。  20倍のエンジニア、それは

[22:42 - 22:48]
他でもないAERに取り組んでいるPaulです。AI

[22:45 - 22:50]
コーディングにはこの2つのツールをおすすめします。

[22:48 - 22:52]
最初からこの2つのツールが

[22:50 - 22:54]
私のお気に入りです。PaulはAERを開発していて、

[22:52 - 22:56]
CursorチームはCursorを開発しています。

[22:54 - 22:58]
もちろん、AIコーディングにはこの2つが私のおすすめです。これ

[22:56 - 23:01]
まで数多くのAIコーディングツールを

[22:58 - 23:03]
試してきましたが、この2つに何度も戻ってきて、

[23:03 - 23:08]
チャンネルでもこの​​2つを紹介し続けています。エンジニアとしてアウトプットを

[23:05 - 23:10]
増やすために使える最高のツールだからです。

[23:08 - 23:12]
これらのツールは、

[23:14 - 23:18]
エンジニアのエクスペリエンスを重視しており、

[23:18 - 23:22]
何百、

[23:20 - 23:24]
何千ものファイルと

[23:22 - 23:26]
何十万行ものコードを含むコードベースが実際にどのようなものかを重視しているため、非常に重要で強力です。AER

[23:24 - 23:27]
とCursorはどちらも

[23:26 - 23:29]
そのことを理解している製品であり、

[23:27 - 23:31]
私たちエンジニアのエクスペリエンスを構築しています。お

[23:29 - 23:32]
二人に心から感謝します。

[23:35 - 23:38]
この1年ほど前からこのチャンネルでこの2つのツールについてもっと取り上げていくつもりです。AIコーディングに興味のある方は、以前の動画をいくつかリンクしておきます。

[23:40 - 23:44]
説明欄にリンクがあるので、ぜひチェックしてみてください。

[23:42 - 23:47]
このカーソルの新しい

[23:44 - 23:48]
コンポーザー機能のデモは役立ちました。もし

[23:47 - 23:50]
あなたが何をすべきか知っているなら、いいねをドロップして、

[23:48 - 23:53]
サブをドロップして、コメントを残して、

[23:50 - 23:54]
AIコーディングがどうなっているか教えてください。

[23:53 - 23:58]
これらのツールをどれくらい使っているか教えてください。本当に

[23:54 - 24:01]
ありがとう。次回もお会いしましょう。

## コメント

### 1. @davids4227 (👍 1)
Really good overview, thank you for this. You actually got me excited to try Cursor!

### 2. @THCV4 (👍 23)
Try using cursor and composer along with a voice transcriber tool (such as SuperWhisper). You can just talk out loud to code entire apps!

> **@carinebruyndoncx5331** (👍 5): Just use aider already ? I occasionally use voice prompts but people react odd when you start to talk to your computer ...😂

> **@indydevdan** (👍 3): This future is closer than most of us realize. (Also stay tuned for future videos - this idea is in the queue - we can hook up a Personal Ai Assistant to an ai coding tool and absolutely pop off using voice commands)

> **@jankothyson** (👍 3): @THCV4: Sounds super interesting! I would have a rough idea on how to implement this using aider - as code is transparent through open open source. But how would I hook up SuperWhisper with Cursor (in general) and Composer (in particular)? Would you mind sharing some code?

### 3. @phillonc (👍 3)
Top content, I'm an avid learner yearning for more quality videos.

### 4. @KyleFES (👍 5)
Love the content Dan!

Always waiting eagerly for your next video's insights, keep it up.

### 5. @Calmren (👍 1)
It's sooo good, this helped me refactor with ease. normally a nightmare. Claud Dev, Aider and Cursor all have their moments depending on skill level. i'll switch to try new models, but cursor is my main.

### 6. @moisesbessalle (👍 8)
Love your content. BTW, what do you think of agent Q, swe agent, sakana AI and genie?

### 7. @ginocote (👍 7)
Someone did a VS Code / Cursor extension for aider. It will know where your files are to edit them. To open it when installed, from the top command input enter >open  aider
Or do crtl+shift+p then write open aider and enter.
It will open aider in your IDE terminal with the right path to files when you use add/.

> **@indydevdan** (👍 2): I've used this - it's good but buggy with heavy use (assuming we're referring to the same extension).
This is an advantage/disadvantage Cursor has over Aider - it has the full IDE at it's disposal. 
Aider on the other hand is LEAN, tunable and insanely accurate. Both excellent for difference reasons.

### 8. @yellowboat8773 (👍 22)
I feel like aider is streaks ahead of this hey? It's free, only pat for the API, and it has three features already, can yo usee yourself using Cursor composer over aider?

> **@goforit5** (👍 6): I was going to ask the same question.  Aider seems to cover this already.

> **@ShamusMac** (👍 4): @@goforit5 And with far less pointing and clicking. Hardly a need to pop open a text editor, let alone an IDE.

> **@mattshelley6541** (👍 0): My thoughts exactly. Aider handles multi file edits really well. There are still some quirks but it’s night and day better than this.

> **@Zero-tic** (👍 1): 100%. I believe this is a paid ad by Cursor.

> **@aot2002** (👍 2): Aider all the way over this tool

### 9. @stonedoubt (👍 7)
Aider and ClaudeDev have entered the chat. I like Cursor. The nicest thing is not hitting token limits as quickly but I’m an insane developer… I mean I’m literally insane.

Here is an example. I used Swagger to generate a PHP client of the entire OpenAI api using their recent spec and am already half done converting it to PHP 8.3 with strict typing.

Earlier, I created Pydantic in PHP and translated the Ollama Python client to PHP.

Do you realize how much code that is?

> **@WillMcCartneyAI** (👍 2): are you saying just in general you're an insane dev, or are you saying with the assistance of these tools you've maxed out your code gen ability?

> **@juliovac2113** (👍 0): @@WillMcCartneyAI I think the dude is literally insane ;) haha, I'm a noob but I appreciate your crazyness

> **@DevDialectics** (👍 1): I have made ollama client in bash, with claude... ;)

> **@stonedoubt** (👍 0): @@WillMcCartneyAI both tbh. I’m not saying I’m the best. I’m just stupid productive and work long hours. I used to write software for adult and some of my products that I sold in 2010 when I switched to mainstream. It’s been 14 years. You can still buy it. Gallery Daemon also the tgp script.

But yes… I use Gemini 1.5 Pro (now the newer version) to translate or update because of the context. It does a good job. I found that out when it created a json file representing the NVML API, that I then used to create my own wrapper in Python.

I don’t know Python.

I created a web based websocket app using Python and react to monitor distributed inference BUT I’m having networking issues due to the fact that I’m using windows server atm. I hate windows firewalls and bullshit but I am tired of Linux for a minute. Nvidia drivers and kernel updates don’t mix.

> **@Dandiestpanic** (👍 0): It's more than likely way above my pay grade (zero), but what is the benefit of turning these things to PHP? Is it a "just to"  instance? I'm asking out of genuine curiosity and clueless..ness, not from a place of antagonizing or anything Ill (Cept for my beats say whAAAAA---joking.)

### 10. @thelalomorales (👍 0)
dan you are crushing it sir!

> **@indydevdan** (👍 0): 🙏🙏🙏 one day at a time

### 11. @MarcusNeufeldt (👍 1)
using it for a while now, really good. how do you deal with versioning tho? Making so many changes on so many files...what if the LLM breaks the code and you dont know how to get stuff back together as it was? (asking as a newb coder here)

> **@jjaimealeman** (👍 1): This is why we use git!

> **@indydevdan** (👍 3): Solid question. Extensive use of git and ctrl/cmd+z. A good practice is to commit before using AI. Use a bash alias to git commit fast.

### 12. @valcoiyongoekala5924 (👍 1)
Cool 👍👍👍,thanks a lot .

### 13. @ddwinhzy (👍 2)
I hope you can open a course with a detailed and complete set of introductions. It will be great to learn from you.

### 14. @TravisChristopher (👍 1)
Have you tried Claude Dev yet?

### 15. @FRANKWHITE1996 (👍 0)
awesome video

### 16. @dawid_dahl (👍 0)
Great video! Thank you. 

Could you explain what @codebase symbol does?

> **@indydevdan** (👍 0): You're welcome. It loads the codebase into the context, then ATTEMPTS to filter it down to just the relevant files needed to answer your query.

### 17. @jonathan61214 (👍 1)
Not seeing Composer feature in beta section. Have Pro plan enabled - any advice?

### 18. @RealLexable (👍 0)
As far i heard zed can do the same as IDE and is free. What do you think?

### 19. @RickMurt (👍 0)
Awesome tutorial, thanks! What is this theme with the glowing text?

> **@apexpredator9143** (👍 0): Synthwave 84

### 20. @HistorIAsImposibles776AC (👍 0)
This is escalating pretty fast 😮

> **@hamz_aontop** (👍 0): Makes me so hard sooner then later I’ll be able to scam companies with my portfolio with full stacked software “I made” my goal is to make a software of the same company I’ll be applying for that does the same thing but 10x better

