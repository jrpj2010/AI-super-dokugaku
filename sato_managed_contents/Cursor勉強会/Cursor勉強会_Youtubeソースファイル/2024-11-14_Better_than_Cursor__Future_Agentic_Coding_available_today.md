# Better than Cursor? Future Agentic Coding available today

**チャンネル:** AI Jason
**公開日:** 2024-11-13
**URL:** https://www.youtube.com/watch?v=824Fyh146_w

## 説明

AI Coding Agent that KNOWS your codebase - Build production app with Windsurf

Free E-book of how to learn to code with chatGPT: https://clickhubspot.com/znrx

🔗 Links
- Get full code breakdown & Join AI builder club: https://link.agent.rocks/2wdbg3Z
- Get Windsurf: https://wind.surf/jasonzhou
- Follow me on twitter: https://twitter.com/jasonzhou1993
- Join my AI email list: https://www.ai-jason.com/
- My discord: https://discord.gg/eZXprSaCDE

⏱️ Timestamps
0:00 Platform overview
6:21 How does context aware engine works
10:45 Use case walk through
13:32 Case study: Build PDF converter Sass


👋🏻 About Me
My name is Jason Zhou, a product designer who shares interesting AI experiments & products. Email me if you need help building AI apps! ask@ai-jason.com

#cursor #webscraping  #generativeai #gpt5 #autogen #gpt4 #autogpt #ai #artificialintelligence #tutorial #stepbystep #openai #llm #chatgpt  #largelanguagemodels #largelanguagemodel #bestaiagent #chatgpt #agentgpt #agent #babyagi

## 字幕

[00:03 - 00:07]
ここ数日、Wierという新しいAI IDをいじっています。

[00:09 - 00:13]
他のe IDEと同じように見慣れているように見えますが、実際に使ってみると全く違う感じがします。Wierが

[00:13 - 00:17]
特に優れている重要な点の1つは

[00:15 - 00:18]
コンテキスト認識です。

[00:17 - 00:21]
カーソルを使用して

[00:18 - 00:23]
既存のプロジェクトに機能を実装すると

[00:21 - 00:24]
すぐに気付くのは、プロジェクトをセットアップしてアプリケーションのビルドを指示しても、カーソルが

[00:24 - 00:28]
プロジェクト構造をあまり理解していないことがよくあるということです。プロジェクトの

[00:30 - 00:34]
種類や

[00:32 - 00:36]
適切なプロジェクトファイルを作成する場所について、IDEに何もわからないことがよくあります。さらに、

[00:34 - 00:38]
カーソルに

[00:36 - 00:40]
既存のcbaseに新しい機能を追加するように指示した場合、

[00:40 - 00:44]
通常は

[00:42 - 00:46]
異なるファイルの依存関係をあまり理解していないため、ほぼ確実に失敗します。Wind Serはどのように

[00:44 - 00:48]
違うのでしょうか。

[00:46 - 00:51]
これはWierのインターフェースで、

[00:48 - 00:53]
他のIDEと同じように見慣れたものであり、任意の

[00:51 - 00:55]
ファイルをビルドして

[00:53 - 00:57]
オートコンプリートなどの機能を試すことができます。しかし、本当に魔法なのは

[00:55 - 00:59]
Cascade機能です。Cascadeは、

[00:59 - 01:03]
カーソルコンポーザーのように、

[01:01 - 01:05]
ファイルを作成したりコマンドを実行したり、

[01:03 - 01:07]
プロジェクト構造を理解できるエージェントと考えることができます。

[01:05 - 01:10]
他の Chatwi コード

[01:07 - 01:11]
ベースのインターフェースと似ているように見えるかもしれませんが、実際に使ってみると

[01:10 - 01:14]
少し違った感じがします。

[01:11 - 01:16]
プロジェクト全体の構造、環境を本当に認識しているからです。

[01:16 - 01:20]
簡単な例として、この

[01:17 - 01:22]
Nextjs プロジェクトはすでに

[01:20 - 01:24]
特定のファイル構造でセットアップされています。Wind

[01:22 - 01:26]
Serve CC に Web アプリをビルドするように指示するだけで、

[01:26 - 01:30]
現在のファイル構造で指示されることなく、

[01:28 - 01:32]
適切な場所にファイルを作成できます。

[01:30 - 01:35]
たとえば、基本的な

[01:32 - 01:37]
テキストから画像へのプラットフォームを作成したい場合は、

[01:37 - 01:41]
Replicate でホストされている Flux モデルからドキュメントを取得し、Whole Dog を

[01:39 - 01:44]
直接コピーして貼り付け、簡単なプロンプトを追加します。

[01:41 - 01:46]
上記は、Replicate に投稿されたテキストから画像への AI モデルです。

[01:44 - 01:49]
これを

[01:46 - 01:51]
Nextjs と Chassin を使用して Web アプリに変換するのに役立ちます。すでに

[01:49 - 01:53]
アプリ フォルダーにプロジェクトをセットアップしています。

[01:53 - 01:57]
コードを実装する前に、まず

[01:55 - 01:59]
プロジェクト構造を分析して、

[01:57 - 02:02]
どのファイルを作成する場所を把握します。Nextjs

[01:59 - 02:04]
プロジェクトと Chassin

[02:02 - 02:06]
コンポーネントが既にセットアップされていることを確認します。次に、

[02:06 - 02:10]
特定のターミナル コマンドを実行するための承認を求めるこの UI も表示されます。

[02:08 - 02:13]
そのため、実際にコマンドを直接実行できます。

[02:10 - 02:15]
承認をクリックすると、

[02:13 - 02:17]
コマンドが実行されます。 そして結果を取得します。

[02:15 - 02:19]
矢印がない場合は続行されますが、

[02:17 - 02:21]
コマンドラインで

[02:19 - 02:24]
矢印を返すと、

[02:21 - 02:26]
自己反映して問題を修正することもできます。

[02:24 - 02:28]
左側のプロジェクトフォルダを確認すると、

[02:26 - 02:29]
すべてが期待どおりに正しい場所に作成されており、

[02:29 - 02:33]
コンポーネントフォルダがすでに存在することがわかります。そのため、

[02:31 - 02:35]
すべての新しいコンポーネントはそのフォルダの下に配置されます。

[02:33 - 02:38]
このアプリを開くと、アプリ

[02:35 - 02:41]
も実行されています。この

[02:38 - 02:43]
Pur構造とは別に、AIと並んで人間が行っているすべての変更を実際に追跡して理解します。

[02:43 - 02:48]
たとえば、

[02:45 - 02:50]
このコンポーネントに移動して、

[02:48 - 02:54]
この関数の名前をテキストから

[02:50 - 02:56]
画像へのフォームに変更して保存すると、

[02:56 - 03:01]
すべての変数名が間違っているため、明らかにエラーが発生しますが、

[02:58 - 03:04]
実際にはCascadeに移動して

[03:01 - 03:06]
プロンプトを表示せずに続行できます。

[03:06 - 03:10]
コンポーネント名が

[03:08 - 03:12]
画像生成フォームからテキストから画像への

[03:10 - 03:14]
フォームに変更されたことを実際に理解して認識し、コードベース全体のリファクタリングを開始して、

[03:12 - 03:16]
すべてが

[03:14 - 03:19]
更新され、新しい名前が使用されるようにします。

[03:19 - 03:23]
また、変更を反映するためにファイル名の更新も提案されます。これは

[03:21 - 03:25]
私にとって本当に大きなHの瞬間であり、

[03:25 - 03:30]
単なる Visual Studio

[03:28 - 03:33]
プラグインは、

[03:30 - 03:34]
ユーザーの操作をはるかに正確に把握し、変更内容や現在作業中のファイルなどのコンテキスト情報をより多く

[03:33 - 03:36]
取得できるようになったため、より多くの情報を取得できるようになりました。

[03:36 - 03:40]
また、

[03:40 - 03:44]
コンソールから直接フィードバックを取得できるサンドボックス環境も用意されています。Wi-Fi を

[03:42 - 03:47]
使っていた時に経験したもう一つの出来事は、

[03:44 - 03:48]
ある時、ビルドしようとしていたアプリケーションにバグが発生し、

[03:48 - 03:53]
Wi-Fi に修正を依頼した

[03:51 - 03:55]
ところ、実際にリフレクションが

[03:53 - 03:57]
開始され、独自の

[03:55 - 04:00]
解決策が反復処理されたことです。

[03:57 - 04:02]
最初は修正プログラムが生成されましたが、その後、

[04:00 - 04:04]
以前のバージョンにまだ問題がある可能性があるため別のアプローチを試してみましょうというメッセージが表示され、

[04:04 - 04:08]
別のバージョンが試されました。その後、

[04:06 - 04:11]
再度リフレクションが実行され、

[04:08 - 04:14]
より信頼性の高い最終アプローチを試してみましょうというメッセージが表示され、

[04:11 - 04:16]
最終的に問題が解決しました。これは

[04:14 - 04:18]
非常に興味深い点でした。

[04:16 - 04:20]
カーソルや Co-Pilot などの他のプラットフォームを使用すると、

[04:18 - 04:22]
デバッグ中に同じことを何

[04:20 - 04:23]
度も繰り返し実行しているだけで

[04:23 - 04:28]
問題が解決しないように感じることがよくあるからです。

[04:26 - 04:29]
しかし、このリフレクション機能によって、問題を

[04:28 - 04:31]
解決するためのさまざまな方法を実際に検討できるため、

[04:31 - 04:35]
結果と出力が劇的に改善される可能性があります。

[04:33 - 04:37]
これがいつトリガーされるのか、そしてどのように決定されるのかは私には少し謎です。

[04:37 - 04:41]
実際にはまだ改善

[04:39 - 04:43]
と反復作業が必要ですが、この

[04:41 - 04:44]
動作は間違いなく非常に

[04:43 - 04:47]
魅力的でスマートです。前にも述べた

[04:44 - 04:48]
ように、このWing serveのUIは非常に

[04:47 - 04:50]
馴染みのあるものに見えますが、その裏では

[04:48 - 04:53]
コード

[04:50 - 04:55]
品質と接触認識の向上に多くの作業が行われているようです。Wing

[04:53 - 04:57]
serveがコンテキスト認識の

[04:55 - 04:59]
点でこれほど優れている理由を理解するために、

[04:57 - 05:01]
私はcodentと

[04:59 - 05:03]
Wing serveチームに連絡を取り、彼らの

[05:01 - 05:05]
秘密の情報源を理解しました。彼らはWing

[05:05 - 05:08]
serveが実際に舞台裏でどのように機能しているかについて多くの興味深い情報源を共有してくれました。

[05:07 - 05:10]
しかし、これらの洞察インタビュークリップをお見せする前に、

[05:08 - 05:12]
皆さんの多くは

[05:10 - 05:14]
コーディングを学び始めたばかりだと思います。

[05:12 - 05:15]
よく聞かれる質問の1つは、コーディングを

[05:14 - 05:17]
学ぶ必要があるかどうかです。

[05:15 - 05:19]
もしそうなら、ロードマップは

[05:17 - 05:22]
実際にはどのようなものになるのでしょうか。そこで、

[05:22 - 05:26]
Googleの主席アナリティクスリード

[05:24 - 05:28]
兼データサイエンティストであるSunday scetが作成した無料の電子書籍をご紹介します。彼女は、

[05:30 - 05:34]
Chad gbtのようなプラットフォームを使ってコーディングを学ぶ際に使用したすべての秘密のヒントと方法論を書き留め、パーソナライズ

[05:32 - 05:36]
された学習ロールマップを設計しました。

[05:36 - 05:40]
コーディングの基礎と基本事項がすべて網羅されています。目的に合った

[05:38 - 05:42]
コーディング言語の選び方、

[05:44 - 05:48]
コードのデバッグや最適化といった様々なコーディングシナリオにおけるベストプラクティスのプロンプト、そして

[05:48 - 05:52]
わずか4ヶ月でPythonをマスターするための詳細なロードマップ、

[05:52 - 05:57]
多くの学習リソースと詳細な

[05:54 - 05:59]
ビデオチュートリアルを含むカスタムGBTの構築方法、ワークフローをステップバイステップで紹介するチュートリアルなどが含まれています。

[06:01 - 06:04]
コーディングを始めたばかりの方はぜひご覧ください。

[06:02 - 06:06]
説明

[06:04 - 06:07]
欄に無料でダウンロードできるリンクを貼っておきます。

[06:06 - 06:09]
この素晴らしい資料を無料で提供してくれたホップス・ボールに感謝します。

[06:07 - 06:11]
さて、

[06:09 - 06:14]
ウィンガーに戻りましょう。こちらは

[06:11 - 06:16]
私とコーディ、そして創設

[06:14 - 06:18]
エンジニアのアンドロとのインタビュークリップです。アンドロは、このコンテキストアウェアIDEの構築方法

[06:16 - 06:20]
について、多くの興味深い学びや考えを共有しています。

[06:20 - 06:24]
私がいつも

[06:22 - 06:26]
CASCについて説明しているように、AIに

[06:24 - 06:28]
3つのもの、つまり知識

[06:26 - 06:30]
ツールと人間の行動へのアクセスを与えています。そして、これら3つの

[06:28 - 06:32]
それぞれについて調査した結果、

[06:32 - 06:36]
それぞれについて深い理解が得られ、

[06:34 - 06:38]
それらを組み合わせることが実際に理にかなっていることに気づきました。 ますます

[06:36 - 06:40]
大規模なタスクを実行するために、

[06:38 - 06:41]
知識面では、コンテキスト認識エンジンと呼んでいるシステムの

[06:40 - 06:43]
構築に多くの時間を費やしてきました。これは、

[06:46 - 06:52]
大規模なコードベースをパーツとして扱い、埋め込み、

[06:48 - 06:54]
インデックス付けし、完全なリポジトリ

[06:52 - 06:55]
認識とコード構造を組み合わせられるシステムです。つまり、

[06:57 - 07:01]
LLM自体から独立したシステムの構築に多くの時間を費やしてきました。これは

[06:59 - 07:03]
Codi​​umのストーリーの一部です。私たちは

[07:01 - 07:05]
1,000社以上の企業をサポートして

[07:03 - 07:06]
おり、その中にはFortune 500企業も含まれています。企業に

[07:06 - 07:11]
これほど

[07:09 - 07:12]
複雑なコードを提供できる唯一の方法は、

[07:11 - 07:14]
彼らの

[07:12 - 07:15]
コードベースをしっかりと理解することです。それが最初のアクセスです。その

[07:14 - 07:17]
ため、私たちは常に継続的な調査を行っており、

[07:17 - 07:22]
Codium拡張機能の開発に携わってきました。

[07:19 - 07:24]
しかし、ツールと人間の

[07:22 - 07:26]
アクションの部分は比較的最近のものだと

[07:24 - 07:28]
思います。

[07:26 - 07:29]
ツール側で物事がまとまった時、

[07:29 - 07:34]
ファイルの編集、

[07:31 - 07:36]
ファイルの追加、GP、ディレクトリの一覧表示といった、

[07:34 - 07:38]
分かりやすいツールがあることに気づきました。

[07:36 - 07:41]
AIに、

[07:38 - 07:45]
必ずしも画期的な

[07:41 - 07:47]
アイデアではないかもしれませんが、他のツールも開発したいと考えていました。その

[07:45 - 07:48]
一つは

[07:47 - 07:51]
数ヶ月前に報道で取り上げられたもの

[07:48 - 07:52]
です。

[07:51 - 07:54]
埋め込みベースの検索には

[07:52 - 07:56]
根本的な限界があるという考えです。埋め込みベースの検索では、

[07:54 - 07:58]
コードの誤検出率が高いと

[07:58 - 08:01]
誤検出の数が

[08:00 - 08:03]
増え、大量の

[08:01 - 08:05]
ゴミが入ればゴミも出てきます。

[08:03 - 08:07]
そこで私たちは、コンピューティング能力を活用して、大量のLLMを

[08:07 - 08:12]
大規模に並列化し、

[08:12 - 08:17]
大量のコンピューティングリソースを使って同時に実行することで、埋め込みベースの方法よりもはるかに高い精度

[08:15 - 08:19]
で、より関連性の高いスニペットを取得する新しい方法を考案し

[08:19 - 08:23]
ました。埋め込み

[08:22 - 08:27]
ベースの方法に戻ると、

[08:23 - 08:28]
生のコードスニペットを

[08:27 - 08:32]
低次元空間に配置することになります。

[08:28 - 08:33]
定義上、

[08:32 - 08:36]
元の生のテキストのニュアンスの一部が失われます。

[08:33 - 08:38]
つまり、

[08:36 - 08:40]
埋め込みBASシステムの開発には、精度や処理方法

[08:38 - 08:42]
に根本的な限界があります。

[08:40 - 08:46]
偽ビット

[08:42 - 08:47]
率は低く抑えられますが、質問を少し変えてみましょう。

[08:49 - 08:52]
埋め込みベースの検索ではなく、高速だから埋め込みベースの検索を行うという

[08:56 - 09:02]
シンプルな質問を得意とする独自のLMをトレーニングしたらどうなるでしょうか。この

[08:59 - 09:03]
コードスニペットはクエリに関連しているでしょうか？

[09:03 - 09:06]
非常に大規模なモデルである必要はありませんが、その質問に非常に

[09:05 - 09:09]
優れた専用モデルであれば問題ありません。

[09:06 - 09:13]
そして、そのモデルを使って、膨大な計算量を使って、

[09:09 - 09:15]
実質的に数千回の

[09:13 - 09:18]
呼び出しを並列化し、非常に

[09:15 - 09:20]
短期間で処理します。すると、

[09:23 - 09:28]
各コードスニペットとクエリの関連性について、はるかに高い品質スコアが得られます。

[09:28 - 09:31]
生のTexのニュアンスを完全に捉えることができます。

[09:29 - 09:32]
そして、それを

[09:31 - 09:35]
シグナルとして、

[09:32 - 09:37]
検索能力として利用することで、

[09:35 - 09:39]
埋め込みベースの最先端の方法よりもはるかに優れたパフォーマンスが得られることがわかりました。

[09:39 - 09:44]
確かに、計算コストのトレードオフはありますが、

[09:42 - 09:45]
私たちはいつでもそのトレードオフを受け入れます。

[09:44 - 09:47]
もしそれが本当に意味するのであれば、それは

[09:45 - 09:48]
大きな成果を生み出すでしょう。そこではいくつかのブレーク

[09:47 - 09:50]
スルーがありました。そして

[09:48 - 09:51]
人間の行動の部分では、

[09:56 - 10:00]
開発者が何を編集しているのか、どこで編集して

[09:58 - 10:02]
いるのか、どのように

[10:00 - 10:04]
ディレクトリ内を移動しているのか、

[10:02 - 10:05]
ターミナルでコマンドを実行しているのかを実際に把握できる

[10:05 - 10:09]
適切な粒度とは何かを本当に理解しようとしていたと思います。そして、

[10:07 - 10:11]
開発者が

[10:09 - 10:13]
常に何をしているのかを真に把握するために必要な粒度を理解していました。これが3つ目の

[10:11 - 10:14]
理由で、そして最も最近の理由です。

[10:17 - 10:20]
開発者が何をしているのかを把握したいので、エディターへのアクセスと制御が本当に必要だと思いました。

[10:20 - 10:23]
開発者が何をしているのか理解できれば、

[10:23 - 10:27]
彼らの意図をより深く理解し、

[10:25 - 10:29]
適切な結果を提供できる可能性が高くなります。ですから、

[10:32 - 10:35]
すべてを解決した魔法の弾丸が一つあった、とだけ言うことはできません。

[10:34 - 10:37]
何年もの実際の作業が結集

[10:35 - 10:40]
したようなもので、

[10:37 - 10:42]
独自の

[10:40 - 10:43]
Surface、独自のUX、あるいは独自の 独自のIDEを使えば、

[10:42 - 10:45]
これを魔法のような

[10:43 - 10:47]
方法で公開できます。Wing Surfを最大限に活用する方法を最もよく示すために、

[10:47 - 10:51]
実際のアプリケーションを一緒に構築してみましょう。

[10:51 - 10:55]
構築するユースケースを探していたときに、Greg Eisenbergのツイートを見ました。

[10:52 - 10:57]
これは銀行取引明細書コンバーターと呼ばれるマイクロセットで、

[10:55 - 10:59]
基本的に

[10:57 - 11:01]
PDFを

[10:59 - 11:03]
Excelに変換するだけですが、このシンプルな

[11:01 - 11:05]
アプリケーション自体が

[11:03 - 11:06]
毎月3万ドル以上の収益を生み出しています。これは

[11:05 - 11:09]
非常に興味深いことです。PDF

[11:06 - 11:11]
から構造データを抽出するのは、

[11:09 - 11:12]
大規模なLangモデルが得意とする作業であり、

[11:14 - 11:18]
会計事務所、弁護士、マーケティング代理

[11:16 - 11:20]
店など、多くの企業が毎月何百

[11:18 - 11:22]
時間もかけてこのデータ入力

[11:20 - 11:24]
と変換作業を行っています。そこで、Wi-Fiを使用して

[11:22 - 11:26]
PDFからExcelへのコンバーターを構築しました。このコンバーターに

[11:24 - 11:29]
あらゆる種類の

[11:26 - 11:31]
PDFファイルをドロップし、必要なデータ部分をすべて定義すると、

[11:31 - 11:34]
残りの作業はコンバーターが情報を抽出して

[11:33 - 11:36]
Excelファイルに変換し、

[11:34 - 11:38]
ユーザーがダウンロードできるようにします。このコンバーターがあれば、

[11:38 - 11:42]
使い慣れた特定の垂直ソリューションに簡単に調整でき、より

[11:40 - 11:43]
小さなモデルを作成してFチューンすることもできます。

[11:42 - 11:45]
コストを削減し、Wind Serf

[11:43 - 11:46]
でこれをどのように構築するかを段階的に説明します。GitHub

[11:46 - 11:49]
に新しいプロジェクトを作成してバージョンを追跡できるようにします。

[11:48 - 11:52]
まず、

[11:49 - 11:56]
chassis inを使用してNextjsプロジェクトを作成します。

[11:52 - 11:59]
次に、CD converter

[11:56 - 12:01]
MPX CH in Latestをinput S car label

[11:59 - 12:02]
buttonで実行します。これは、おそらく使用する必要がある一般的なコンポーネントのリストです。

[12:02 - 12:06]
このPDFコンバータを構築するための

[12:05 - 12:08]
パイプラインは次のようになります。

[12:06 - 12:10]
アプリはさまざまなPDFを受け取り

[12:08 - 12:12]
、おそらく市場で最高のPDFからMarkdownへのコンバータであるllama Partsを使用します。

[12:13 - 12:18]
これは基本的に、

[12:15 - 12:20]
大量のPDFファイルから情報をMarkdownに抽出できるサービスです。

[12:18 - 12:22]
これは、大規模な

[12:20 - 12:24]
Dageモデルが非常に読みやすい形式です。

[12:22 - 12:27]
なぜ特別な

[12:24 - 12:29]
PDFコンバータが必要なのか疑問に思うかもしれません。それは、PDFが

[12:27 - 12:32]
非常に複雑で乱雑だからです。

[12:29 - 12:34]
表や図、方程式など、さまざまな構造があり、

[12:34 - 12:38]
読み取り順序も

[12:36 - 12:41]
異なる場合があります。意味を理解するために特定の順序で読む必要があるテキストを含むPDFファイルもあります。

[12:44 - 12:49]
大規模な L モデルが

[12:46 - 12:51]
実際に PDF ファイルを適切に読み取ることができるようにするために、大量の最適化を行う必要がありますが、

[12:49 - 12:52]
これは llama pars が得意とするところです。そのため、llama

[12:51 - 12:55]
parts を使用して

[12:55 - 12:59]
メッセージ PDF から構造化マークダウン テキストを実際に抽出し、

[12:57 - 13:01]
このデータを GPD 4o モデルなどの

[12:59 - 13:04]
構造化データ抽出をサポートする Lar モデルにフィードして、

[13:04 - 13:07]
それらのデータを Excel ファイルにフラット化できます。

[13:06 - 13:10]
前に述べたように、

[13:07 - 13:12]
フレームワークとして nextjs を使用します。

[13:10 - 13:15]
フロントエンド開発に精通していない場合は、

[13:12 - 13:17]
nextjs は一種のフロントエンド フレームワークであり、

[13:15 - 13:18]
ゼロから構築するのではなく、

[13:18 - 13:23]
特定のプロジェクト構造で既に構築されている多くのコンポーネントを提供します。chassen

[13:20 - 13:26]
と twin は、アプリの外観を改善するための

[13:23 - 13:28]
UI コンポーネントと CSS ライブラリです。

[13:26 - 13:30]
また、

[13:28 - 13:33]
npm npx も使用します。これは、

[13:30 - 13:35]
サードパーティのライブラリをインストールするためのパッケージ マネージャーのようなものです。それでは

[13:33 - 13:37]
始めましょう。

[13:35 - 13:39]
このプロジェクト フォルダー内に instructions フォルダーを作成し

[13:37 - 13:41]
、instruction を作成します。  MD

[13:39 - 13:43]
ファイル。私の他のAI

[13:41 - 13:45]
コーディング動画をご覧になったことがある方はご存知でしょうが、私のプロセスは

[13:43 - 13:48]
通常、AIと連携した製品要件定義から始まります。そうすることで、

[13:48 - 13:51]
構築するものが何であれ、私が

[13:49 - 13:53]
望む結果が得られるように

[13:51 - 13:54]
なります。共通の構造は通常、プロジェクトの

[13:53 - 13:57]
概要、

[13:54 - 13:59]
プロジェクトで何を行うか、私が

[13:57 - 14:00]
提供したいコア機能、関連ドキュメント

[13:59 - 14:02]
実装、AIモデルが犯す

[14:00 - 14:05]
一般的な間違いをカバーする重要な実装メモ、

[14:02 - 14:07]
そして

[14:05 - 14:09]
現在のファイル構造のようになります。しかし、

[14:07 - 14:11]
Wind Serveの優れた点の1つは、

[14:11 - 14:15]
プロジェクト構造の理解が非常に優れていることです。そのため、実際には、

[14:15 - 14:19]
現在のファイル構造を含めるためにこのハックを行う必要はありません。Wi

[14:17 - 14:21]
Serveはそれを取得するだけで、

[14:19 - 14:23]
残りのコンテンツは依然として関連性があります。Wi

[14:21 - 14:25]
Serveチームにも

[14:23 - 14:27]
確認してもらいましたが、これは、

[14:25 - 14:29]
どの程度の情報を放棄すべきかについての彼らの推奨事項です。

[14:29 - 14:33]
私たちのケースでは、このプロジェクトの概要を説明し、

[14:34 - 14:39]
複数のPDFファイルをアップロードし、オープン

[14:37 - 14:41]
構造出力を使用して情報を抽出し、

[14:39 - 14:44]
Excelファイルに変換できるNextJSアプリを構築することを目標とします。NEX

[14:41 - 14:45]
js14シャーシとTailwind Lucidアイコンを使用します。

[14:44 - 14:47]
次に、次のように記述します。

[14:47 - 14:51]
このアプリのコア機能は、4つの主要なコンポーネントから構成されています。

[14:50 - 14:53]
まず、ユーザーがファイルをアップロードし

[14:51 - 14:55]
、抽出したいデータポイントを定義できるようにします。

[14:53 - 14:57]
次に、

[14:55 - 15:00]
Lパーツを使ってテキストを抽出し、

[14:57 - 15:02]
Open AIに送信してデータを処理します。

[15:00 - 15:04]
そして最終的にExcelファイルに変換して

[15:02 - 15:06]
ユーザーがダウンロードできるようにします。私は通常、

[15:04 - 15:08]
非常に詳細な動作を指定する傾向があるので、

[15:08 - 15:12]
ファイルのアップロードとスキーマ定義を設定します。

[15:11 - 15:14]
ユーザーは1つまたは

[15:12 - 15:16]
複数のPDFファイルをアップロードし、抽出したいデータポイントを定義できるようにします。

[15:16 - 15:20]
これは、個々の

[15:18 - 15:22]
フィールド

[15:22 - 15:26]
または抽出したいオブジェクトの配列であるグループのいずれかです。これは、

[15:24 - 15:28]
銀行の明細書や請求書など、

[15:28 - 15:31]
同様の構造を持つ情報のリストを

[15:29 - 15:34]
取得したい場合に便利です。各グループには、

[15:31 - 15:36]
複数のフィールドを定義し

[15:34 - 15:37]
たり、別のグループを定義して、

[15:36 - 15:40]
このようなNast構造を作成できます。また、

[15:37 - 15:42]
抽出ボタンも必要です。

[15:40 - 15:44]
また、

[15:42 - 15:47]
このソフトウェアがどのように機能するかを示すために、デフォルトのスキーマを設定します。

[15:44 - 15:49]
デフォルト

[15:47 - 15:51]
値を設定します。

[15:49 - 15:53]
サーバーサイドのファイル処理は

[15:51 - 15:54]
基本的にフロントエンドで行います。各

[15:53 - 15:56]
機能はクライアント側またはサーバー側で実行できます。サーバー

[15:54 - 15:58]
サイドアクションは、

[15:58 - 16:01]
セキュリティ

[15:59 - 16:03]
データのプリロードとファイル処理を必要とするタスクに適しています。ファイル処理は

[16:01 - 16:05]
通常、サーバー側で処理されます。

[16:03 - 16:07]
ここでのドキュメントの大部分は、

[16:05 - 16:09]
基本的に

[16:07 - 16:10]
どのような機能を

[16:09 - 16:13]
構築したいかという要件を分割しているだけです。テキスト

[16:10 - 16:15]
抽出については、PDF Tex抽出にLLAMを使用します。

[16:13 - 16:17]
これもサーバー

[16:15 - 16:19]
側で行います。各ファイルについて、ドキュメント化されたすべてのチャンクを結合して

[16:17 - 16:21]
完全なTXを作成し、

[16:19 - 16:24]
4つのTXを返すようにします。これは以前

[16:21 - 16:26]
LV Partsを使用していたときに気づいたことです。LV Partsは

[16:26 - 16:30]
PDF全体を複数の異なる

[16:28 - 16:32]
チャンクに分割しますが、多くの場合、大規模なLモデルは

[16:30 - 16:34]
これを認識せず、最初のチャンクのみを抽出します。つまり、

[16:34 - 16:38]
完全なPDFデータを取得できないということです。

[16:36 - 16:39]
そこで、この命令を追加します。この

[16:38 - 16:41]
テキスト抽出は、

[16:39 - 16:43]
ユーザーがファイルをUIに承認した直後に実行されるようにする必要があります。

[16:41 - 16:45]
ボタンが

[16:43 - 16:47]
クリックされるのを待つ必要はありません。これにより、この

[16:45 - 16:49]
プロセスを少し高速化できます。コード実装例

[16:47 - 16:52]
として、LLAM Procorドキュメントに厳密に従います。

[16:49 - 16:54]
これは

[16:52 - 16:57]
実際には非常に重要です。LLAM

[16:54 - 16:59]
パーサーは 比較的新しいパッケージなので、

[16:57 - 17:01]
クラウドやGBD4のようなモデルについては、使い方についてあまり知識がありませんでした。

[17:01 - 17:06]
通常は、ドキュメントにアクセスして、

[17:06 - 17:11]
ここにあるファイルをコピーして、自分の説明書に貼り付けます。

[17:08 - 17:12]
名前が

[17:11 - 17:14]
同じであることを確認します。これは、

[17:14 - 17:19]
ドキュメントの関連部分に注意を払うのに役立つと考えているためです。

[17:17 - 17:20]
ここにある識別子が示すように、

[17:19 - 17:23]
各ファイルがアップロードされると、

[17:20 - 17:25]
ページ上のアイテムとして表示されるため、

[17:23 - 17:27]
ユーザーはクリックして

[17:25 - 17:28]
抽出されたテキストをプレビューできます。ファイルを追加し続けることもできます。

[17:27 - 17:31]
これはサーバー側での

[17:28 - 17:32]
処理のみで、その後はデータ処理になります。

[17:31 - 17:34]
ユーザーが抽出開始ボタンをクリックすると、

[17:32 - 17:36]
データは

[17:34 - 17:38]
Open AIに送信され、すべてのファイルが処理されます。

[17:38 - 17:42]
情報抽出にはOpen AIの構造出力を使用します。Open

[17:42 - 17:46]
AIの構造データ出力について添付されているドキュメントに従ってください。

[17:45 - 17:49]
基本的に同じ

[17:46 - 17:51]
ことを行い、この特定のOpen AIに適用できる関連コード例を探します。

[17:51 - 17:56]
構造データ抽出の例を提供している

[17:54 - 17:58]
ので、コピーして

[17:56 - 18:00]
貼り付けます。

[17:58 - 18:02]
ここには、

[18:00 - 18:04]
すべてのモデルでGBD4を使用するようにという注意書きも記載しておきます。

[18:02 - 18:06]
データ構造を定義するためのZodは、カーソルを

[18:04 - 18:08]
使用していたときに発見したものです。この

[18:08 - 18:12]
機能を使用するとほぼ確実に失敗します。これは、

[18:10 - 18:14]
構造出力が非常に新しい機能であるためです。

[18:12 - 18:17]
リリースされた大規模なLモデルを開くと、

[18:17 - 18:21]
カーソルを使用していた当時は、その知識がありませんでした。ドキュメント

[18:19 - 18:23]
内の適切なコード例を取得するという点ではそれほど優れていませんでした。そのため、

[18:23 - 18:26]
旧式の方法で実装される傾向がありました。

[18:25 - 18:29]
これは、Wind Serverが本当に得意とするところです。

[18:26 - 18:31]
最後に、

[18:29 - 18:33]
ファイルのダウンロードに関するドキュメントも追加します。

[18:33 - 18:37]
複数の異なるファイルからのすべてのタイプデータ処理を1つの

[18:35 - 18:40]
Excelに結合します。次の構造ではそれらをフラット化し、

[18:37 - 18:43]
適切なエラー

[18:40 - 18:44]
処理とExcelファイルのダウンロードを有効にする必要があります。

[18:43 - 18:46]
また、一時

[18:44 - 18:49]
ファイルのクリーンアップも実装する必要があります。そうしないと、アップロードされたすべての

[18:46 - 18:51]
Excelファイルがpingを出し続けます。

[18:49 - 18:53]
これでほぼ完了です。最後に、

[18:53 - 18:58]
重要な実装メモもいくつか含めます。

[18:55 - 19:00]
私のAIコーディングワークフローでは、

[18:58 - 19:02]
一般的な矢印のリストを追跡する傾向があります。そうする

[19:00 - 19:04]
ことで、

[19:02 - 19:05]
これらの間違いが発生する可能性が低くなります。これで

[19:04 - 19:08]
ほぼ準備が整いました。では、

[19:05 - 19:10]
このアプリの実装を開始しましょう。

[19:10 - 19:14]
Wi-Fi のコーディングエージェントである Cascade を開いて、

[19:13 - 19:17]
指示を与えます。

[19:14 - 19:19]
ユーザーが PDF ファイルをアップロードして

[19:17 - 19:21]
Excel に変換できる NextJS アプリを構築したいのです。私が与えた

[19:19 - 19:23]
指示に厳密に従って実装します。

[19:21 - 19:25]
プロジェクトは

[19:23 - 19:27]
このフォルダに既にセットアップしてあります。それでは、

[19:25 - 19:29]
最初の機能であるファイルのアップロードと

[19:27 - 19:30]
スキーマ定義を構築してみましょう。

[19:30 - 19:36]
指示ファイルを開いて

[19:34 - 19:39]
revant チャンクを調べると、

[19:36 - 19:41]
実際にどのコード行が参照されているかがわかります。また、

[19:43 - 19:47]
このプロジェクトにどのようなコンポーネントが既に存在するかを確認して、

[19:45 - 19:49]
適切な場所にファイルが作成されていることを確認します。

[19:47 - 19:52]
ここで表示されるのは、

[19:49 - 19:54]
各ステップの後にカーソルコンポーザーと比較することです。これは、

[19:54 - 19:58]
以前に行われた処理を少し反映できます。次に、次のステップに進みます。

[19:56 - 20:00]
これが完了すると、生成された

[19:58 - 20:02]
コードにクールな点も表示されます。

[20:02 - 20:06]
まだインストールしていない UI コンポーネントライブラリがいくつか使用されているため、

[20:04 - 20:09]
ターミナルコマンドが生成され

[20:06 - 20:11]
、承認を求められます。

[20:09 - 20:13]
ここで承認すると、コマンドラインが実行され、

[20:11 - 20:15]
次のステップに進みます。これは非常に

[20:13 - 20:18]
便利です。 コマンドラインには

[20:15 - 20:20]
矢印がいくつかあり、フィードバックも取得される

[20:18 - 20:22]
ため、それに基づいて反復して次のステップを設計できます。

[20:20 - 20:26]
これを実行してみましょう。

[20:22 - 20:28]
開いているターミナルで mpm run

[20:26 - 20:30]
def cool を実行すると、このアプリが

[20:28 - 20:32]
すでにビルドされており、

[20:30 - 20:34]
ファイルをアップロードできるほか、重要な特定のデータポイントを定義することもできます。

[20:34 - 20:39]
名前、データ型、説明をここに入力できます。

[20:37 - 20:41]
グループの場合は、さらに情報を定義することもできます。

[20:39 - 20:45]
それでは、

[20:41 - 20:47]
次のステップに進みましょう。ステップ 2 を実行しましょう。

[20:45 - 20:50]
次に何が起こるかというと、実際には

[20:47 - 20:52]
指示に戻ります。  MDでコンテキスト

[20:50 - 20:55]
の一部として関連情報を探します。

[20:52 - 20:57]
ここで新しいライブラリをインストールする必要があることに注意してください。これを受け入れます。これで

[21:02 - 21:06]
完了です。矢印が表示されています。

[21:05 - 21:08]
この矢印は基本的に、シャーシから

[21:06 - 21:10]
このダイアログコンポーネントを実際には追加していないことを意味します。

[21:10 - 21:14]
これをコピーして貼り付けると、

[21:13 - 21:16]
適切なコマンドが実行されるはずです。

[21:14 - 21:19]
ただし、1つ

[21:16 - 21:22]
知っておくべきことがあります。デフォルトでは、クラウド

[21:19 - 21:24]
3.5はシャーシとUIの古い構文を使用しているため、

[21:24 - 21:28]
問題が発生する可能性があります。シャーシを使用している

[21:26 - 21:30]
場合は、このような特別な指示を追加して

[21:28 - 21:32]
ドキュメントに追加してください。

[21:30 - 21:34]
ここで本当に素晴らしいのは、

[21:32 - 21:37]
この矢印によって、

[21:37 - 21:41]
必要な他のコンポーネントも

[21:39 - 21:43]
インストールする必要があるかどうかを確認する必要があることも反映され、ファイルdogを参照して

[21:41 - 21:44]
再確認できることです。

[21:43 - 21:47]
前の指示に基づいて、次に行う必要がある2つのことは、

[21:44 - 21:49]
1つはllama paror APIキーを追加することです。もう1つは、

[21:49 - 21:55]
アップロードされたファイル用にプロジェクトルート内にフォルダーを作成する必要があります。

[21:52 - 21:58]
ここにフォルダーを作成して、

[21:55 - 22:00]
plose datを使用することもできますが、

[21:58 - 22:02]
必要であればこれを実行するために挿入しますが、

[22:00 - 22:05]
ここでは ARL を作成するだけです。また、クラウドにアカウントを

[22:02 - 22:08]
作成するための llama pars API も取得する必要があります

[22:05 - 22:10]
。 ラマ指数。 次に「

[22:08 - 22:13]
APIキー」に移動し、ここで新しいAPIキーを作成します。「

[22:10 - 22:15]
Tov」にAPIキーを貼り付けます。

[22:13 - 22:18]
これでページを更新して試すことができます。

[22:15 - 22:20]
このサンプルPDFファイルをアップロードします。

[22:18 - 22:22]
完了すると「

[22:20 - 22:24]
テキストを表示」ボタンが表示されます。これをクリックすると、元の請求書PDFに

[22:24 - 22:28]
基づいてテキストがマークダウンファイルに適切に抽出されていることがわかります。これで「

[22:28 - 22:33]
次のステップ」に進み、ステップ3を実行できます。

[22:31 - 22:35]
これは私が非常に興味深い部分です。

[22:33 - 22:38]
前述のように、

[22:35 - 22:40]
Cloud 3.5は

[22:38 - 22:42]
最新の構造出力機能について何も知らないからです。しかし、

[22:40 - 22:44]
Wind Surfを見ると、

[22:42 - 22:46]
まず

[22:44 - 22:48]
関連する命令部分に移動し、

[22:46 - 22:50]
最新の構文を理解してから、

[22:48 - 22:53]
これをインストールする必要があるかどうかを判断します。これは

[22:50 - 22:55]
bredentです。つまり、

[22:53 - 22:58]
おそらく正しく実装されるでしょう。

[22:55 - 23:00]
次に、

[22:58 - 23:02]
テーブル内のシャーシの使用も試みます。

[23:00 - 23:04]
これの素晴らしい点は、Wierがどういうわけかこれらの

[23:02 - 23:07]
ことをよりよく覚えて、

[23:04 - 23:09]
正しい構文を使用することです。このリリースでは矢印が大幅に少なくなっています。これで、

[23:09 - 23:14]
この機能は完了です。

[23:12 - 23:17]
必要なのは、EMVファイルにOpen AI APIキーを追加するだけです。

[23:17 - 23:22]
これで実行してファイルをアップロードできます。

[23:24 - 23:28]
正しく実装されているか簡単に確認しておきたいので、

[23:26 - 23:30]
データ処理に進むと、

[23:28 - 23:33]
正しいモデルと、

[23:30 - 23:34]
要求した正しい形式が使用されていることがわかります。結果として、

[23:34 - 23:39]
探していたテーブルが表示されました。これは素晴らしいですね。

[23:37 - 23:42]
最後の

[23:39 - 23:45]
部分、つまりファイルのダウンロードを実行させましょう。再び、このパッケージを

[23:42 - 23:47]
インストールするように求められます。

[23:45 - 23:49]
これでこの部分も完了です。アプリケーション

[23:47 - 23:52]
に戻って

[23:49 - 23:54]
ファイルをアップロードし、

[23:52 - 23:56]
抽出を行います。データが

[23:54 - 23:58]
抽出されると、Excelファイルのダウンロード

[23:56 - 24:00]
ボタンが表示されます。これをクリックすると、

[23:58 - 24:02]
結果が適切なExcelテーブルに表示されます。

[24:02 - 24:06]
ご覧のとおり、Wi-Fi Serfは最新の在庫の抽出と参照

[24:04 - 24:08]
に関して非常に優れた仕事をしました。

[24:08 - 24:13]
ラマのパーと

[24:11 - 24:15]
Open AI構造の出力はどちらも

[24:13 - 24:17]
Lar nモデルの知識の一部ではありませんが、

[24:15 - 24:19]
Ride Dogを参照することができました。

[24:17 - 24:21]
最後に、

[24:19 - 24:23]
UI の簡単な修正を少し行いたいと思います。現在の

[24:21 - 24:25]
スタイルは少々退屈に見えましたが、

[24:25 - 24:31]
AI ビルド クラブのコミュニティ メンバー Garrett から学んだことの 1 つは、たとえば vz に移動すると、

[24:27 - 24:35]
v.d Sims を使用してはるか

[24:31 - 24:37]
に優れた UI を制御できることです。

[24:35 - 24:39]
d/s では、同じものをクリックして複製し、

[24:39 - 24:43]
左側でさまざまなスタイルを試すことができます。AI に、必要な特別な同じものを生成させることもできますが、

[24:41 - 24:45]
私の場合は、

[24:43 - 24:47]
この種の Windows 98 タイプのスタイルを使用したいと思います。

[24:45 - 24:50]
完了したら、

[24:47 - 24:53]
コードをコピーして、それらの

[24:50 - 24:56]
コードを 1 つずつ Nextjs プロジェクトに貼り付けることができます。

[24:56 - 25:02]
グローバル CSS であるこの CSS ファイルを貼り付け、次に

[24:59 - 25:04]
レイアウトのフォント ファイルを貼り付けます。

[25:02 - 25:06]
アプリフォルダの下にあるTSと、

[25:04 - 25:08]
ルートフォルダにあるTailing configを実行してみます。

[25:06 - 25:10]
これで実行できます。

[25:08 - 25:12]
矢印がいくつかあるようですが、

[25:10 - 25:15]
フォントの太さを定義する必要があります。

[25:12 - 25:17]
この矢印メッセージを貼り付けるだけです。Wind

[25:17 - 25:21]
Serveの素晴らしい点の1つは、プロンプトを出さなくても、最近

[25:19 - 25:23]
どのような変更を行ったかがわかることです。

[25:23 - 25:26]
そのため、

[25:25 - 25:28]
連絡先が増え、それらの変更を直接修正できます。Windows

[25:28 - 25:34]
98

[25:31 - 25:35]
スタイルのUIがここにあります。もう1つ

[25:34 - 25:38]
試してみたいのは、

[25:38 - 25:42]
既存のPur構造を理解し

[25:40 - 25:44]
、それに新しい機能を追加するという点で、Wind Serveがどれほど優れているかということです。

[25:42 - 25:46]
新しいCascadeを開始します。

[25:44 - 25:48]
連絡先

[25:46 - 25:51]
や過去のチャット履歴がないため、

[25:48 - 25:52]
どのファイルをどこに作成するかがわからないと思います。

[25:52 - 25:57]
コンテキストなしで指示するだけです。アプリはモバイルフレンドリーになります。

[25:57 - 26:02]
ファイルのアップロードUIとスキーマ定義UIを並べて表示し、

[26:00 - 26:04]
星抽出ボタンを

[26:04 - 26:10]
Windowsブルーのプライマリカラーで下部に固定して、何が まず

[26:07 - 26:13]
最初に、

[26:10 - 26:15]
私たちのページを調べて分析します。 メインファイルであるTSXは、

[26:13 - 26:17]
ファイルを分析し、

[26:15 - 26:19]
そこに存在するさまざまなコンポーネントをすべて理解し、

[26:19 - 26:23]
それらを実装する適切な場所を特定しようとします。

[26:21 - 26:26]
アプリケーションに戻ると、プロンプト

[26:26 - 26:30]
なしでUIを変換するだけで、完全に

[26:28 - 26:32]
機能します。これでほぼ完了です。VZの

[26:30 - 26:35]
使用方法

[26:32 - 26:37]
とUI部分の構築方法に興味がある場合は、

[26:35 - 26:40]
Gが実際にAI Builderクラブ内でコースを開講しました。AI

[26:40 - 26:44]
Builder Clubが何であるかわからない場合は、ステップバイステップのチュートリアルとコード例を

[26:46 - 26:51]
使用して、さまざまなAIコーディングとエージェント構築コースを深く掘り下げるコミュニティです。

[26:51 - 26:54]
最も重要なのは、

[26:52 - 26:56]
すでにあなたが直面している問題を経験している可能性のあるトップAIビルダーのグループがいるので、

[26:58 - 27:02]
気軽に質問することができます。

[27:00 - 27:04]
以下の説明にあるリンクをクリックして、

[27:02 - 27:05]
このAIビルドクラブに参加してください。

[27:04 - 27:07]
このビデオを楽しんでいただければ幸いです。これは、

[27:05 - 27:10]
WindServeを使用してアプリケーションを作成する方法の概要です。エージェントをよりコンテキストアウェアにする

[27:07 - 27:13]
ことで、

[27:10 - 27:15]
エージェントをよりコンテキストアウェアにすることができますが、

[27:15 - 27:19]
まだ 一つの

[27:17 - 27:21]
命令を与えるだけで全て解決します

[27:19 - 27:23]
が、コードの品質は

[27:21 - 27:25]
はるかに良くなります。

[27:25 - 27:29]
皆さんがwi serfを使ってどんな面白いヒントやコツを見つけ始めるのかとても楽しみです。Belさん、

[27:27 - 27:30]
何か

[27:29 - 27:33]
面白い洞察があればコメントして共有してください。ありがとうございます。また

[27:30 - 27:33]
次回お会いしましょう。

## コメント

### 1. @AIJasonZ (👍 74)
For people asking if this is an ad for windsurf - it is NOT 😁 No compensation received from Windsurf team, just tried and liked the software

It is sponsored by hubspot though

> **@abdulsamad.abd007** (👍 1): bro, there are new and better AI everyday

> **@numbaeight** (👍 2): @AIJasonZ , very good job on the video!! but bro if you really want to share something, don't say its free while you request to fill up my email address to get it. Just post a direct link to download. otherwise YOU KNOW its not free, PLEASE !!

> **@IamMarcusTurner** (👍 2): Those who watched the video it’s HubSpot sponsored.

> **@koen.mortier_fitchen** (👍 3): @@AIJasonZ It is obviously not sponsored but big news for those that code with ai: Cursor now has competition (it’s not better tho). This starting of competition between real AI IDE’s is in fact quite the milestone.

> **@TheNitroPython** (👍 0): Awww that's the same thing bro lol

### 2. @vveerrgg416 (👍 65)
As a Cursor user ... project context has been the BIGGEST issue with my project work.  NICE FIND ... thank you

> **@wes7bg** (👍 1): yeah this dummy creates new endpoints instead of updating the old ones ! CONSTANTLY !

### 3. @pawanramuk (👍 42)
Dude, I literally take your opinion blindly just seeing the amount of depth you achieve in your videos. Thank you for all that you do and look forward to more of your content! Just an appreciation post

> **@AIJasonZ** (👍 3): I appreciate that!

> **@jessicalewisjessielew3399** (👍 2): I approve and support this message, keep up the good unbiased work Jason

### 4. @Whatismarketingshow (👍 73)
I just tested Windsurf, it could complete areas Cursor has been stuck on. Truly an impressive product. I am switching.

> **@Midnight_Aura** (👍 3): really? time to try, i think.

> **@Its_Zeus_** (👍 0): I was gonna say the same

> **@avi7278** (👍 0): ​@@Whatismarketingshowhe was saying he's going to try based on your recommendation...

> **@olesgamingkanal343** (👍 0): i would recommend cline it seems too be able too delete most of the code in a document thats an issue ive had with this one and just implementation and use of other logic than specified use case noted in other files.

> **@jliby1708** (👍 0): yeah I would say it's prob best on the market.

### 5. @shsunmoon (👍 0)
Honestly you are providing such a valuable content way earlier than most other youtubers, and i can see you have a high standard in quality of information you share:)

### 6. @Suhaybkaofficial (👍 26)
As a cursor ide user for the last 4 5 months and building with great high performance multi tenant apps . I tested windsurf, and I can say it’s time to change 🎉 a great product, 50% cheaper and unlimited Claude sonnet requests ❤

> **@leoingson** (👍 0): Someone wrote 1000. So quarter price in a way.

> **@DreamingConcepts** (👍 0): Any updates on the results? for me it seems that the Cascade doesn't fully update code with the requested changes, it misses both certain areas in files and complete files altogether, even when specifically mentioning them.

> **@leoingson** (👍 1): @@DreamingConcepts It does not figure changes in files (made by cursor, haha), no idea how to refresh index. It seems to rely on what happened in chat, too much?

> **@regallux6973** (👍 0): What's your stand as of now on windsurf do you still think it is better as of today is it still your main ide am thinking of switching from windsurf to corsur main points for switching docs and web the fact that I can give corsur more context so as of today which do you prefer

> **@leoingson** (👍 0): @@regallux6973 Cursor got on par (or better) with agents and yolo mode, at less paid requests (cheaper). Everything else is much better anyway, I'm back with Cursor.

File changes in windsurf: Just open a new chat (cascade or whatever this is called).

### 7. @RichardLierow (👍 3)
Windsurf is out of this world! As mentioned, the most amazing capability, it can do complex app editing really well.

### 8. @silsois (👍 3)
such a good walkthrough. Loved seeing your workflows in-depth. Keep making videos like this 💪

### 9. @Myexpectationsarerealistic (👍 2)
Having use it strictly for about 14 - 17 hours straight.

I can tell you that it's okay at automating boilerplate code, and builds. That's about it.

### 10. @serhiikrechko (👍 0)
Your analysis of AI workflow and Windsurf specifically has been exceptional. Thank you. Can you make more videos about improving prompts  for more accurate results when coding? Some specific cases include brainstorming ideas for implementation, refactoring/reviewing code, bug fixes, etc.

### 11. @krlospatrick (👍 2)
Thanks for sharing your thoughts about Windsurf, it was really helpful

### 12. @ordinarygg (👍 4)
I love this AI stuff, as a penetration engineer this tool is so nice, that will create less educated devs who will bring more and more work for us)

> **@SALAVEY13** (👍 0): itcs like herd immunity - like turtles born same time - you need sleep, can't hack us all!))

> **@marilynlucas5128** (👍 1): keep dreaming. you're almost out of work.lmao

> **@PaperboySilver** (👍 3): I've been a pentester and am an AppSec Engineer ATM and I'd disagree, it tends to fix bugs instead of bitching and moaning about it.

> **@ordinarygg** (👍 0): @ fixing it because you point them or it writes it without bugs?

> **@PaperboySilver** (👍 1): @@ordinarygg the former mostly. I've yet to meet a dev that writes code without bugs on the first try

### 13. @pawanramuk (👍 3)
Thanks

### 14. @uguptuzirby8451 (👍 0)
really great video, packed with useful information, thanks

### 15. @TheSopk (👍 10)
After testing cursor, aider, codeium, and codestory ai, I can give you my own personal opinion:
1/ Aide by codestory is the best, the best context awareness of all, it just does the job
2 / codeium is great, but ask too much questions and sometimes miss context compared to aide by codestory
3/ cursor: bad
4/ aider: ok but worst because high cost, you have to use your own key, and context awareness is not that great

> **@FaceySpacey** (👍 0): really, Aide, the free and open source one is better than Codeium? Is Aide missing anything the others have?

> **@DreamingConcepts** (👍 1): why is Ade's codestoryai twitter account suspended?

> **@jaysonp9426** (👍 0): Lmao, cursor: bad?

> **@NostraDavid2** (👍 0): Windsurf guys also made Codeium, BTW.

### 16. @koen.mortier_fitchen (👍 12)
Wow nice. I am a business Cursor user with a maxed out account (11x €20/month) and have to use api key. So I know the issues here well. Still, it’s the best. Am trying Windsurf now and will post findings in thread…

> **@koen.mortier_fitchen** (👍 5): It takes the lead more, which I like. 

Has only 3 llm models, which makes sense.

In Cursor I use 1. 

Has its own new ‘Cascade Base’ which they put next to 4o and Claude (I need confirmation if it is the 20241022 claude bc this is the best for coding).


It has a lot of themes. Am exploring themes. Nah, dark theme is best.

> **@koen.mortier_fitchen** (👍 0): It can’t read what’s in terminal, which would be a big difference, and is pointing out problems that aren’t actually problems. 
Am gonna ignore that and try to see how good it can build. 
I am doing Flutter project, which is for ios, Android and web apps all in one code. 
Jason is doing just web, which is not for true apps, but more like app-like web applications, which are simpler than so-called ‘native’ real apps. 
Search for ‘what’s the difference between native and web apps’. 
I didn’t know that when I started and it’s important. 
As a beginner it’s really hard.

> **@koen.mortier_fitchen** (👍 5): There is no obvious way to see if it knows my code. In cursor there is a huge difference between enter and command enter. Also command J for resynch codebase is important. Here it is just ‘enter’. Here goes my benchmarking..

> **@koen.mortier_fitchen** (👍 4): HOLY SHT it’s awesome. Using Cascade Base model as opposed to Claude 20241022 which I know how to handle like it’s my dog. But this one is way faster and response is what I wanted. 
Ok for reading codebase and getting it, it is superior. 
Am gonna ask it to build a component. A map and a list and some other stuff. 
As a beginner you’d think that ai can build whole apps but this wastes your time trying that. 
You let it build small pieces. 
Agents are a hoax, believe you me..

Ok curious what it can do for building

> **@koen.mortier_fitchen** (👍 7): Cascade Base model is wild in a bad wide. Messes up your code. Don’t use it. Trying it with Claude now

### 17. @melvinjongen1697 (👍 1)
Gonna try it out tonight 🎉

### 18. @nbvcxz098 (👍 3)
Bro that is the CEO of Codeium, not just some engineer 😅

### 19. @pilesofcash (👍 11)
The overall pricing plan is confusing... they don't say what "Cascade (Read-Only Mode)" means in the free plan, although I imagine it's the same thing but won't be able to edit or add. Also, what does "Cascade (Full, 1000 steps/month) mean in the pro plan? What is a step? How many steps are used per message?

Also, if I don't get unlimited access to Cascade (assuming the 1000 steps/month is similar to tokens but instead is the amount of steps the AI uses in it's flow) why does it say "Unlimited Access to GPT-4o, Claude Sonnet" in the pro plan?

> **@leoingson** (👍 0): There is a chat mode, that does not change the files - read only.

A step is a model request I guess. Here a prompt can mean many request, since self-correcting etc.

> **@DreamingConcepts** (👍 1): I assume the "steps" are are the iterations it does on its own when encounters an error and tries to fix it. If you assume it gets everything right the first time that would mean 1000 messages to Cascade per month. If it takes it 2 attempts on each, that would mean only 500 messages per month.

### 20. @Pablo-px3ct (👍 2)
Cursor and THEO the bought influencer with equity agenda - GAME ON

