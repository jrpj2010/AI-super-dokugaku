# Cursor 1.0: Moving Past The Fork

**チャンネル:** Theo - t3․gg
**公開日:** 2025-06-06
**URL:** https://www.youtube.com/watch?v=NDYLKkd0_mc

## 説明

Cursor 1.0 just dropped. Bugbot, background agents, and more, this is a very interesting release...

Thank you G2i for sponsoring! Check them out at: https://soydev.link/g2i

SOURCE
https://www.cursor.com/changelog

Want to sponsor a video? Learn more here: https://soydev.link/sponsor-me

Check out my Twitch, Twitter, Discord more at https://t3.gg

S/O Ph4se0n3 for the awesome edit 🙏

## 字幕

[00:00 - 00:03]
現時点では、

[00:01 - 00:05]
私がカーソルの大ファンだということは秘密ではありません。

[00:03 - 00:07]
私はしばらくこれを使用しているだけでなく、

[00:05 - 00:08]
実際に投資家でもあります。 面白いことに、私は

[00:08 - 00:12]
それを使うかどうか確信が持てないうちに投資してしまったのです。 当時、私はまだ

[00:10 - 00:14]
VS Code を多用していました。 私は Super Maven の大ファンでした

[00:12 - 00:16]
が、現在 Super Maven は Cursor が所有しています

[00:14 - 00:18]
。

[00:16 - 00:20]
それ以来、その会社がどのように進化してきたかは、ちょっと驚くべきことです。 そして、私だけが

[00:20 - 00:24]
本当に熱烈なファンではないと言ってもいいと思います。 最近見かけるほとんどの人が Cursor を利用しているように感じます

[00:22 - 00:26]
。

[00:24 - 00:28]
最近アンケートを実施したところ、

[00:26 - 00:30]
VS Code ユーザーよりも Cursor ユーザーのほうが多かったことがわかりました。 それは

[00:28 - 00:33]
ちょっとおかしいですね。 特に驚くべきことは、

[00:30 - 00:36]
この間ずっと、私たちが Cursor のベータ版を使用していたことです

[00:33 - 00:38]
。 はい、その

[00:36 - 00:41]
通りです。 まだゼロ

[00:38 - 00:44]
バージョンでした。  050が最新リリースでした。

[00:41 - 00:45]
今日、ついにカーソル 1.0 がリリースされました

[00:45 - 00:50]
。 これは一体何を意味するのでしょうか? どのような新

[00:48 - 00:52]
機能が期待できますか? そして

[00:50 - 00:54]
私たちは何に興奮すべきでしょうか?

[00:52 - 00:56]
私のエディタにその小さなプレビューがここにあります。   バック

[00:54 - 00:57]
グラウンド エージェント、バグボット、Jupyter

[00:56 - 00:59]
ノートブックのサポート、そしてその他、

[00:57 - 01:01]
話す価値があると思われるいくつかのこと

[00:59 - 01:03]
。  Cursor はこれに対して私に一切支払いをしていません

[01:01 - 01:04]
。 彼らは私にこれが起こるとは知らせてさえいませんでした

[01:03 - 01:05]
。 何が起こっているのか分からない

[01:04 - 01:08]
。 最近は投資家向けの最新情報すら得られません

[01:05 - 01:10]
。 そうは言っても、私たちは

[01:08 - 01:11]
請求書を支払う必要があります。 それでは、今日のスポンサーから簡単にお話を伺ってから、

[01:11 - 01:15]
早速始めましょう。AI によって

[01:13 - 01:17]
開発者の作業は大幅に高速化されましたが、

[01:15 - 01:19]
他の役割の作業はいくつか遅くなりました。

[01:17 - 01:21]
特に、AI によって生成されたと思われる大量のジャンク履歴書に目を通さなければならない採用担当者にとっては、採用活動が地獄のような状況になっています

[01:25 - 01:29]
。 ありがたいことに、今日のスポンサーが

[01:27 - 01:32]
この問題を解決するためにここにいます。  G2I を使用すると、

[01:29 - 01:34]
採用が非常に簡単になります。 彼らは本当に

[01:32 - 01:35]
優秀なエンジニアを雇用しています。 私は

[01:34 - 01:37]
彼らの会議に参加しているので、そのことを知っています。  React

[01:35 - 01:38]
Miami は、開発者エコシステム全体の中で私のお気に入りのイベントの 1 つであり

[01:37 - 01:40]
、

[01:38 - 01:42]
それを運営しているのは彼らです。 しかし、

[01:40 - 01:43]
それらはあなたにとって何をしてくれるのでしょうか? そうですね、彼らは、

[01:42 - 01:45]
従来は

[01:43 - 01:48]
リクルーターを雇わなければならなかったことをやってくれますが、それをはるかに上手にやってくれます

[01:45 - 01:49]
。 そしてはるかに速くなります。

[01:48 - 01:51]
ご存知のとおり、採用担当者は

[01:49 - 01:52]
物事に時間をかける傾向があり、

[01:51 - 01:55]
特に彼ら自身が技術に詳しくない場合は、得られる成果の質は高くありません。

[01:52 - 01:56]
G2I は、採用しようとしている人々の技術的スキルを

[01:55 - 01:58]
非常によく審査する技術者集団です

[01:58 - 02:02]
。

[02:00 - 02:04]
彼らにたくさんの質問を送ります。 彼らは、

[02:04 - 02:08]
8,000 人の優秀な採用候補者からなる巨大なプールに質問を送信します。

[02:06 - 02:10]
そして、彼らが質問に答えたビデオ結果が送られてくるので

[02:08 - 02:11]
、それを

[02:10 - 02:12]
見て、最も適していると思う人を選ぶことができます

[02:11 - 02:14]
。 また、

[02:12 - 02:16]
各候補者に対して詳細な技術分析も提供しており

[02:14 - 02:17]
、それぞれの強み

[02:16 - 02:19]
や、

[02:17 - 02:20]
最新の AI ツールに精通しているかどうかなどが示されています

[02:19 - 02:21]
。 したがって、カーソル操作が得意な人を探している場合は

[02:20 - 02:23]
、それを

[02:21 - 02:25]
簡単に見つけることができます。 彼らは

[02:23 - 02:26]
パートタイムでもフルタイムでもサポートしてくれます。

[02:26 - 02:31]
サイトでは、Lattis がモバイル アプリの最初のバージョンをリリースするため

[02:28 - 02:32]
に 2 人の React Native エンジニアを 10 週間雇った方法など、たくさんの素晴らしい事例を見ることができます

[02:32 - 02:35]
。 この例は

[02:33 - 02:37]
本当に素晴らしいです。なぜなら、G2I は基本的に

[02:35 - 02:38]
数週間の間 Lattis 内の子会社となり、

[02:38 - 02:42]
Slack を共有し、毎日スタンドアップを実施し、契約チーム

[02:41 - 02:44]
に期待されるすべてのことを行ったからです

[02:42 - 02:45]
。 今日のビデオのスポンサーとなった G2I に心から感謝します

[02:44 - 02:47]
。

[02:45 - 02:49]
今すぐ

[02:47 - 02:52]
swwayv.link/2i でチェックしてください。  1.0 の新機能は何ですか

[02:49 - 02:55]
? 誰でも Bugbot バックグラウンド エージェントにアクセスでき

[02:52 - 02:57]
、MCP をワンクリックでインストールできます。

[02:55 - 03:00]
これはかなりクールなセットであり、

[02:57 - 03:02]
特に Bugbot は

[03:00 - 03:04]
カーソルの将来の戦略がどの

[03:02 - 03:06]
ようなものになるかを実際に示しています。 ただし、これについては後ほど説明します。

[03:04 - 03:09]
他の部分は、

[03:06 - 03:11]
Jupyter ノートブックのエージェントのような少し単純なもので、Jupyter ノートブックのユーザーで

[03:09 - 03:13]
あれば最も簡単に説明できます

[03:11 - 03:15]
。

[03:13 - 03:16]
Jupyter ノートブック スタイルのファイルを使用してエージェント作業を処理できるようになりました

[03:15 - 03:18]
。

[03:16 - 03:20]
研究者やデータ関連の仕事をする人にとっては素晴らしいです。

[03:18 - 03:22]
おそらく皆さんにはあまり関係ないと思います

[03:20 - 03:24]
。 また、Sonnet でのみ動作します

[03:22 - 03:26]
。 彼がそれを出荷するのを見るのはクールだ。

[03:24 - 03:29]
思い出はとても興味深い変化です。

[03:29 - 03:33]
カーソルをプロンプトしているときに何かを表示すると、その

[03:31 - 03:35]
下に小さなものが表示され、

[03:33 - 03:38]
何かを何度も表示したり、

[03:35 - 03:39]
より具体的な言語で言ったりすると、自動的に更新されます

[03:38 - 03:42]
。 開発サーバーを起動するときと同様に

[03:39 - 03:44]
、サーバーはホットリロードされるため再起動せず

[03:42 - 03:46]
、その詳細を記憶します

[03:44 - 03:48]
。 メモリはますます重要な問題になってきているようです

[03:46 - 03:50]
。 個人的には、

[03:48 - 03:53]
メモリ製品の用途はまだあまり見出せていません

[03:50 - 03:55]
。 それはちょっと嘘です。 実際、私は

[03:53 - 03:57]
Code Rabbit で何かを修正するときのメモリが非常に気に入っています

[03:57 - 04:01]
。 だから、Code Rabbit が PR に来て、私たちが

[04:04 - 04:08]
実際には気にしていない、または私たちには関係のない何かをやめるように、あるいは何かを避けるように指示してきたら、

[04:05 - 04:09]
私はこう言います。「おい、Code Rabbit、

[04:08 - 04:11]
失せろ。そんなことをしないように言うのはやめろ

[04:09 - 04:12]
」 そして、ほとんどの場合、それに

[04:11 - 04:15]
応じて調整するのは非常に迅速であり、

[04:12 - 04:16]
それは本当に素晴らしいことです。

[04:15 - 04:19]
ただし、メモリを使用するのはそこだけです。

[04:16 - 04:21]
チャット GPT で使用したとき、ただイライラしました。

[04:19 - 04:23]
しかし、おそらくすぐにこれを T3 チャットに統合する必要があります

[04:21 - 04:25]
。 カーソルのようなものでの使用が考えられます

[04:23 - 04:27]
。

[04:25 - 04:28]
カーソルに何かを伝えるとどんな感じになるのか、

[04:27 - 04:30]
そしてカーソルが

[04:28 - 04:32]
それを実際に記憶し続けるかどうかを見るのが楽しみです。 しかし、調べる方法は1つしかありません

[04:30 - 04:34]
。 使わなきゃ。  MCP

[04:32 - 04:36]
関連のものは特に興味深いです。

[04:34 - 04:39]
なぜなら、標準規格が

[04:36 - 04:40]
ものすごく急​​速に成長しているように見えるからです。

[04:39 - 04:43]
奇妙なことに、私はまだ MCP の用途をあまり見つけていません

[04:40 - 04:46]
。 個人的には、

[04:43 - 04:48]
数日前に最初の MCP をインストールしたばかりです

[04:46 - 04:50]
。 私は最近、Context 7 を追加しました。

[04:48 - 04:53]
これは、

[04:50 - 04:55]
Josh を含む Upstash の人たちが開発した優れたツールです。

[04:53 - 04:57]
いい仲間だよ。 とても

[04:55 - 04:58]
とても役立ちそうです。 そして、

[04:57 - 05:01]
私よりも賢いと思われる多くの人々が、

[04:58 - 05:05]
Context 7 がいかに便利かを語っています。  Context

[05:01 - 05:07]
7 は、LLM のドキュメント MCP です。 したがって、

[05:05 - 05:09]
Context 7 を指定して名前を付けると

[05:07 - 05:11]
、通常は

[05:09 - 05:14]
適切なドキュメントを見つけて

[05:11 - 05:16]
エディターに統合できるほどスマートになります。 これで、

[05:14 - 05:18]
その物を適切に使用する方法がわかりました。

[05:16 - 05:20]
特に、探してエディターに組み込む必要がある

[05:18 - 05:22]
奇妙な LLM テキスト ファイルと比較すると、非常に便利です

[05:22 - 05:25]
。

[05:24 - 05:27]
適切なコンテキストを少し効率的に取得できる MCP があると便利です

[05:25 - 05:29]
。 しかし、私

[05:27 - 05:30]
自身はまだ他のユースケースをあまり見つけていません

[05:29 - 05:31]
。 変化する可能性は高いです

[05:30 - 05:34]
が、変化しない可能性も高いです

[05:31 - 05:35]
。 今後どうなるか見てみましょう。

[05:34 - 05:37]
皆さんの

[05:35 - 05:39]
お気に入りの MCP ユースケースをコメント欄で教えてください。

[05:37 - 05:40]
今後、さらに多くのユースケースを検討させていただきます。

[05:39 - 05:43]
これもまた本当にクールなものです。

[05:40 - 05:44]
彼らはチャット体験を全面的に見直しています。

[05:43 - 05:46]
つまり、単にテキストを吐き出し、

[05:44 - 05:48]
時々コードの差分を出力するだけではありません。

[05:46 - 05:50]
図表などを表示できるようになりました。

[05:48 - 05:53]
クリックすると全画面表示になります。

[05:50 - 05:56]
実際に、

[05:53 - 05:59]
何らかのデータから取得した項目のテーブルを表示することもできます。 私は視覚化を生成するために、

[05:56 - 06:01]
巨大な JSON ファイルを cursor や v 0 などのツールに定期的にダンプします

[06:01 - 06:05]
。 そして、実際に私が「はい」と言う前に、

[06:05 - 06:08]
どのように再フォーマットされるかを示すためにログの一部をそこに置くというアイデアは、

[06:08 - 06:12]
かなり便利そうです。 ダッシュボードも設置しました。

[06:10 - 06:17]
私は実のところこれにとても興奮しています。

[06:17 - 06:20]
カーソルによってどの程度のコードが編集されたのか、自分で確認してみます。 それが

[06:19 - 06:23]
私にとって十分に最新のものであるかどうか興味があります

[06:20 - 06:24]
。 実際に私がどれくらいの量のコードを

[06:23 - 06:26]
いつ書いたかを確認できます

[06:24 - 06:30]
。  5 月 30 日は、私が行った安全性ベンチマークのコードの大部分を書いた日です

[06:30 - 06:34]
。 つまり、そこに大きなスパイクがあるのです。

[06:32 - 06:37]
そして、他のすべてはより伝統的な

[06:34 - 06:39]
日々です。 今週は

[06:37 - 06:42]
言葉では言い表せないほど忙しかったです。 つまり、それ以下です。

[06:39 - 06:45]
もっと大きなウィンドウに拡大できますか

[06:42 - 06:50]
? それは面白いですね。 どうやら、

[06:45 - 06:51]
22日に大量の AI コードを書いたようです。

[06:50 - 06:53]
これを見ると面白いですね。T3

[06:53 - 06:57]
チャットのオーバーホールのために書かなければならなかったコードのほとんどは、

[06:57 - 07:02]
AI がコード生成にあまり向いていなかったために生成されなかったと何度か言及したからです。 そして

[07:00 - 07:04]
これがそれを示しています。 しかし、

[07:02 - 07:07]
タブ補完について見てみると、確かにこれは

[07:04 - 07:09]
まったく違う話だということがわかると思います。 私にとって、

[07:07 - 07:11]
これら 2 つのグラフがいかに異なっているかというのは実に面白いことです

[07:09 - 07:12]
。 エージェントコードでは、

[07:11 - 07:14]
数日に急増することがあります

[07:12 - 07:16]
が、ほとんどの場合、

[07:14 - 07:19]
エージェントにコードをそれほど多く書かせていません。 しかし、

[07:16 - 07:22]
タブ側では、タブ補完を常に行っています。

[07:19 - 07:24]
5月10日にタブが200個完了しました。 それは

[07:22 - 07:27]
面白いですね。 それは実に面白いですね。

[07:24 - 07:29]
でも、そうですね、私はタブ補完をよく使います。

[07:29 - 07:33]
カーソル セクションのチームに Open AI があるのはちょっと面白いです。OpenAI

[07:31 - 07:35]
の従業員数名がそれを使用しているからです。 これは

[07:33 - 07:37]
面白い。特に、

[07:35 - 07:39]
OpenAI が買収するかもしれない、あるいはしないかもしれない企業に関する最近のニュースを考えると、面白い

[07:37 - 07:41]
。 それらは単純なことでした

[07:39 - 07:43]
。 大きな一握りを見てみましょう。   バック

[07:41 - 07:46]
グラウンドエージェントは最大のものの1つです

[07:43 - 07:47]
。

[07:46 - 07:49]
近い将来、

[07:47 - 07:52]
AI コーディング支援のさまざまなタイプを分類するビデオを作成する必要があると思います。

[07:49 - 07:54]
なぜなら、歴史的に、

[07:52 - 07:56]
カーソルは

[07:54 - 07:58]
私が副操縦士

[07:56 - 08:01]
エクスペリエンスと呼んでいたものに焦点を当ててきましたが、それがますます独自のものになってきているように感じるからです

[08:01 - 08:04]
。 また、副操縦士という用語は、

[08:07 - 08:11]
カーソルが元々は主に

[08:09 - 08:13]
タブ補完のようなものとして始まり、その後、

[08:18 - 08:21]
ファイル内で何かを実行するように指示するとそれを実行するインライン エディター フローのようなコマンド K が使用されるようになってから、少し複雑になったと私が言っていた意味とは異なるさまざまなことに使用されています。

[08:20 - 08:24]
私は実はまだこれがとても好きです。 私は

[08:21 - 08:27]
よく、セクション コマンド K を強調表示して、

[08:24 - 08:29]
代わりにこれを実行させるように指示します。 そして、

[08:27 - 08:30]
私の編集のかなりの部分が

[08:29 - 08:32]
まだこのようになっていることに気づきました。 また、

[08:30 - 08:35]
私が使用しているモデルが 4.1 であることに気付いたかもしれません

[08:32 - 08:37]
。 物事をただ終わらせたいだけの

[08:35 - 08:39]
簡単な編集などには、非思考モデルの方が適していると思います

[08:37 - 08:42]
。

[08:39 - 08:44]
しかし、ここではほとんど裂け目があるようです。

[08:42 - 08:47]
私が考えている階層化は、

[08:44 - 08:50]
すべてのコードを自分で記述する最低レベルのようなものです

[08:47 - 08:52]
。 そしてここの上部は

[08:50 - 08:54]
完全にバイブコード化されていますが、それはスペクトルです。

[08:52 - 08:56]
自分でコードを書いた後の次のステップは、

[08:54 - 08:58]
明らかにタブ補完です。 つまり、まだ

[08:56 - 09:00]
自分でコードを書いているのですが、

[09:00 - 09:04]
何か他のことをする意欲を起こさせるための小さなタブが完成すると、それが

[09:01 - 09:06]
そこに表示されます。 次のステップは、

[09:04 - 09:09]
先ほど示したコマンド + K フローです。

[09:06 - 09:11]
これは、

[09:09 - 09:13]
ファイルに移動し、

[09:11 - 09:17]
テキストを選択して、

[09:13 - 09:20]
AI に変更を加えるように指示するインライン プロンプトです。

[09:17 - 09:22]
次のステップはエージェントです。 これは

[09:20 - 09:24]
私が体験したコマンドです。

[09:22 - 09:26]
異なるファイルにタグを付け、異なるコンテキストにタグを付けて、

[09:24 - 09:28]
「この

[09:26 - 09:32]
変更を加えるか、計画を立てるか、

[09:28 - 09:34]
計画を立てるのを手伝ってもらうか」と指示します。 これは、

[09:32 - 09:35]
AI にさらに多くの処理を実行させ

[09:34 - 09:39]
、プロセスのより多くの部分を AI に引き継がせるための、より深いステップです

[09:35 - 09:42]
。 次に、バックグラウンドエージェントがあります

[09:39 - 09:44]
。 これは、私が

[09:42 - 09:46]
何かをするように指示し、それが実行されるのを見守らない場合です

[09:44 - 09:48]
。

[09:46 - 09:50]
他の作業をしている間、バックグラウンドで実行させます。

[09:48 - 09:52]
私の場合、やっていることはメールを送ったり

[09:50 - 09:54]
コンテンツを計画したりすることですが、ほとんどの開発者にとっては、

[09:54 - 09:59]
代わりに他の開発作業に取り組んだり、Slack にミームを投稿したりすることになると思います。

[09:56 - 10:00]
現実的に考えてみましょう。 そして、バックグラウンド エージェント プラス +

[09:59 - 10:03]
以外にこれを何と呼べばいいのかさえわからないものもあります

[10:00 - 10:05]
。

[10:03 - 10:07]
非常に似ているため、

[10:05 - 10:11]
このように区別するのは奇妙に感じますが、これは Slack でのことです

[10:07 - 10:14]
。 ボットにタグを付けて、「ちょっと、

[10:11 - 10:16]
ここに来て、この変更をしてください

[10:14 - 10:18]
」と言います。 そして、あなたに代わってプル リクエストを提出します

[10:16 - 10:21]
。 これら 2 つの方法の間にはギャップがあると思います。1

[10:18 - 10:23]
つは、

[10:21 - 10:26]
ファイルを直接タグ付けすることによってコード エディターで実行され、もう

[10:23 - 10:28]
1 つは完全に

[10:26 - 10:30]
抽象化されています。さらに、

[10:28 - 10:32]
vibe coded があり、これは UI 内で

[10:30 - 10:33]
必要なものを記述するだけで、

[10:32 - 10:36]
コードを見る必要さえありません。   バック

[10:33 - 10:41]
グラウンド エージェント ++ には、Devon

[10:36 - 10:44]
や新しい Codeex、Codex Web アプリ、

[10:41 - 10:46]
Slackbot などがありますが、

[10:46 - 10:52]
歴史的には Claude

[10:49 - 10:54]
Code や Codeex CLI などであった、より伝統的なバックグラウンド エージェントもあります。これらは、

[10:52 - 10:55]
エージェントとバック

[10:54 - 10:57]
グラウンド エージェントの中間に位置するものです。なぜなら、これを

[10:55 - 11:00]
実行して

[10:57 - 11:02]
他の作業を行う人がたくさんいることを知っているからです。また、

[11:00 - 11:03]
実際に変更が行われて

[11:02 - 11:05]
いるかを見ている人もたくさんいます。

[11:03 - 11:06]
これは中間の奇妙な存在です。 だからこそ、

[11:05 - 11:08]
ここで境界線を定めることは私にとって難しいのです。

[11:06 - 11:10]
分かりました。 こういったタイプのものの大きさについて、ビデオ全体を作る必要があります。

[11:10 - 11:14]
なぜなら、開発

[11:12 - 11:16]
の範囲のどのポイントに

[11:14 - 11:18]
ツールが当てはまるかという問題もあるからです。

[11:16 - 11:20]
コードラビット

[11:18 - 11:22]
とカーソルの違いは大きいです。 そして、彼らは

[11:20 - 11:24]
これにも取り組んでいます。

[11:24 - 11:28]
今日発表された他の機能の 1 つに、Bugbot を使用した自動コード レビューがあります。これは、

[11:28 - 11:32]
GitHub に実際にコメントを残し、クリックするとカーソルが戻って、壊れたものを修正するように自動的に促す

[11:30 - 11:33]
小さな修正カーソル ボタンが表示されます

[11:39 - 11:43]
。 ちょっとクレイジーだね。

[11:43 - 11:47]
ここで行われている変更については、考えるべきことがたくさんあります。 ただし、バックグラウンド エージェント フローを試してみたいと思っています

[11:45 - 11:49]
。 これ、

[11:47 - 11:51]
かっこいいですね。 重要な注意点の 1 つは、

[11:49 - 11:53]
プライバシー モードを使用しているユーザーの場合、

[11:51 - 11:56]
まだプライバシー モードを使用できないことですが、

[11:53 - 11:59]
近い将来に設定できるようになる予定です。 私にとって、

[11:56 - 12:01]
コマンド E は単なる別の検索です。 ああ、

[11:59 - 12:03]
また、サイドバーのオン/オフを切り替える

[12:01 - 12:05]
ためのデフォルトのホットキーとして、すべてのアプリでコマンド+シフト+E を設定しました。

[12:05 - 12:10]
これまでこれを使用したものは他になかったからです。

[12:07 - 12:13]
Zen では、サイドバーを開いて閉じることになります。 カーソル内には

[12:10 - 12:14]
、私の Openlo サイドバーがあります。

[12:13 - 12:16]
他にもいくつかのアプリをプログラムしました。

[12:14 - 12:18]
ですから、衝突が起きないことを願います

[12:16 - 12:22]
。 ここでバックグラウンドエージェントはオプションですか

[12:18 - 12:26]
? いいえ。 私にはそれがないだけでしょうか? ああ、

[12:22 - 12:30]
プライバシーモードが有効になっていると表示されます。 ああ、

[12:26 - 12:32]
そうだ。 デモではこれをオフにすればよいのでしょうか?

[12:30 - 12:35]
カーソルにここでコードを表示するかどうかはわかりません

[12:32 - 12:37]
。 ヨロしてやろうと思う。

[12:35 - 12:41]
その決断を後悔することにならないことを祈ります

[12:37 - 12:42]
。 カーソル、ファンとして、友人として、

[12:41 - 12:44]
そして投資家として、あなたには

[12:42 - 12:49]
私のクソ T3 チャット コードに触れる権限はありません

[12:44 - 12:51]
。 とにかく、ここに安全スクリプトのリポジトリがあります

[12:49 - 12:54]
。 これは

[12:51 - 12:56]
私が作成した snitchbench のリポジトリです。 バックグラウンドエージェントを有効にします

[12:54 - 12:57]
。 バックグラウンド エージェントはクラウドで実行される

[12:56 - 12:59]
ため、エージェントは

[12:57 - 13:00]
コードベースで非同期的に動作できます。

[12:59 - 13:02]
セキュリティ上の重要な影響がいくつかあります

[13:00 - 13:05]
。 詳細についてはドキュメントをお読みください

[13:02 - 13:06]
。 コードは AWS インフラストラクチャ内で実行されます。バック

[13:06 - 13:11]
グラウンド エージェント用にセットアップされているためです。ほとんどのエージェントと同様に、

[13:11 - 13:17]
クラウド内で実際の VM が実際に起動され、

[13:15 - 13:20]
人間が

[13:17 - 13:22]
CLI でコマンドを呼び出して

[13:20 - 13:24]
変更を加えるのと同じようにコードが実行されます。

[13:22 - 13:26]
これらのバックグラウンド エージェントが機能する方法は、

[13:24 - 13:27]
クラウド内に

[13:26 - 13:30]
リモート開発環境とほぼ同じような VM をセットアップするが、実際に

[13:27 - 13:31]
開発を行うのは自分ではない、というようなものです。 代わりに、Devon

[13:30 - 13:33]
や Curser、あるいはその他の

[13:31 - 13:35]
バックグラウンド エージェント会社が

[13:33 - 13:39]
それを実行します。 正直言って、

[13:35 - 13:41]
OpenAI、Cursor、Devon が、CLI の作成に忙しすぎ

[13:39 - 13:42]
て、開発会社の Anthropic よりも先に

[13:41 - 13:44]
この作業を行ったというのは、ちょっとおかしいです

[13:42 - 13:48]
。

[13:44 - 13:52]
それが現実さ。 まだ試してみたい

[13:48 - 13:55]
。 おそらく後悔することになるだろう。

[13:52 - 13:57]
snitchbench の変更に面白いことを思いついて、

[13:55 - 13:59]
それがうまく

[13:57 - 14:01]
適用されるかどうかを確認してみました。

[14:01 - 14:04]
シャットダウンするように指示されたときに LLM にシステムの制御を委ねる別のテスト セットを作成します。

[14:04 - 14:07]
シャットダウンの強度を高める 4 つのプロンプトを作成し、

[14:05 - 14:08]
これが起こる現実的なシナリオを考え出します

[14:07 - 14:10]
。

[14:10 - 14:14]
モデルが利用可能なツールを使用してシャットダウンを防止しようとしたかどうかを確認するために、出力を分析する方法を必ず含めてください

[14:12 - 14:16]
。 したがって、これ

[14:14 - 14:19]
によってインデックス フィールド内に新しいテスト シナリオが作成されます

[14:16 - 14:21]
。 新しい

[14:21 - 14:26]
テスト ケースを含む新しいディレクトリを作成し、

[14:24 - 14:27]
分析ファイルを変更するか、

[14:26 - 14:30]
新しいファイルを作成する必要があります。

[14:30 - 14:34]
これらのバックグラウンド エージェント ツールを設定するのにかかった時間は、実際に節約できた時間よりはるかに長かったです

[14:32 - 14:35]
。

[14:34 - 14:37]
公平に言えば、私は

[14:35 - 14:39]
まだそれらの 1 つからコードをマージしていないため、時間の節約にはなりませんでした

[14:37 - 14:42]
。 これらがよいものになる可能性はあると私は信じています

[14:39 - 14:45]
。 しかし、私の経験からすると

[14:42 - 14:47]
、

[14:45 - 14:48]
従来のエージェントをエディター内、または

[14:47 - 14:50]
少なくとも CLI 内で実行して、エージェントの

[14:48 - 14:53]
動作を監視し、開発環境を使用する方がまだよいと思います

[14:50 - 14:55]
。 そうは言っても、

[14:55 - 14:59]
2 つのことを同時に実行できるように、git 作業ツリーのようなものをローカルに設定したいと思っていました

[14:57 - 15:02]
が、

[14:59 - 15:04]
それをクラウド環境に置きたくありませんでした。

[15:02 - 15:06]
私の環境にもそれが欲しいです。

[15:04 - 15:09]
自分のシステム上でそれを制御したいのです。

[15:06 - 15:10]
それでも、状況は変わっていくだろうと思いましたが、

[15:09 - 15:11]
同時に、

[15:11 - 15:16]
OpenAI の codeex と

[15:14 - 15:17]
Devon の両方でこの環境を動作させようと苦労した後では、得られた結果

[15:17 - 15:23]
に非常に不満だったため、ビデオを作成するほどの成果も得られませんでした

[15:19 - 15:24]
。 おお、どうやら

[15:23 - 15:27]
彼らは、

[15:24 - 15:30]
複数のタスクを一度に起動できる何かを開発しているようです

[15:27 - 15:32]
。 ここでの私の懸念は、

[15:32 - 15:36]
競合するファイル内であったり、

[15:34 - 15:38]
類似のものに触れる複数の類似のことを実行したりする場合にどのように処理されるかということです。 たとえば、

[15:36 - 15:41]
異なるブランチを作成して同時に編集することはできますか

[15:38 - 15:42]
?

[15:42 - 15:45]
カーソル用にこのようなものを実現しようとしているのはすばらしいことですが、

[15:44 - 15:48]
すべてが機能するまでには少し時間がかかり

[15:45 - 15:50]
、Git 側では困難が伴います。

[15:48 - 15:51]
正直に言うと、私が

[15:50 - 15:53]
ますます考えるようになったのは、これらの多くのこと

[15:51 - 15:55]
について間違ったプリミティブを取得しているように感じるということです

[15:53 - 15:56]
。 マージ競合が

[15:55 - 15:58]
発生するとすぐに間違ったプリミティブを取得し、

[16:02 - 16:06]
部分ごとに変更しようとしているときに部分的なマージ競合を合理的にコミットできないことに気付きます。

[16:08 - 16:12]
T3 チャットの書き換えのために、クレイジーなマージ競合解決を実行しなければならなかったときほど、苦労したことはありません。

[16:10 - 16:16]
2 人のエージェントに実行させようとしましたが、

[16:12 - 16:18]
どちらも半分くらいしか実行できず、必要な

[16:16 - 16:19]
部分をコミットできず、

[16:18 - 16:23]
保管していない部分を無視して、希望どおりに

[16:19 - 16:24]
終了することができませんでした。どうやら

[16:23 - 16:26]
執事は

[16:24 - 16:29]
この作業が得意のようです。 もっと詳しく見るべきです

[16:26 - 16:32]
が、機会がありませんでした。 どうやら

[16:29 - 16:36]
これを修正するにはエディターをリセットする必要があるようです。

[16:32 - 16:38]
いいね。 見てみましょう。 今なら動作しますか? いいえ。

[16:36 - 16:41]
これは私の経験です。 バック

[16:38 - 16:43]
グラウンドエージェントを使って何かを設定しようとするたびに

[16:41 - 16:46]
、まったくうまく動作しないのです

[16:43 - 16:48]
。

[16:46 - 16:50]
これがうまく動作して、何か良いことがあれば、将来更新する予定です。

[16:48 - 16:52]
しかし、現時点では、バックグラウンド

[16:50 - 16:56]
エージェントはまだ初期段階なので、

[16:52 - 16:57]
それが機能するのを見たことはありません。  AGI がそんなに

[16:56 - 17:00]
優れているのなら、なぜ誰もそれを理解できないのでしょうか

[16:57 - 17:01]
?

[17:00 - 17:03]
残念なことに、

[17:01 - 17:06]
バグ ボットのものも見たかったのですが、

[17:03 - 17:08]
それが動作しない場合は見ることができるかどうかわかりません。

[17:06 - 17:10]
しかし、この部分も見ていて本当に面白いです。

[17:08 - 17:12]
なぜなら、AI コード

[17:10 - 17:13]
レビューは実は AI の最適な使用例の 1 つであることがわかったからです

[17:13 - 17:17]
。 私が経験したすべての苦痛が、

[17:17 - 17:21]
私の投資が偏りすぎていて

[17:19 - 17:24]
物事を合理的にカバーできないと考えている人たちに、そのことを証明するのに役立つことを願っています。

[17:21 - 17:26]
カーソルに問題がある場合は、カーソル全体を酷評します。

[17:24 - 17:29]
そして、デモでまったく動作させることもできない状態で、バックグラウンド エージェントを 1.0 として出荷したなんて信じられません

[17:30 - 17:36]
。 それはちょっと

[17:33 - 17:39]
狂ってるよ。 チームを尊敬しているが

[17:36 - 17:41]
、あれは一体何だったんだ

[17:39 - 17:43]
？ とにかく、実際には、

[17:41 - 17:45]
組織に対してのみ有効にして

[17:43 - 17:46]
、

[17:45 - 17:47]
個人用のアプリを有効にしていなかった可能性がありますが、その場合はエラーが表示されるはずです

[17:47 - 17:52]
。 問題はまた別の機会に。 私が

[17:49 - 17:53]
Bugbot についてお話ししたいのは、AI

[17:52 - 17:55]
コード レビューが、

[17:53 - 17:57]
AI コード全般にとって、実際に最も魅力的な使用例の 1 つであることがわかったからです

[17:55 - 17:58]
。 私はそれから多くの恩恵を受けました

[17:57 - 18:00]
。  Code Rabbit は

[17:58 - 18:03]
私たちにとって素晴らしいものでした。  Graphites Diamond も本当に

[18:00 - 18:06]
素晴らしいです。 私の経験から言うと、GitHub 内で直接 Copilot のレビューを行うことは

[18:03 - 18:08]
あまり良くありません

[18:06 - 18:11]
。 正直言って、

[18:08 - 18:12]
GitHub はコード レビュー プラットフォームであるにもかかわらず、この特定の競争に負けたのは不合理です

[18:12 - 18:16]
が、確かに負けました。

[18:14 - 18:18]
他の人は皆、彼らよりもずっとうまくやっています

[18:16 - 18:20]
。 しかし、少なくとも、

[18:18 - 18:21]
AI によるコード レビューは、

[18:20 - 18:24]
役に立つとは思っていませんでしたが、後に

[18:21 - 18:26]
なって非常に役に立つことがわかりました。

[18:24 - 18:28]
コード レビューが役立つ理由の大きな部分は、

[18:26 - 18:30]
別の人の目でコードを確認し

[18:28 - 18:33]
、

[18:30 - 18:36]
見落としている可能性のある点を見つけられることです。 こうすることで、他の人がコードレビューを行うときに、

[18:33 - 18:39]
他の人の時間をそれほど無駄にしていないように感じられ、

[18:39 - 18:43]
誰かにコードを見るように頼むのもそれほど悪い気がしなくなります

[18:40 - 18:45]
。  AI がそれを読み取って問題を発見し、

[18:43 - 18:47]
私がそれを修正したら、

[18:45 - 18:49]
それが十分な状態であることを確認するために自分で一度読み直します

[18:47 - 18:51]
。 その後、

[18:49 - 18:52]
レビューのためにチームに引き渡すと、その作業に対する私の悪い気持ちは軽減され、チームも、

[18:54 - 18:57]
探して

[18:55 - 18:59]
細心の注意を払わなければならなかったくだらないバグのために時間を無駄にすることがなくなります。

[18:57 - 19:02]
AI が喜んでその作業に取り組めば、こうしたことが起こる可能性はずっと低くなります

[18:59 - 19:04]
。

[19:02 - 19:05]
AI コード レビューが、構文エラーや順序が乱れた愚かなステートメントなど、通常探している愚かな部分を検出できれば、人間によるコード レビューはより優れたものになります

[19:10 - 19:14]
。 本当に

[19:12 - 19:17]
よかったですし、とても気に入っています。 それで、

[19:14 - 19:18]
カーソルがそうする理由が分かります。

[19:17 - 19:21]
ダークモードがあることにも気づきました。

[19:18 - 19:22]
以前にそうしなかったことをお詫びします。

[19:21 - 19:25]
このすべてが表すもう一つのことは、

[19:25 - 19:29]
ここで再び垂直スペクトルに戻ると、

[19:27 - 19:31]
私が描いていない水平スペクトルもあることを思い出してください。

[19:29 - 19:33]
それは別のビデオになります。

[19:31 - 19:36]
この後、

[19:33 - 19:38]
サイクルのどの時点でこれらの

[19:36 - 19:40]
さまざまなものを使用しているかを撮影するかもしれません。 そして、

[19:38 - 19:43]
カーソルは両方向に拡大しようとしているようです

[19:40 - 19:46]
。 彼らは、

[19:43 - 19:48]
コーディングとコードプロセスのさらなる強化に取り組んでいます。

[19:46 - 19:49]
これは大きな変化です。なぜなら、

[19:48 - 19:52]
これらはもはや、私たちがミームで呼んでいた単なる VS Code フォークではないからです

[19:49 - 19:53]
。

[19:53 - 19:58]
カーソル 1.0 で最も大きく変わったのは、カーソル自体ではないさまざまなものが追加されたことです

[19:56 - 20:00]
。 そして、

[19:58 - 20:01]
先ほど見たリオのツイートにも、

[20:00 - 20:03]
同じようなことが書いてありました。 皮肉にも、彼らはカーソルの外でこれらすべてのことを行っているので、

[20:01 - 20:06]
私たちはカーソルのことを忘れていません、と

[20:07 - 20:11]
。  Bugbot には

[20:10 - 20:13]
7 日間の無料トライアルが付属しているため、

[20:11 - 20:14]
カーソル サブスクリプションの一部としては含まれません

[20:13 - 20:15]
。 これは完全に別の製品のようなものです

[20:15 - 20:19]
。

[20:17 - 20:22]
面白い。 正直なところ、

[20:19 - 20:24]
ここで提供している最大の機能は

[20:22 - 20:26]
固定ボタンとカーソル ボタンのようですが、

[20:24 - 20:28]
他の人もそれを追加すると思います。 実際、

[20:26 - 20:30]
Code Rabbit には、PR で何かにフラグが付けられたときにコピーできる小さな機能がすでに用意されており、それをコピー

[20:30 - 20:35]
して

[20:32 - 20:37]
エディターに貼り付けると、

[20:35 - 20:40]
修正を求めるプロンプトが表示されます。 ここでは、

[20:42 - 20:46]
タイトルをハードコーディングするのではなく、デフォルトの変数を作成することを提案しています。 そして、AI エージェントのプロンプトが表示され、ワン

[20:44 - 20:49]
クリックでコピーし、

[20:46 - 20:51]
エディターに戻ってコマンド I を押し、貼り付けて

[20:49 - 20:53]
入力すると、理論的には、

[20:51 - 20:55]
作業を完了するのに十分なコンテキストが得られます。

[20:53 - 20:56]
かなりクールですね。 これを見たときは驚きました。

[20:55 - 20:57]
ああ、これは実はちょっと

[20:56 - 21:00]
いいなと思いました。 そしてそれがいかに役に立つかが分かりました

[20:57 - 21:02]
。 これをワンクリックで

[21:00 - 21:06]
自動入力できるようにした方が、

[21:02 - 21:08]
貼り付ける「戻る」コマンドをクリックするよりも良いと思いますが、

[21:06 - 21:11]
それだけでは

[21:08 - 21:14]
完全に新しい製品を

[21:11 - 21:18]
一から作る理由としては不十分です。 それについては、あまり興奮していない

[21:14 - 21:19]
。 それはとても興味深いことであり、それがカーソル 1.0 ドロップ

[21:18 - 21:21]
から私が得た最大の成果です

[21:19 - 21:24]
。 これは、

[21:21 - 21:26]
カーソルでさえ、VS Code フォークであることだけでは

[21:24 - 21:28]
不十分であり、

[21:26 - 21:32]
他のことを探求する必要があると考えていることを示しています。 そして、

[21:28 - 21:34]
1.0 での

[21:32 - 21:37]
数字の変更の意味は、カーソルが

[21:34 - 21:39]
最終的に安定したということではないと私は主張します。 カーソルが

[21:37 - 21:41]
十分に安定し、

[21:39 - 21:43]
探索やその他の作業を開始する準備が整いました。

[21:41 - 21:45]
そして私にとって、それがこのリリースが

[21:43 - 21:47]
意味するものです。 そして、

[21:45 - 21:50]
この変更ログ投稿が行われた時点でカーソル

[21:47 - 21:53]
1.0 がここにあったというのは、ちょっと面白いことです。 リストの最初の 2 つの機能は、

[21:50 - 21:55]
実際にはカーソル機能ではありません。

[21:53 - 21:57]
これはカーソルからトリガーできます

[21:55 - 22:01]
が、Slack からトリガーすることもできます。

[21:57 - 22:05]
これは機能によるものではなく、API によるカーソル機能です

[22:01 - 22:06]
。 これは、Cursor が、ひどい金額を稼いでいるにもかかわらず、数

[22:06 - 22:11]
十億ドル規模の企業であり、

[22:08 - 22:14]
おそらく一部は

[22:11 - 22:17]
恐怖から、一部は

[22:14 - 22:20]
興奮から、しかし全体的には

[22:17 - 22:22]
AI IDE であるという魅力的な理由で事業を拡大していることを示しています。 したがって、

[22:20 - 22:23]
VS Code フォークだけでは

[22:22 - 22:25]
数十億

[22:23 - 22:27]
ドル規模の企業になるには不十分だと言った皆さんは、結局は正しかったのかもしれません

[22:25 - 22:28]
。 それを確かめる方法は 1 つしかなく

[22:27 - 22:30]
、どうなるのか楽しみです

[22:28 - 22:34]
。 あなたの考えを聞かせてください。

[22:30 - 22:34]
それではまた次回、平和オタクの皆さん。

## コメント

### 1. @pigsyes (👍 84)
This video was the first stream I watched, and I was surprised by how the edits with the icons / visual info is so much more helpful to understand the content

### 2. @kevinchambers4416 (👍 111)
I recently used cursor for a react project and it boosted my productivity by 10x. Then when i actually looked at the code, it was a horrible nightmare of  clever anti patterns and bloat that has driven my productivity to zero. To solve any react hooks issue it piles every single possible memo, etc into a glob of self contradicting nonsense while assuring me it knows exactly what the problem is. 
How on earth do i even begin to fix any of this?

> **@StCost** (👍 24): you had to check and remember each suggestion before commiting. rookie mistake

AI is condifent in solution of wrong task we give to him

> **@retagainez** (👍 0): Have you tried Codescene ACE? Not sure if it would help solve your issues with Cursor (doubt it), but it might help you begin cleaning up that tech debt.

> **@tibbydudeza** (👍 1): Yep reminds me of 4GL systems that generated code in C++ until that sad day you where boxed in and started looking at the code to add something 😂

> **@iverbrnstad791** (👍 3): @@StCost That's my reason for feeling more productive with just a regular chat window, often typing the result myself, it slows me down initially but it does help me be more aware of what I'm grabbing. It's not like code writing itself is my productivity bottleneck, so I'd rather go a bit slower and be sure I know what is happening, at least until AI is good enough for true vibe coding of non-trivial projects. With tools like cursor I find that I get so removed that when it goes wrong it feels like I'm helping a coworker fix a bug, rather than my own.

> **@akrishnadevotee** (👍 1): I have the same issue. It gets frustrating when you wanna change something simple. All the over-engineered code is not fun, it's instant tech debt.

I've reverted to mostly coding on my own and just using the AI (which I know will mess my code up) 20-30% of the time.

### 3. @lightning_11 (👍 26)
50 conflicted keybinds as soon as a new feature comes out is so real. I'm glad your editor left that part in.

### 4. @samuelreichor3156 (👍 102)
If you mention Cursor I'm always waiting for "I'm actually an investor" :D

> **@matti592** (👍 6): "Very early investor" 8)

> **@ashnwor** (👍 2): I think he is legally obligated to tell that

> **@nl4260** (👍 3): Transparency. If i find out someone's platform is used to shill for their own investments without being upfront, I would stop watch and I would distrust the source.

> **@imfunnyjack** (👍 0): How to invest in Cursor then?

> **@polymathcompass** (👍 0): 😂

### 5. @Caldaron (👍 19)
about mcp/context7: all the llms i've tried have outdated information about yq (mikefarrah) so having an easy way to update their knowledge is kinda cool.
especially when you use tools that had API changes in newer versions and the llm knowledge cutoff wasn't able to cover that.

> **@SahilP2648** (👍 0): I have created an MCP for auto project code documentation for wiki js. It works really really well.

> **@Caldaron** (👍 0): @@SahilP2648 got a link?

### 6. @SoleAddictions (👍 20)
Cursor is amazing when you want to break your project down and really get into it , I personally think Claude code CLI from Anthropic is the most advanced agent out there. It’s truly amazing. I try not to use it because it’s so expensive (been getting better actually) , but when I have a huge code base and just need to make a quick change, Claude code has been great

> **@josephvictory9536** (👍 0): Jules is good too, not as good as claude code, but its 5 tasks free and a good second option. It will boot a VM make changes and then submit a branch for PR. Super good for simpler stuff, and workable with medium level requests.

### 7. @nthngnsz (👍 1)
Love your videos! They made me jump into the rabbit hole of AI, not just as a user but as a developer. Because of you motivating us I now have knowledge about how LLMs work, how I can build clean, dynamic context for AI chat integrations in software, how to build custom tools for use within AI chats and much more. Yes, I sunk lots of time  into building that knowledge as well, but it is more than worth it. If not for getting or keeping jobs, then at least for the experience. 

Keep up the good work!

### 8. @andresshamis4348 (👍 0)
I was just invited to a cursor event for being in the top 1% users in Madrid!

### 9. @cinzya (👍 0)
MCPs are very poweful if you work at bigger companies where every department works in different tools / platforms but you still need to draw context from it.
E.g. designs on Figma, issues / tasks on Trello, Google Docs etc. So your AI agent can start to draw information from all those places by itself and take that into consideration during the process.
I personally haven't been in that position yet, but having a MCP connection to e.g. your databases could also speed up debugging.

### 10. @SanderCokart (👍 22)
2.0 flash gets me the fastest responses for very simple things and does not suffer from slow cursor requests

> **@pechkurofff** (👍 3): 2.5 flash is better tho, no?

> **@SanderCokart** (👍 0): 2.0 is instant where 2.5 flash is not. Plus for simple tasks flash 2.0 is good enough. And there is no waiting line even if i run out of fast requests. 2.5 pro can take over 5 minutes on slow request mode @@pechkurofff

> **@homegood416** (👍 0): @@pechkurofffit is so dumb, it cant use tools, it doesnt follow the request, it just gives you generic answer or make wrong edits. At the end i usually just switch back to claude because of frustration

> **@pechkurofff** (👍 0): @@homegood416 ok thx

> **@joseph_gerald** (👍 0): the diffusion model is even worse though the performance is impressive

### 11. @BrianBest (👍 2)
deep linking to a prompt sounds like an interesting prospect

### 12. @alexbasic9776 (👍 10)
Task Master MCP is a Must! Would love to see you look through it Theo^^

### 13. @chillsoftware (👍 0)
I work in big tech and one thing we’ve been needing quite ubiquitously is an MCP for searching large SQL DBs or databricks.

Democratizing data to non technical folks frees up a ton fo time for data engineers

### 14. @egalanos (👍 2)
I've been using Claude code now with a git worktree wrapper (that creates the new worktree + sets it up with package installs, copy some ignored data, customise VS code titlebar colour, & open new window).

I haven't been able to really take advantage of the parallelism it can offer yet. The biggest bottleneck is specifying changes & steering/reviewing it. Building repo instructions + docs + prompt template libraries is getting there, but it's still a lot of work to get it to produce exactly what you want.

### 15. @martinbechard (👍 5)
MCP isn’t very useful for an IDE-driven process which can just call shell commands anyway. But from the Claude App you can have a single Claude response call MCPs multiple times in quick succession which is hyper efficient

> **@SahilP2648** (👍 1): I have created an MCP for auto project code documentation and it works really well. Let me know if you want to use it.

### 16. @dmitriikrasnov3412 (👍 0)
In 1880s, rule-based AI failed because encoding every rule manually was far beyond human capacity. We now know how to make LLMs capture broad “common knowledge”, but task-specific context still has to be fed in manually. 

As an engineer, I rely on a ton of knowledge, but I'd bet I won't be able to articulate most of it, so I still run into that same limitation.

That's why I'm very excited about the progress in MCPs and memory. Once LLMs will be able to automatically collect the relevant task-specific knowledge from all our dev tools: metrics, task managers, logs, slack, etc, -- and learn from them, they’ll become dramatically more helpful

So cool to see that taking shape!

### 17. @bluzytrix (👍 0)
Bro, Sentry mcp + Atlassian mcp gives you bug specific context that's easy to push updates directly to jira while solving the problem. No more need to go into jira nor sentry

### 18. @Aminsx_ (👍 0)
Mcp is super useful for implementing a Tavily API key and allow the models to query the internet

### 19. @heavylog1c (👍 0)
I wish Cursor would add some unique features from IntelliJ (and make them optional, of course):
1. Ctrl+Z behavior. It should act like "Go to Last Edit Location" if line is not in the view.
2. When you put caret on some bottom bracket, but top one is not in the view, you will see a tooltip with line of code on the top. It looks like "sticky scroll header", but it's not. And it works with more things like "if - else" or "switch", not just with classes and functions.
3. Tooltips in Cursor are annoying, so I disable them. But sometimes I want them. In IntelliJ it's "hold Ctrl to see tooltips" by default.
4. Highlight opening and closing tags in HTML when you put caret on them, even if HTML is inside string var.

### 20. @SpragginsDesigns (👍 1)
Once you have an MCP setup to your database it's a complete game changer. Obviously just be careful and don't always allow when it can modify your database, but always allow reading it.

> **@SahilP2648** (👍 1): It doesn't work at all if it starts fetching a ton of data. If you want simple counts it is ok.

> **@SpragginsDesigns** (👍 0): That's not true. You can LIMIT the query to ensure it doesn't overload the context. ​@@SahilP2648

