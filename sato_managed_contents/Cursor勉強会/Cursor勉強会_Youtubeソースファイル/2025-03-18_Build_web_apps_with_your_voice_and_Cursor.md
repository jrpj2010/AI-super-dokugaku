# Build web apps with your voice and Cursor

**チャンネル:** Sanity
**公開日:** 2025-03-17
**URL:** https://www.youtube.com/watch?v=j6zrfJ56KYE

## 説明

Learn how anyone can use an AI-powered code editor to build a Sanity Studio with best-practice code and the front end of your choice.

Complete this course on Sanity Learn for a shareable certificate
https://www.sanity.io/learn/course/code-with-ai

Download Cursor
https://www.cursor.com/

Download Superwhisper
https://superwhisper.com/

00:00 Introduction
01:09 What makes a good prompt?
03:47 Cursor and other code editors
06:06 Prompting with Ask and Agent
10:44 Speaking prompts
11:45 Rules for enforcing best practices
16:05 Creating placeholder content
18:03 Prompting any front end 
24:51 Closing thoughts

## 字幕

[00:00 - 00:04]
コーディングはもはや開発者だけのものではあり

[00:02 - 00:06]
ませんが、AI ツールがすべてを実行してくれるわけではありません。

[00:10 - 00:13]
開発のペースと品質を向上させるには、これらの AI ツールの仕組みについて十分に理解することが最善です。このビデオでは、Sanity Learn の

[00:12 - 00:15]
AI を活用した

[00:13 - 00:17]
Sanity 開発コースの基本を取り上げます。

[00:17 - 00:20]
ステップ バイ ステップの手順を確認し、

[00:18 - 00:22]
タスクを完了するたびにチェックマークを付けて、

[00:22 - 00:26]
このビデオで提供されているものよりも最新のガイダンスを確認したい場合は、sanity.io learn にアクセスして

[00:24 - 00:28]
コースを見つけ、

[00:26 - 00:30]
ステップ バイ ステップで進めることができます。以前は、

[00:30 - 00:33]
アプリケーションのコンテンツのアイデアがある場合、望む結果を得るためには、コーディング方法を知っていて

[00:31 - 00:35]
、記述するコード行を記憶する必要がありましたが、今ではそうではありません。

[00:40 - 00:44]
必要なアプリケーションを構築するために、ユース ケースを説明できます。これは、

[00:42 - 00:46]
新しい開発者にとっては一歩前進ですが、

[00:44 - 00:48]
経験豊富な開発者にとってはロケット ブースターになります。

[00:48 - 00:51]
アプリケーションの記述方法をコード化して、

[00:49 - 00:53]
基本的にアプリケーションを自動的に記述させながら、

[00:53 - 00:58]
必要に応じて 1 行ずつ介入できるためです。 これまで、

[00:55 - 01:00]
Sanity Poweredコンテンツアプリケーションの構築にAIが必要だったことはありませんでしたが、

[00:58 - 01:02]
オール

[01:00 - 01:04]
コード構成のため、

[01:02 - 01:07]
AIを活用した開発に最適です。AI

[01:04 - 01:08]
ツールの活用の中核はプロンプトです。では、

[01:07 - 01:10]
良いプロンプトとは何かを考えてみましょう。

[01:10 - 01:14]
コンピューティングの歴史を通して、一貫した入力を与えれば、

[01:12 - 01:16]
一貫した出力が得られます。

[01:14 - 01:18]
なぜなら、それはコンピューターだからです。しかし、

[01:16 - 01:19]
AIツールではもはやそうではありません。

[01:18 - 01:21]
プロンプトを作成し、それを様々なモデルにフィードすることで、

[01:19 - 01:23]
多少

[01:21 - 01:25]
異なる応答を得ることができます。これは、

[01:25 - 01:29]
大規模言語モデルを扱う際の魔法であり、フラストレーションでもあります。そのため、

[01:29 - 01:32]
良いプロンプトを作成することが、

[01:30 - 01:34]
プロンプトエンジニアになるために、そして、

[01:32 - 01:36]
どのモデルと話していても、予測どおりに良い応答を得ることの意味を理解することが極めて重要になります。

[01:36 - 01:41]
より良いプロンプトを作成するためのヒントをいくつか紹介します。

[01:38 - 01:43]
まず、ギャップを埋めましょ

[01:50 - 01:55]
う。大規模言語モデルは非常に多くのことを知っていますが、すべてを知っているわけではありません。特に、あなたが伝えていないことは理解できません。おそらく、チャットGPTなどにプロンプ​​トを作成した経験は既にあるでしょう。これは、

[01:51 - 01:57]
悪いプロンプトの例です。ブログを書いてください。

[01:55 - 01:59]
すぐに応答が得られました。

[01:57 - 02:01]
ありがたいことに、より詳細な情報を尋ねています

[01:59 - 02:03]
が、必ずしもそうとは限りません。

[02:01 - 02:04]
一部のモデルは、

[02:03 - 02:06]
与えられた質問を受け取り、役立つ可能性のある追加のコンテキストを無視して、すぐに何かを構築し始めます。

[02:08 - 02:12]
大規模言語モデルは多くのことを知っていますが、

[02:10 - 02:14]
知識にギャップがあります。

[02:14 - 02:18]
最新の API を知っているという技術的なギャップもありますが、間違いなく

[02:16 - 02:20]
コンテキストのギャップがあります。構築したいものを正確に把握しており、

[02:18 - 02:22]
伝えなければ

[02:20 - 02:24]
理解できず、

[02:22 - 02:26]
詳細情報を尋ねることなく先に進む可能性があります。その

[02:24 - 02:28]
ため、

[02:26 - 02:29]
プロジェクトのこの段階では、伝えるのではなく質問することが良い習慣です。

[02:28 - 02:31]
必要なことをすべて知っているとは限りませんが、

[02:29 - 02:33]
大規模言語モデルは

[02:31 - 02:35]
これらのアイデアのブレインストーミングに非常に役立ちます。そのため、

[02:33 - 02:37]
最初に時間を取って、構築しようとしている

[02:35 - 02:38]
ものを計画し、

[02:38 - 02:42]
すぐに構築フェーズに進むのではなく、プロジェクト計画を立てるのが最善です。構築を

[02:40 - 02:44]
開始したら、それに応じて

[02:42 - 02:47]
期待値を設定することが非常に重要です。AI は

[02:44 - 02:49]
人間ではありません。

[02:47 - 02:51]
人間のように話し、人間のように見えます。そして、

[02:52 - 02:56]
一緒に作業しているのが誰かだと信じたくなるかもしれませんが、それは人間ではなく、コンピューターではありません。

[02:54 - 02:58]
これは、私たち全員が受け入れつつある曖昧なブラックボックスのようなもので、

[02:58 - 03:02]
あなたに代わって

[03:00 - 03:04]
フレンドリーに質問に答えてくれます。しかし同時に、

[03:04 - 03:09]
人間がやったら

[03:06 - 03:10]
すぐに信頼を失ってしまうような、自信満々に嘘をつくこともあります。ですから、

[03:09 - 03:12]
これを

[03:10 - 03:14]
人間だとか常に信頼できる存在だと考えないように注意してください。むしろ、

[03:16 - 03:19]
間違った

[03:18 - 03:21]
質問をしたり、あなたが望む

[03:19 - 03:24]
答えを得るための文脈を与えていなかったとしても、どんな質問にも熱心に答えてくれる存在です。

[03:21 - 03:26]
そして最後に、シンプルにしましょう。これは

[03:24 - 03:28]
現実世界で

[03:26 - 03:31]
もデジタル世界でも当てはまります。時間をかけて包括的なプロジェクトドキュメントを作成するのでない

[03:28 - 03:32]
限り、プロンプトは適度に短くしてください。そうすれば、

[03:36 - 03:41]
いつでも参照して短いステップで作業を進めることができます。1

[03:41 - 03:45]
つのプロンプトでプロジェクト全体を計画しようとしないでください。

[03:43 - 03:47]
すべてが勝手に進むのを期待して、ただ座って待つだけです。

[03:45 - 03:49]
これらのルールをすべて念頭に置いて、

[03:47 - 03:51]
構築を始めましょう。このビデオでは、

[03:49 - 03:54]
非常に人気のあるAI搭載コードエディターであるカーソルを使用します。

[03:51 - 03:56]
他にも、

[03:54 - 03:58]
Wind SurfやZedなどがあります。 これらは非常に

[03:56 - 04:00]
人気があり、VSS コードはコード エディター内で AI ツールを使用するというアイデアを普及させました

[04:00 - 04:05]
が、私の意見では、

[04:05 - 04:09]
これらの新しいツールのいくつかに追いついていません。そのため、

[04:09 - 04:12]
このビデオを作成した時点では、コード エディターの中で最も AI ネイティブであると思われる

[04:12 - 04:16]
Cursor が今日使用します。Cursor は Web サイトから無料でダウンロードできます。

[04:14 - 04:17]
有料プランもありますが、

[04:17 - 04:20]
無料プランを使用してこのビデオを完了できるはずです。Cursor を

[04:19 - 04:22]
ダウンロードしてインストールすると、

[04:20 - 04:25]
次のような画面が表示され、

[04:22 - 04:27]
ターミナルを開いて新しい

[04:25 - 04:30]
sanity プロジェクトを開始できます。

[04:27 - 04:31]
この行をターミナルにコピーして貼り付けると、

[04:30 - 04:33]
新しい sanity

[04:31 - 04:35]
プロジェクトが作成されます。チャット

[04:33 - 04:37]
ウィンドウを開いて新しい

[04:35 - 04:38]
sanity プロジェクトの作成を開始することもできますが、私と

[04:38 - 04:42]
同じコード ベースから開始することをお勧めします。これが

[04:40 - 04:44]
私たちが行うことです。

[04:42 - 04:46]
その中心にあるのは、

[04:44 - 04:48]
遅くとも npm create sanity を実行することですが、

[04:46 - 04:50]
ここではいくつかの追加のフラグを選択しました。

[04:48 - 04:52]
ブログ テンプレート スキーマを選択します。

[04:52 - 04:55]
aied sanity という新しいプロジェクトを作成し、データセットの

[04:54 - 04:57]
名前を production にします。Typescript を選択して

[04:55 - 05:00]
、それを AI powered sanity というフォルダに配置します。pnpm を

[04:57 - 05:03]
使用して

[05:03 - 05:07]
依存関係をインストールします。

[05:05 - 05:09]
作成したフォルダ内で、

[05:07 - 05:10]
cursor Dot と入力すると、

[05:10 - 05:14]
cursor 内のこのディレクトリが開きます。ターミナルでこのコマンドが機能しない場合は、

[05:14 - 05:21]
command、shift、p を押してコマンド パレットを開き、「

[05:16 - 05:22]
Shell install cursor」コマンドを入力します。

[05:21 - 05:24]
これで、

[05:22 - 05:26]
新しい sanity プロジェクトのすべてのプロジェクト ファイルが表示されます。sanity

[05:24 - 05:28]
構成ファイルは、

[05:26 - 05:30]
ここで確認できる主要なファイルで、投稿、作成者、カテゴリ、ブロック コンテンツの

[05:28 - 05:32]
スキーマ タイプなど、多くの事前構成済みオプションが含まれています。command、

[05:32 - 05:37]
T を押して

[05:34 - 05:41]
ターミナルを開き、「npm runev」と入力すると、

[05:37 - 05:41]
ローカル開発プロセスを開始し、以前

[05:46 - 05:50]
使用したのと同じ資格情報を使用して sanity Studio にログインできます。

[05:48 - 05:51]
何が起こったのかを簡単に理解しましょう。ローカルで

[05:50 - 05:54]
新しい sanity

[05:51 - 05:56]
Studio プロジェクトを作成し、コードを使用して、sanity でドキュメントを作成するときにコンテンツ レイクと

[05:54 - 05:58]
呼ばれるクラウドでホストされるデータ ストアを作成しました。

[05:58 - 06:01]
Studio では、

[05:59 - 06:03]
コンテンツ レイクに即座に書き込まれます。コンテンツ管理システム

[06:01 - 06:05]
内には、ライブ リアルタイム マルチプレイヤー編集機能があります。

[06:05 - 06:08]
これはすべてコードで設定されています。では、

[06:07 - 06:10]
プロンプトを書き始めましょう。

[06:08 - 06:13]
ファイル ブラウザーを閉じて

[06:10 - 06:14]
ターミナルを閉じ、チャット ウィンドウを開きます。チャット

[06:13 - 06:17]
ウィンドウは、

[06:14 - 06:20]
質問モードではコマンド l、

[06:17 - 06:22]
エージェント モードでコマンド I を押すことで開きます。質問モードでは、

[06:20 - 06:24]
使用するトークンは少なくなりますが、

[06:22 - 06:26]
AI と会話するのは

[06:24 - 06:28]
コード変更を提案されたときだけです。コード変更を

[06:26 - 06:30]
1 つ 1 つ手動でファイルに適用する必要があります。

[06:28 - 06:32]
エージェント モードでは、使用する

[06:30 - 06:34]
トークンはいくつか増えますが、AI が代わりにアクションを実行します。

[06:34 - 06:38]
プロジェクト ファイルへの書き込みと削除を移動します。少し変更を加えたい場合は、

[06:38 - 06:42]
カーソル設定に移動して YOLO モードをオンにすると、

[06:42 - 06:46]
ターミナルでコマンドを実行するための確認を待つ必要がなくなります。何かを入力する前に、

[06:44 - 06:48]
質問モードで最初のプロンプトを記述しましょう。

[06:48 - 06:54]
ここでコンテキストを追加しましょう。コード

[06:52 - 06:56]
ベース全体と、このコード

[06:54 - 06:59]
ベースを調べてプロジェクトについて知っていることを教えてくださいと言うことができます。

[07:00 - 07:02]
応答を確認すると、これがプロジェクトであると

[07:01 - 07:05]
正しく判断されていることがわかります。

[07:02 - 07:07]
Sanity Shudioプロジェクトと

[07:05 - 07:08]
ブログコンテンツモデルについてです。

[07:07 - 07:10]
ブログテンプレートを使用していますが、

[07:08 - 07:12]
Sanity

[07:10 - 07:15]
Studioを拡張したいとします。変更を加える前に、まず質問させてください。

[07:15 - 07:19]
別のプロンプトを入力しました。

[07:17 - 07:21]
これはブログ用のコンテンツ管理システムです

[07:19 - 07:22]
が、私のビジネスには店舗の所在地も含まれています。

[07:22 - 07:27]
これらをどのように表現できると思いますか？ここに、

[07:27 - 07:31]
店舗所在地の新しいコンテンツタイプスキーマの例が表示されています。

[07:30 - 07:33]
これはドキュメントであり、

[07:31 - 07:35]
すべてのフィールドに既に記述されており、すべて

[07:35 - 07:38]
Sanity Studioスキーマの

[07:36 - 07:40]
記述方法が正しく記述されています。

[07:38 - 07:43]
テンプレート内の既存のファイルを使用して、そのタイプの新しいファイルを作成しています。

[07:40 - 07:45]
ただし、1つ問題があります。「

[07:45 - 07:49]
店舗所在地」という名前はあまり好きではありません。「場所」という名前の方が

[07:47 - 07:51]
より一般的で好ましいので、

[07:49 - 07:53]
この会話を続けて、モデルにそのように伝えます。

[07:56 - 08:01]
タイプを再利用したい場合は、「店舗所在地」ではなく「場所」と呼ぶべきだと思います。Go

[07:59 - 08:03]
ポイントにはプラグインが必要であると言われたかもしれませんが、

[08:01 - 08:05]
私の回答でよく見かけますが、それは

[08:03 - 08:07]
違います。 確かにGoogleマップには

[08:05 - 08:09]
プラグインが必要ですが、ジオポイントには必要ありません。

[08:09 - 08:13]
今回のレスポンスには記載されていませんが、過去のレスポンスには記載されています。次のプロンプトを送信しましょう。

[08:12 - 08:15]
単にロケーションと呼ぶべきだと思います。

[08:13 - 08:18]
ここに更新された

[08:15 - 08:20]
スキーマがあります。これは素晴らしいですね。

[08:18 - 08:22]
まさに私が求めていたものです。このレスポンスが

[08:20 - 08:25]
完了したら、

[08:22 - 08:28]
プロジェクトに適用できます。

[08:25 - 08:30]
個別に適用することも、すべて適用することもできます。

[08:28 - 08:32]
ロケーションファイルが

[08:30 - 08:35]
スタジオに書き込まれています。「すべて適用」

[08:32 - 08:37]
ボタンをクリックして

[08:35 - 08:40]
これらのファイルを受け入れましょう。

[08:43 - 08:48]
ここで、すべてのスキーマタイプが読み込まれるスキーマインデックスファイルが表示されます。Sanity Studioに戻ると、ロケーション

[08:45 - 08:50]
ファイルが表示されます。ここで新しいロケーションドキュメントを作成できます。

[08:48 - 08:52]
名前はスラッグ

[08:50 - 08:54]
、住所などです。これが

[08:52 - 08:56]
ロケーションドキュメントスキーマです。必要に応じて

[08:54 - 08:58]
名前をタイトルなどに変更できます。

[08:56 - 09:01]
フィールド

[08:58 - 09:03]
構成はすべて保存されます。これは

[09:01 - 09:04]
AIパワー開発の一種の変曲点です。

[09:03 - 09:06]
以前は

[09:04 - 09:09]
開発者がこれを記述する必要がありましたが、

[09:06 - 09:11]
今はチャットで説明できます。

[09:09 - 09:13]
チャットは機能しますが、エージェントを試してみましょう。エージェントを使えば、「

[09:13 - 09:17]
適用」をクリックすることなく変更を加えることができます。

[09:15 - 09:19]
ここでエージェントモードに切り替えます。

[09:17 - 09:23]
コンテキストはまだありません。

[09:19 - 09:25]
新しいプロンプトを入力します。この

[09:23 - 09:26]
プロジェクトには著者ドキュメントタイプが含まれています。

[09:28 - 09:31]
念のため、その著者ファイルを開いて確認してみましょう。これが私の著者ドキュメントタイプです。これはSanity Studioに

[09:38 - 09:42]
付属していますが、このユースケースには具体的すぎます。より汎用的に人物を表すようにします。プロジェクトの将来的には、すべての人がブログ投稿の作成者になるとは限らないからです。これをエージェントに送信して、変更が反映されるのを確認してみましょう。

[09:45 - 09:48]
このステップの優れた

[09:46 - 09:50]
点は、この著者ファイルだけでなく、

[09:50 - 09:54]
他のファイルの参照も更新することです。他のファイルへの参照は、これだけでは

[09:52 - 09:56]
見落としてしまう可能性があります。

[09:56 - 09:59]
この変更の本当に強力な点は、

[09:57 - 10:02]
コードベース全体にわたって

[09:59 - 10:04]
人物へのすべての参照、例えば

[10:02 - 10:06]
投稿ドキュメントタイプにある

[10:04 - 10:08]
著者への参照が更新されることです。

[10:06 - 10:10]
人物への変更です。これはコード構成ではなく、

[10:08 - 10:12]
スキーマ構成ファイル内の単なる文字列ですが、

[10:10 - 10:15]
エージェントが

[10:12 - 10:18]
すべて処理してくれるので、

[10:15 - 10:20]
これらのファイルを閉じることができます。

[10:18 - 10:22]
これで、作成者ではなく人物レコードが存在することが確認できました。

[10:22 - 10:26]
投稿を作成する必要があります。投稿は参照になります。

[10:24 - 10:28]
フィールド名は

[10:26 - 10:30]
作成者ですが、人物タイプのドキュメントへの参照になります。

[10:28 - 10:32]
これは、

[10:30 - 10:34]
まだデータがないため、強力かつ高速です。

[10:32 - 10:36]
これがコンテンツが既に存在するプロダクションスタジオの場合、

[10:34 - 10:38]
既存の作成者ドキュメントを人物タイプのドキュメントに変更するために、

[10:36 - 10:40]
移行スキームを作成するか、AI Wrer

[10:38 - 10:42]
移行スキームを用意する必要があります。

[10:42 - 10:47]
これまで、私はプロンプトをこれらのチャットウィンドウ

[10:45 - 10:48]
にコピーして貼り付けるだけでした。これは

[10:47 - 10:50]
主に、プロンプトを入力する

[10:48 - 10:52]
のに本当にうんざりしているからです。

[10:50 - 10:53]
これは非常に

[10:52 - 10:55]
面倒に感じます。私は1分間に100語入力できます

[10:53 - 10:57]
が、何らかの理由でプロンプトを書くのが嫌いです。

[10:57 - 11:00]
マイクロマネジメントのように感じます。しかし、

[10:58 - 11:02]
私にとってプロンプトを本当に解き放ったのは、

[11:00 - 11:04]
音声で入力することです。

[11:02 - 11:06]
おそらくOSには既にディクテーション機能がありますが、

[11:04 - 11:08]
AIパワーディクテーションツールがあり、

[11:08 - 11:13]
これまでよりも速くプロンプトするのに非常に便利です。私のお気に入りのAI

[11:11 - 11:15]
搭載ディクテーションアプリはSuper Whisperです。

[11:13 - 11:17]
無料で試すことができます。有料版もあり、他にもいくつか

[11:15 - 11:18]
代替アプリがあります。これは

[11:18 - 11:21]
このコースで使用するものです。Super

[11:20 - 11:24]
Whisperをインストールしたら、プロンプトを次のように記述できます。

[11:24 - 11:27]
このプロジェクトのタイトルはAI搭載ですが、これは

[11:26 - 11:29]
地元のパン屋のブログです。

[11:27 - 11:32]
このプロジェクト内のAIへの参照を私

[11:29 - 11:32]
の

[11:34 - 11:39]
パン屋に更新していただけますか？そうすれば、どれだけ速く実行できたかを確認できます。

[11:37 - 11:41]
これは素晴らしいことです。

[11:39 - 11:44]
変更したいのは、

[11:41 - 11:46]
サニティ構成のタイトルと

[11:44 - 11:48]
パッケージのJSON名の2つのファイルです。これらのAI

[11:46 - 11:51]
ツールがコードを作成するときは、通常、

[11:48 - 11:53]
最も一般的な平均的な

[11:51 - 11:55]
応答を行うか、プロジェクト内の既存のコードに依存して

[11:55 - 11:59]
非常によく似たコードを作成します。そのため、AIにコードの書き方を指示しない限り、

[11:57 - 12:02]
非常に偏ったベストプラクティスを適用することは困難です。

[12:02 - 12:06]
幸いなことに、私は

[12:05 - 12:08]
これらについて非常に強い意見を持っており、

[12:06 - 12:10]
これを

[12:08 - 12:12]
カーソルと呼ばれるものにコード化することができました。 ルールについて、

[12:10 - 12:13]
私はかなり長い間「Sanity Studioの

[12:12 - 12:16]
意見に基づいたガイド」というガイドをメンテナンスしてきました。

[12:13 - 12:17]
以前は、

[12:17 - 12:21]
Sanity Studiosを私と同じように構築したい場合、これらの点を念頭に置く必要がありました。

[12:21 - 12:27]
これらの意見の要約は、

[12:23 - 12:29]
GitHubのAIルールリポジトリにあります。

[12:27 - 12:32]
この意見に基づいたルールファイルを開いて内容をコピーすると、

[12:29 - 12:34]
カーソルに移動して

[12:32 - 12:38]
新しいカーソル

[12:34 - 12:41]
ルールを作成できます。このルールを「Sanity

[12:38 - 12:44]
Opinionated」と名付け、その内容を貼り付けます。

[12:41 - 12:47]
このカーソルルールファイルは、

[12:44 - 12:50]
隠しフォルダ「Incursor Rules Sanity

[12:47 - 12:52]
Opinionated MDC」に保存されています。このリポジトリを再度確認することが重要です。Sanity

[12:56 - 12:59]
プロジェクトを構成するための最良の方法をコード化する新しい方法を見つけるにつれて、これらのルールは最新の状態に保たれます。それでは、

[12:58 - 13:01]
これらのルールを適用してみましょう。

[12:59 - 13:04]
ファイルブラウザを閉じます。

[13:01 - 13:06]
エージェントをもう一度開き、

[13:04 - 13:08]
Sanity Opinionated Rulesを使用して新しいチャットを開始します。index.tsに

[13:06 - 13:09]
インポートされたスキーマタイプファイルをリファクタリングします。

[13:11 - 13:15]
すべてのスキーマタイプ

[13:12 - 13:16]
ファイルを読み取って、Opinionatorガイドのベストプラクティスルールを適用していることがわかります。これには、

[13:18 - 13:22]
ドキュメントタイプ用のアイコンをインポートするのと同じように、オピニオンエイターガイドには

[13:21 - 13:24]
すべてのドキュメントタイプ用のアイコンを追加する方法が含まれています。

[13:22 - 13:26]
ここで、

[13:24 - 13:28]
エージェントはエラーが発生していることを認識します。これは、

[13:26 - 13:29]
Sanity Iconsパッケージがインストールされてい

[13:33 - 13:37]
ないためです。エージェントはインストールを進めますが、残念ながら、アイコンパッケージのインストール方法がわからないため、最後のハードルで失敗しています。

[13:37 - 13:42]
ターミナルを開いて、新しいターミナルウィンドウを取得します。PM

[13:39 - 13:45]
PM install sanity iconsと言うだけです。

[13:47 - 13:52]
残念ながら、

[13:50 - 13:55]
ここでも失敗しています。場所

[13:52 - 13:58]
アイコンがないため、

[13:55 - 14:01]
存在しないアイコンが作成されています。ピンアイコンを使用しましょう。CU

[13:58 - 14:02]
1つ存在することはわかっているので、ここに幻覚が1つあることがわかります。

[14:02 - 14:09]
場所アイコン、はい、

[14:04 - 14:11]
まだ正しくありません。ピンアイコンを使用します。わかりました。

[14:09 - 14:13]
場所アイコンを、本来あるべきでは

[14:11 - 14:15]
ないいくつかの場所で使用しましょう。

[14:13 - 14:18]
ブロック

[14:15 - 14:19]
コンテンツにコードブロックが含まれているようです。これは、

[14:19 - 14:23]
コードを書く場合に役立つブロックですが、Bakeryがコードを書くとは思わないので、

[14:23 - 14:29]
この行を自分で変更することも

[14:25 - 14:32]
できます。 ブロック コンテンツにコードを入力する必要がなく

[14:32 - 14:35]
、そのファイルを参照することもできる

[14:34 - 14:37]
ので、エージェントは私たちが何

[14:35 - 14:39]
について話しているのかを正確に理解できます。また、

[14:37 - 14:41]
場所アイコンがないことをエージェントに伝えることもできました。

[14:39 - 14:44]
これで、すべての

[14:41 - 14:46]
ドキュメント タイプにアイコンがあり、

[14:44 - 14:49]
ここにあるすべての新しいドキュメントにグループがあることがわかり

[14:46 - 14:50]
ます。これは、意見付きガイドの一部です。

[14:50 - 14:55]
検証ルールを持つ必須フィールドがあり、各検証

[14:52 - 14:56]
ルールにはカスタマイズされたエラー メッセージがあります。

[14:55 - 14:59]
ルールを使用して

[14:56 - 15:00]
コードの記述方法をガイドするのと同じように、

[14:59 - 15:02]
外部ドキュメントを参照して、エージェントが

[15:00 - 15:04]
実際には知らないことを伝えることもできます。

[15:02 - 15:06]
良い例の 1 つは、

[15:08 - 15:11]
長い間デスク ツールと呼ばれてきた Sanity Studio 構成の一部である構造ビルダーの構成です。

[15:10 - 15:13]
構造ビルダーをカスタマイズするように要求すると、

[15:11 - 15:15]
おそらく

[15:15 - 15:20]
2024 年 5 月以降関連がなくなった Sanity Desk からデータをインポートします。幸いなことに、

[15:18 - 15:21]
ドキュメントに送信して、

[15:23 - 15:26]
構造ビルダーのチート シートにあるような、より優れた最新の例を取得できます。これで、

[15:29 - 15:33]
Sanity 構成で構造ツール構成を更新し、構造ビルダーの例を使用してくださいというプロンプトを作成できます。

[15:33 - 15:39]
ドキュメントタイプ

[15:36 - 15:39]
名を単数形から

[15:39 - 15:44]
複数形に更新するためのチートシートです。これで、これらの単語の一部をURLに置き換えることができます。URLを

[15:42 - 15:46]
貼り付けるだけで

[15:44 - 15:51]
参照され、

[15:46 - 15:53]
Sanity設定ファイルも参照できます。

[15:51 - 15:56]
残念ながらアイコンが消えてしまった

[15:53 - 16:00]
ので、そのことを伝えることができます。

[15:56 - 16:00]
すべてのドキュメントタイプにアイコンがあることを確認してください。

[16:01 - 16:05]
これで、ドキュメントタイプに

[16:02 - 16:06]
投稿、人、カテゴリ、場所が追加されました。

[16:06 - 16:10]
コードでこの設定をすべて素早く作成できましたが、

[16:08 - 16:12]
AIツールを使用してコンテンツを作成することもできます。

[16:10 - 16:15]
さあ、Sanity

[16:12 - 16:17]
プロジェクトのデータセットをエクスポートすると、endd

[16:15 - 16:19]
JSONファイル形式になります。このファイルでは、すべてのドキュメントが

[16:17 - 16:21]
1行のJSONとして表され、

[16:19 - 16:23]
それらでいっぱいの大きなドキュメントになります。AIを

[16:21 - 16:26]
使用してこれらのドキュメントの1つを生成し、

[16:23 - 16:30]
Sanity Studioにインポートします。

[16:26 - 16:32]
エージェントモードで新しいチャットを開きましょう。コンテンツモデルを

[16:32 - 16:35]
検証できるように、プレースホルダーコンテンツを作成する必要があります。scheme of

[16:35 - 16:39]
typesディレクトリ内のすべてのコンテンツタイプを確認します。ND

[16:37 - 16:41]
JSONファイルを作成し、それを本番

[16:39 - 16:42]
データセットにインポートします。インポートを実行するときに、

[16:42 - 16:47]
既存のドキュメントIDを上書きします。

[16:45 - 16:50]
オピニオン

[16:47 - 16:52]
ルールではプロンプトを入力できます。ここで、

[16:50 - 16:55]
これらの参照のいくつかを更新します。これは

[16:52 - 16:57]
オピニオンルールであり、スキーマタイプ

[16:55 - 16:59]
ディレクトリです。これは実際には ND

[16:57 - 17:02]
Json ファイルであり、理解できる形式です。

[17:03 - 17:07]
モデルがプレース

[17:05 - 17:09]
ホルダーコンテンツを作成していることがわかります。  ND

[17:07 - 17:11]
Jsonファイルがあり、それをインポートするコマンドが提供されるはずです。

[17:11 - 17:15]
このドキュメントは自動的にインポートされ、

[17:15 - 17:18]
これらのアセット

[17:18 - 17:23]
もアップロードされています。これは素晴らしいことです。画像付きの投稿が3つ作成され、

[17:21 - 17:25]
クリックすると表示

[17:23 - 17:28]
されます。

[17:25 - 17:29]
参照の保存方法で問題が発生したため、著者では

[17:28 - 17:31]
なく参照

[17:29 - 17:34]
、

[17:31 - 17:38]
カテゴリではなく参照と呼ばれているようです。著者とカテゴリの参照に正しい型名を使用していることを確認してください。

[17:40 - 17:43]
これで

[17:42 - 17:46]
修正されました。戻って

[17:43 - 17:48]
投稿リストを確認できます。人々にジャンプできます。プロンプトに

[17:48 - 17:51]
さらにコンテキストを追加して、このプレース

[17:50 - 17:54]
ホルダーコンテンツは

[17:51 - 17:56]
パン屋を表すか、10件の投稿を作成して20人の

[17:54 - 17:58]
人を作成するように指示することもできます。それはあなた次第ですが、

[17:56 - 18:00]
ここでダミーデータが

[17:58 - 18:02]
機能していることがわかります。これにより、

[18:02 - 18:05]
このコンテンツをレンダリングするために選択したフロントエンドをテストするのがはるかに簡単になります。これからは、

[18:05 - 18:09]
サニティコンテンツのフロントエンドをAIに構築させます。これは、私がこれ

[18:07 - 18:11]
までに

[18:09 - 18:13]
書いたりビデオに録画したりしたすべてのチュートリアルのエキサイティングな部分です。私は常に

[18:11 - 18:15]
正確な手順を示してきました。

[18:13 - 18:17]
これらを完了するために必要な手順を実行すると、

[18:15 - 18:18]
私と同じ結果が得られます。

[18:17 - 18:20]
ただし、このビデオでは、これから行う内容とは

[18:18 - 18:22]
異なることを強くお勧めします。

[18:22 - 18:25]
私が選択するフレームワークは、私があまり

[18:23 - 18:27]
詳しくないものです。これは、好きなことを何でもできることを強調したいためです。

[18:29 - 18:33]
別のフレームワークを使用する場合は、それを使用してください。

[18:31 - 18:35]
現在、プロジェクトのルートには sanity Studio 構成ファイルがあります。これから

[18:35 - 18:40]
行うことは、スタジオ

[18:37 - 18:42]
に大きな、場合によっては危険な変更を加えることです。

[18:40 - 18:44]
これらの

[18:42 - 18:46]
フォルダーをすべて studio というディレクトリに配置します。

[18:44 - 18:49]
この時点で、プロジェクトに取り消し不可能な変更を加える可能性があります。

[18:49 - 18:54]
エージェントがこれらの

[18:52 - 18:56]
変更を行いますが、

[18:54 - 18:58]
大きな混乱が生じる可能性もあります。そのため、

[18:56 - 19:00]
Git に精通している場合は、

[18:58 - 19:03]
今すぐコミットすることをお勧めします。

[19:00 - 19:06]
ターミナルとファイル ブラウザーを閉じて、

[19:03 - 19:08]
新しいチャットでエージェントを戻します。

[19:06 - 19:10]
現在、このプロジェクトのルートには sanity studio がありますが、

[19:10 - 19:14]
後でフロントエンドも追加し、すべてのプロジェクト

[19:12 - 19:16]
ファイルを Studio という独自のフォルダーに移動します。

[19:14 - 19:18]
ルートに新しい read me を追加します。package.json を追加しますが、

[19:16 - 19:22]
ルートでは無視されます。

[19:18 - 19:22]
フロントエンド コードは記述しないでください。

[19:26 - 19:31]
ここで音声プロンプトに 1 つ調整を加えて、

[19:29 - 19:34]
小文字の s を大文字にします。

[19:31 - 19:36]
ただし、これを放置すると

[19:34 - 19:38]
大文字の

[19:36 - 19:40]
名前が使用されるため、プロンプトを作成するのに少し試行錯誤が必要でした。

[19:40 - 19:44]
コードが重複することがあり、

[19:44 - 19:47]
尋ねられることなく NextJS フロントエンドの構築が開始されることもありました。

[19:46 - 19:49]
プロンプトを作成することで多くのことを学ぶことができます。そのため、

[19:49 - 19:54]
いつでも元に戻せる状態を用意することが重要です。

[19:52 - 19:55]
これらの変更を受け入れる前に、

[19:54 - 19:59]
行われたことをよく確認しましょう。

[19:55 - 20:01]
新しい read me ファイルは次のとおりです。ここに

[19:59 - 20:03]
私のスタジオ ディレクトリがあります。

[20:01 - 20:04]
ありがたいことに、Node.js モジュールがここに移動されました。これは

[20:03 - 20:06]
このプロンプトでは常に発生するわけではありませんが、

[20:04 - 20:08]
Sanity Studio は

[20:06 - 20:10]
継続されます。そのため、

[20:08 - 20:12]
これらの変更を受け入れ、

[20:10 - 20:15]
いくつかのものを移動するために、チャット

[20:12 - 20:16]
ウィンドウを閉じ、すべてのファイルを閉じ、ターミナルを戻して、

[20:18 - 20:24]
前に実行されていた開発プロセスに戻ります。

[20:20 - 20:29]
スタジオに入り、npn runev をもう一度実行すると、

[20:24 - 20:29]
スタジオを実行できるはずです。

[20:30 - 20:34]
ブログも再び表示され、

[20:32 - 20:35]
ドキュメントもすべて残っています。コンテンツは

[20:34 - 20:37]
コードから分離されているので、コードは

[20:35 - 20:39]
常にそこに存在するはずです。

[20:37 - 20:40]
次は、選択したフロントエンドを構築します。

[20:40 - 20:47]
ターミナルを閉じて、新しいエージェント

[20:43 - 20:50]
チャットを開き、このプロジェクトの

[20:47 - 20:52]
Web フォルダを使用して新しい空の Astro Web サイトを作成するなどと入力します。

[20:50 - 20:54]
これは、

[20:54 - 20:57]
Sanity Studio で行ったようにベストプラクティスのスターターが必要な場合は、

[20:57 - 21:01]
ターミナルから実行するコマンドを見つけることもできますが、今回は

[20:59 - 21:04]
AI を信頼して、

[21:04 - 21:08]
可能な限り最高の Bare Bones Astro テンプレートを取得します。Web ディレクトリ

[21:06 - 21:11]
に移動して npm

[21:08 - 21:15]
run

[21:11 - 21:15]
Dev を実行するように指示されているのがわかります。これをここで実行できます。

[21:15 - 21:21]
次に、

[21:18 - 21:21]
ローカルホスト 4321 で Web フロントエンドを開き、

[21:21 - 21:24]
Astro サイトを表示します。

[21:24 - 21:29]
ターミナルを閉じて、

[21:27 - 21:31]
Sanity コンテンツを Astro プロジェクトに取り込む前に、もう少し詳細を尋ねます。

[21:31 - 21:36]
コードでもいいので、

[21:33 - 21:38]
Sanity から Astro フロントエンドにコンテンツをインポートする方法をどの程度理解しているか教えてください。

[21:38 - 21:42]
これにより、

[21:40 - 21:44]
AI が 2 つのテクノロジーのつながりについて何を知っているかを明確にすることができます。

[21:42 - 21:45]
また、

[21:45 - 21:49]
ドキュメントを参照する必要がある場合があります。あまり明確に理解してい

[21:47 - 21:51]
ない場合はテンプレートを参照する必要があるかもしれませんが、

[21:49 - 21:52]
答えはほぼ適切と思われます。Sanity

[21:52 - 21:56]
クライアントを使用し、クエリの作成には Grock を使用します。

[21:54 - 21:58]
では、時間の都合上、

[21:56 - 22:00]
Sanity

[21:58 - 22:03]
コンテンツを取得して、大きなプロンプトで Astro サイトに配置しましょう。

[22:03 - 22:07]
すばらしいですね。Sanity

[22:04 - 22:09]
構成ファイルで、

[22:07 - 22:10]
Sanity Studio のプロジェクトの詳細、スキーマ タイプ、

[22:10 - 22:15]
使用可能なドキュメント タイプ、

[22:13 - 22:17]
Gro クエリの作成方法に関する独自のルールを確認してください。次に、最新のブログ投稿

[22:15 - 22:19]
のみをクエリするように Astro フロントエンドを更新します。

[22:19 - 22:24]
ホームページにブログ投稿を単純なリストとして表示します。個々のルートを作成しません。

[22:21 - 22:27]
最初のブログ投稿。

[22:27 - 22:33]
他のアクションを実行する前に、この小さなタスクが機能することを確認したいので、

[22:30 - 22:35]
これは大きなプロンプトですが、

[22:33 - 22:36]
今は

[22:35 - 22:39]
確認したいだけなのでシンプルにしておきます。

[22:36 - 22:41]
1回のフェッチが実行可能かどうか確認してから、

[22:39 - 22:43]
残りの処理を実行できるということです。

[22:41 - 22:44]
ブログ全体を構築するように指示すれば、おそらく自動的に実行さ

[22:43 - 22:46]
れるでしょう。しかし、

[22:48 - 22:51]
プロジェクト全体をすぐに壊してしまうリスクを冒すよりも、今すぐ元に戻せる小さなステップを踏む方が良いでしょう。そこで、読みやすさの

[22:50 - 22:54]
ために、ここにいくつかの手順を追加してみましょう。Sanity 構成

[22:51 - 22:57]
ファイルは

[22:54 - 22:57]
sanity config です。

[23:00 - 23:03]
スキーマ

[23:10 - 23:15]
タイプとオピニオン

[23:21 - 23:26]
ルールの内部からインデックスファイルを取得し、残りの処理を実行します。Sanity

[23:34 - 23:38]
構成ファイルからプロジェクトの詳細を取得していることがわかります。

[23:36 - 23:40]
利用可能なドキュメントタイプを理解しています。Gro クエリの

[23:38 - 23:41]
記述方法と、

[23:41 - 23:46]
ドキュメントのフェッチと

[23:47 - 23:53]
画像のレンダリングに必要なパッケージを理解しています。Sanity クライアント構成を作成していることがわかります。

[24:17 - 24:21]
現在はいくつかの TypeScript タイプを修正しているところですが、

[24:18 - 24:23]
残念ながら

[24:21 - 24:26]
ルールにある Sanity Type Gen は使用されていません。しかし、

[24:27 - 24:32]
今はそのままにしておきます。Rout

[24:29 - 24:33]
ディレクトリから開発サーバーを実行しようとしているようですが、これは

[24:32 - 24:35]
正しくなく、よくわかりません。

[24:33 - 24:37]
すでに実行されており、

[24:35 - 24:39]
ホームページが

[24:37 - 24:40]
更新され、以前の CSS がすべて削除されていることがわかります。Tailwind を

[24:40 - 24:44]
インストールする必要があります。Tailwind にインストールするように依頼することもできます

[24:42 - 24:46]
が、Sanity コンテンツは

[24:44 - 24:48]
Astro フロントエンドで取得されており、

[24:46 - 24:50]
Astro の使い方はわかりませんが、うまく機能

[24:48 - 24:51]
しています。

[24:51 - 24:55]
この時点から、

[24:55 - 25:00]
このフロントエンドの残りの部分、または夢の Sanity を

[24:58 - 25:02]
活用したコンテンツ アプリケーションを構築するのは、あなたと AI 次第です。

[25:00 - 25:04]
このコースが役に立ったことを願っています。

[25:02 - 25:05]
何か抜けがある場合は、

[25:04 - 25:07]
下のコメントに返信するか、

[25:05 - 25:11]
Sanity Learn に関するフィードバックをお送りください。

[25:07 - 25:11]
次回のコースでお会いしましょう。

## コメント

### 1. @simeonGriggs (👍 4)
Prefer something other than Cursor? Sound off in the comments! 👇

> **@elliscaicedo9045** (👍 1): cursor its the best

> **@simeonGriggs** (👍 0): @@elliscaicedo9045 🤝

### 2. @ajmalafif (👍 1)
I‘ve always wished theres a way to create this placeholder content (coming from way back in WordPress, Rails back then) and so glad to learn about this!

### 3. @mattitswesty (👍 2)
Love this, would love to see it with nextjs (even though you always use it!) alongside Windsurf - my main question is what should I build in nextjs and what should be in Sanity? It would be great to show a front end with next/astro and the elements you keep within Sanity (should any page elements be editable in Sanity) thanks a lot

> **@simeonGriggs** (👍 1): I'd keep your front end and Sanity code entirely separate—other than integrating Visual Editing. Ideally, your content model in Sanity describes your *organization*, not your *website*.

### 4. @fredbyron6944 (👍 3)
Thanks. Prefer Cline most of the time.

> **@simeonGriggs** (👍 1): Oh nice, haven't seen that one before—adding it to the list!

